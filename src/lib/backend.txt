import functions_framework
import pymysql
import json
import requests
import logging
import traceback
import io
import os
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseUpload
from google.cloud import storage
import pandas as pd 
from datetime import datetime

# üîß Conexi√≥n a MySQL
def get_connection():
    return pymysql.connect(
        user="zeussafety-2024",
        password="ZeusSafety2025",
        db="Zeus_Safety_Data_Integration",
        unix_socket="/cloudsql/stable-smithy-435414-m6:us-central1:zeussafety-2024",
        cursorclass=pymysql.cursors.DictCursor
    )

## Funci√≥n de Subida a Cloud Storage (LOCAL STORAGE)
# Variables globales para el cliente y el bucket de GCS
storage_client = storage.Client()
BUCKET_NAME = "archivos_sistema"
GCS_FOLDER = "incidencias_areas_zeus"

def upload_to_gcs(file):
    """
    Sube un archivo a Google Cloud Storage y devuelve la URL p√∫blica.
    Args: file: El objeto de archivo multipart/form-data.
    Returns: La URL del archivo subido o None si hay un error.
    """
    try:
        bucket = storage_client.bucket(BUCKET_NAME)
        # La ruta del archivo en el bucket
        object_name = f"{GCS_FOLDER}/{file.filename}"
        blob = bucket.blob(object_name)

        # Sube el archivo directamente
        blob.upload_from_file(file, content_type=file.content_type)
        
        # Genera la URL p√∫blica
        gcs_url = f"https://storage.googleapis.com/{BUCKET_NAME}/{object_name}"
        return gcs_url
    except Exception as e:
        print(f"Error al subir a Cloud Storage: {e}")
        return None
    
# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE CONTEO MALVINAS / CALLAO
# =======================================================================
# ***********************************************************************

# ============================================================
# FUNCION ASIGNAR INVENTARIO
# ============================================================
def asignar_inventario(data):
    """
    Asigna un nuevo inventario
    """
    try:
        # Validar que lleguen los campos m√≠nimos requeridos
        # Verificar que los campos existan y no est√©n vac√≠os
        required_fields = ['numero_inventario', 'contrasena', 'area', 'autorizado_por']
        missing_fields = []
        
        for field in required_fields:
            value = data.get(field)
            # Verificar que el campo exista y no est√© vac√≠o (None, '', o solo espacios)
            if not value or (isinstance(value, str) and not value.strip()):
                missing_fields.append(field)
        
        if missing_fields:
            return {
                'success': False,
                'message': f'Faltan campos obligatorios: {", ".join(missing_fields)}'
            }

        conn = get_connection()
        cursor = conn.cursor()
        
        # Llamar al stored procedure
        cursor.callproc('sp_asignar_inventario', [
            data['numero_inventario'],
            data['contrasena'],
            data['area'],
            data['autorizado_por'],
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        # Obtener resultados
        cursor.execute('SELECT @_sp_asignar_inventario_4, @_sp_asignar_inventario_5')
        result = cursor.fetchone()
        
        conn.commit()
        
        if result['@_sp_asignar_inventario_4'] > 0:
            return {
                'success': True,
                'inventario_id': result['@_sp_asignar_inventario_4'],
                'message': result['@_sp_asignar_inventario_5']
            }
        else:
            return {
                'success': False,
                'message': result['@_sp_asignar_inventario_5']
            }
            
    except Exception as e:
        # Devolver el error de forma controlada para que el frontend pueda verlo
        logging.error(f"Error en asignar_inventario: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al asignar inventario',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION UNIRSE AL INVENTARIO
# ============================================================
def unir_colaborador_inventario(data):
    """
    Une un colaborador a un inventario activo
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.callproc('sp_unir_colaborador_inventario', [
            data['numero_inventario'],
            data['nombre_colaborador'],
            data.get('rol', 'contador'),
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_unir_colaborador_inventario_3, @_sp_unir_colaborador_inventario_4')
        result = cursor.fetchone()
        
        conn.commit()
        
        if result['@_sp_unir_colaborador_inventario_3'] > 0:
            return {
                'success': True,
                'colaborador_id': result['@_sp_unir_colaborador_inventario_3'],
                'message': result['@_sp_unir_colaborador_inventario_4']
            }
        else:
            return {
                'success': False,
                'message': result['@_sp_unir_colaborador_inventario_4']
            }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION INICIAR CONTEO
# ============================================================
def iniciar_conteo(data):
    """
    Inicia un conteo (por cajas o por stand)
    """
    try:
        # Validar campos requeridos
        required_fields = ['numero_inventario', 'almacen_id', 'registrado_por', 'tipo_conteo']
        missing_fields = []
        
        for field in required_fields:
            value = data.get(field)
            # Verificar que el campo exista y no est√© vac√≠o (None, '', o solo espacios)
            if not value or (isinstance(value, str) and not value.strip()):
                missing_fields.append(field)
        
        if missing_fields:
            return {
                'success': False,
                'message': f'Faltan campos obligatorios: {", ".join(missing_fields)}'
            }

        conn = get_connection()
        cursor = conn.cursor()
        
        # Convertir tienda_id a None si viene vac√≠o
        tienda_id = data.get('tienda_id')
        if tienda_id == '' or tienda_id == 'null' or tienda_id is None:
            tienda_id = None
        else:
            try:
                tienda_id = int(tienda_id)
            except (ValueError, TypeError):
                tienda_id = None
        
        # Obtener inventario_id desde numero_inventario
        cursor.execute("SELECT id FROM inventarios WHERE numero_inventario = %s", (data['numero_inventario'],))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {
                'success': False,
                'message': f'No se encontr√≥ el inventario con n√∫mero: {data["numero_inventario"]}'
            }
        
        inventario_id = inventario['id']
        
        # VALIDACI√ìN: Verificar si ya existe un conteo del mismo tipo para este inventario, almac√©n y tienda
        # IMPORTANTE: La validaci√≥n debe ser espec√≠fica por tipo_conteo (por_cajas o por_stand)
        # Esto permite: 1 conteo por_cajas + 1 conteo por_stand por cada tienda
        # Solo considerar conteos que NO est√©n anulados (en_proceso o finalizado)
        
        logging.info(f"[iniciar_conteo] Validando conteo duplicado: inventario_id={inventario_id}, almacen_id={data['almacen_id']}, tienda_id={tienda_id}, tipo_conteo={data['tipo_conteo']}")
        
        if tienda_id is None:
            cursor.execute("""
                SELECT 
                    c.id,
                    c.estado,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%d/%%m/%%Y %%H:%%i') as fecha_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%d/%%m/%%Y %%H:%%i') as fecha_final
                FROM conteos c
                WHERE c.inventario_id = %s
                    AND c.almacen_id = %s
                    AND c.tienda_id IS NULL
                    AND c.tipo_conteo = %s
                    AND c.estado != 'anulado'
                ORDER BY c.id DESC
                LIMIT 1
            """, (inventario_id, data['almacen_id'], data['tipo_conteo']))
        else:
            cursor.execute("""
                SELECT 
                    c.id,
                    c.estado,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%d/%%m/%%Y %%H:%%i') as fecha_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%d/%%m/%%Y %%H:%%i') as fecha_final
                FROM conteos c
                WHERE c.inventario_id = %s
                    AND c.almacen_id = %s
                    AND c.tienda_id = %s
                    AND c.tipo_conteo = %s
                    AND c.estado != 'anulado'
                ORDER BY c.id DESC
                LIMIT 1
            """, (inventario_id, data['almacen_id'], tienda_id, data['tipo_conteo']))
        
        conteo_existente = cursor.fetchone()
        
        if conteo_existente:
            estado_mensaje = "finalizado" if conteo_existente['estado'] == 'finalizado' else "en proceso"
            tipo_mensaje = "por cajas" if conteo_existente['tipo_conteo'] == 'por_cajas' else "por stand"
            mensaje = f"Este conteo {tipo_mensaje} ya fue {estado_mensaje}. Conteo ID: {conteo_existente['id']}, Inicio: {conteo_existente['fecha_inicio']}"
            if conteo_existente['fecha_final']:
                mensaje += f", Finalizaci√≥n: {conteo_existente['fecha_final']}"
            
            logging.warning(f"[iniciar_conteo] ‚ö†Ô∏è Conteo duplicado encontrado: {conteo_existente}")
            
            return {
                'success': False,
                'message': mensaje,
                'conteo_existente': {
                    'id': conteo_existente['id'],
                    'estado': conteo_existente['estado'],
                    'tipo_conteo': conteo_existente['tipo_conteo'],
                    'fecha_inicio': conteo_existente['fecha_inicio'],
                    'fecha_final': conteo_existente['fecha_final']
                }
            }
        
        logging.info(f"[iniciar_conteo] ‚úì No se encontr√≥ conteo duplicado, procediendo a crear nuevo conteo")
        
        # Log antes de crear el conteo
        logging.info(f"[iniciar_conteo] Creando conteo con numero_inventario='{data['numero_inventario']}', inventario_id={inventario_id}, almacen_id={data['almacen_id']}, tienda_id={tienda_id}, tipo={data['tipo_conteo']}")
        
        cursor.callproc('sp_iniciar_conteo', [
            data['numero_inventario'],
            data['almacen_id'],
            tienda_id,
            data['registrado_por'],
            data['tipo_conteo'],
            data.get('origen_datos', 'sistema'),
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_iniciar_conteo_6, @_sp_iniciar_conteo_7')
        result = cursor.fetchone()
        
        conteo_id = result['@_sp_iniciar_conteo_6']
        
        # Verificar qu√© inventario_id tiene el conteo creado
        if conteo_id > 0:
            cursor.execute("""
                SELECT c.id, c.inventario_id, i.numero_inventario, c.estado, c.almacen_id, a.nombre as almacen
                FROM conteos c
                LEFT JOIN inventarios i ON c.inventario_id = i.id
                LEFT JOIN almacenes a ON c.almacen_id = a.id
                WHERE c.id = %s
            """, (conteo_id,))
            conteo_info = cursor.fetchone()
            if conteo_info:
                logging.info(f"[iniciar_conteo] Conteo creado: ID={conteo_id}, inventario_id={conteo_info['inventario_id']}, numero_inventario={conteo_info['numero_inventario']}, estado={conteo_info['estado']}, almacen={conteo_info['almacen']}")
            else:
                logging.warning(f"[iniciar_conteo] ‚ö†Ô∏è Conteo {conteo_id} creado pero no se pudo obtener informaci√≥n")
        
        # Si el origen es 'sistema', cargar productos del sistema
        if data.get('origen_datos', 'sistema') == 'sistema' and conteo_id > 0:
            cursor.callproc('sp_cargar_productos_conteo', [
                conteo_id,
                0,  # OUT p_resultado
                ''  # OUT p_mensaje
            ])
            
            cursor.execute('SELECT @_sp_cargar_productos_conteo_1, @_sp_cargar_productos_conteo_2')
            carga_result = cursor.fetchone()
            
        conn.commit()
        
        if conteo_id > 0:
            response = {
                'success': True,
                'conteo_id': conteo_id,
                'message': result['@_sp_iniciar_conteo_7']
            }
            if data.get('origen_datos', 'sistema') == 'sistema':
                response['productos_cargados'] = carga_result['@_sp_cargar_productos_conteo_1']
            return response
        else:
            return {
                'success': False,
                'message': result['@_sp_iniciar_conteo_7']
            }
            
    except Exception as e:
        logging.error(f"Error en iniciar_conteo: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al iniciar conteo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# =================================================================================
# FUNCION ACTUALIZAR UBICACION COLABORADOR (PARA VER EN DONDE ESTA HACIENDO CONTEO)
# =================================================================================
def actualizar_ubicacion_colaborador(nombre_colaborador, inventario_id, conteo_id=None):
    """
    Registra en qu√© conteo (tienda/stand) est√° trabajando el usuario actualmente.
    Si conteo_id es None, significa que sali√≥ de la tienda al men√∫ principal.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        query = """
            UPDATE colaboradores_inventario 
            SET conteo_actual_id = %s 
            WHERE nombre_colaborador = %s AND inventario_id = %s
        """
        cursor.execute(query, (conteo_id, nombre_colaborador, inventario_id))
        conn.commit()
        return {'success': True}
    except Exception as e:
        logging.error(f"Error al ubicar colaborador: {e}")
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


# =================================================================================
# FUNCION PARA MONITOREAR USUARIOS DURANTE EL CONTEO
# =================================================================================
def obtener_presencia_colaboradores(inventario_id):
    """
    Muestra qu√© personas est√°n activas y en qu√© tienda/conteo est√°n metidas.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        query = """
            SELECT 
                ci.nombre_colaborador,
                ci.rol,
                COALESCE(t.nombre_tienda, 'Men√∫ Principal / Callao') as ubicacion,
                c.tipo_conteo
            FROM colaboradores_inventario ci
            LEFT JOIN conteos c ON ci.conteo_actual_id = c.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE ci.inventario_id = %s
        """
        cursor.execute(query, (inventario_id,))
        return {'success': True, 'usuarios_activos': cursor.fetchall()}
    except Exception as e:
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION (SUBIDA DE EXCEL EMERGENCIA)
# ============================================================
def cargar_excel_emergencia(request):
    """
    Procesa archivo Excel de emergencia para un conteo
    """
    try:
        # Obtener datos del formulario
        conteo_id = request.form.get('conteo_id')
        usuario = request.form.get('usuario')
        
        if 'excel_file' not in request.files:
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        # Primero intentar leer la hoja 'Products'
        try:
            file.seek(0)  # Asegurar que el archivo est√© al inicio
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                # Usar la primera hoja disponible
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Normalizar nombres de columnas (convertir a may√∫sculas y eliminar espacios extra)
        excel_data.columns = excel_data.columns.str.strip().str.upper()
        
        # Mapear columnas posibles (aceptar diferentes nombres)
        column_mapping = {
            'CODIGO': ['CODIGO', 'C√ìDIGO', 'COD'],
            'CANTIDAD': ['CANTIDAD', 'CANT', 'QTY'],
            'UNIDAD_MEDIDA': ['UNIDAD DE MEDIDA', 'UNIDAD_MEDIDA', 'UNIDAD', 'UNIDAD DE MED', 'C√ìDIGO UNIDAD']
        }
        
        # Buscar las columnas correctas
        codigo_col = None
        cantidad_col = None
        unidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in column_mapping['CODIGO']:
                codigo_col = col
            elif col_upper in column_mapping['CANTIDAD']:
                cantidad_col = col
            elif col_upper in column_mapping['UNIDAD_MEDIDA']:
                unidad_col = col
        
        # Verificar que se encontraron las columnas necesarias
        if not codigo_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna CODIGO. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        if not cantidad_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna CANTIDAD. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        if not unidad_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna UNIDAD DE MEDIDA. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Crear la tabla temporal si no existe (las tablas temporales solo existen en la sesi√≥n actual)
        # Usar CREATE TEMPORARY TABLE IF NOT EXISTS para evitar errores si ya existe
        try:
            cursor.execute("""
                CREATE TEMPORARY TABLE IF NOT EXISTS tmp_excel_conteo (
                    codigo VARCHAR(100),
                    cantidad INT,
                    unidad_excel VARCHAR(50)
                )
            """)
        except Exception as e:
            logging.warning(f"Error al crear tabla temporal tmp_excel_conteo: {str(e)}")
            # Si falla, intentar sin IF NOT EXISTS (puede que ya exista en esta sesi√≥n)
            try:
                cursor.execute("""
                    CREATE TEMPORARY TABLE tmp_excel_conteo (
                        codigo VARCHAR(100),
                        cantidad INT,
                        unidad_excel VARCHAR(50)
                    )
                """)
            except Exception:
                # Si ya existe, simplemente limpiarla
                pass
        
        # Limpiar tabla temporal (las tablas temporales se limpian autom√°ticamente al cerrar conexi√≥n)
        # Pero es mejor limpiarla manualmente para evitar datos residuales
        try:
            cursor.execute("DELETE FROM tmp_excel_conteo")
        except Exception as e:
            logging.warning(f"Error al limpiar tabla tmp_excel_conteo: {str(e)}")
            # Si falla, la tabla puede estar vac√≠a o no existir, continuar de todas formas
        
        # Insertar datos en tabla temporal
        registros_insertados = 0
        for _, row in excel_data.iterrows():
            try:
                codigo = str(row[codigo_col]).strip() if pd.notna(row[codigo_col]) else None
                
                # Convertir cantidad a int (manejar diferentes tipos)
                cantidad_raw = row[cantidad_col] if pd.notna(row[cantidad_col]) else 0
                try:
                    if isinstance(cantidad_raw, str):
                        cantidad = int(float(cantidad_raw.strip()))
                    else:
                        cantidad = int(float(cantidad_raw))
                except (ValueError, TypeError):
                    logging.warning(f"[cargar_excel_emergencia] Error al convertir cantidad para c√≥digo {codigo}: {cantidad_raw}, usando 0")
                    cantidad = 0
                
                unidad = str(row[unidad_col]).strip() if pd.notna(row[unidad_col]) else ''
                
                if codigo:  # Solo insertar si hay c√≥digo
                    cursor.execute(
                        "INSERT INTO tmp_excel_conteo (codigo, cantidad, unidad_excel) VALUES (%s, %s, %s)",
                        (codigo, cantidad, unidad)
                    )
                    registros_insertados += 1
                    logging.debug(f"[cargar_excel_emergencia] Insertado en tmp: codigo={codigo}, cantidad={cantidad}, unidad={unidad}")
            except Exception as e:
                logging.warning(f"[cargar_excel_emergencia] Error al procesar fila del Excel: {str(e)}")
                continue
        
        logging.info(f"[cargar_excel_emergencia] Total registros insertados en tmp_excel_conteo: {registros_insertados}")
        
        # Verificar datos en tabla temporal antes de procesar
        cursor.execute("SELECT COUNT(*) as total, SUM(cantidad) as suma_cantidades FROM tmp_excel_conteo")
        tmp_info = cursor.fetchone()
        logging.info(f"[cargar_excel_emergencia] Datos en tmp_excel_conteo: {tmp_info['total']} registros, suma_cantidades={tmp_info['suma_cantidades']}")
        
        # Llamar al stored procedure para procesar el Excel
        try:
            cursor.callproc('sp_cargar_conteo_desde_excel', [
                int(conteo_id),
                usuario,
                0,  # OUT p_registros_procesados
                0   # OUT p_registros_actualizados
            ])
            
            cursor.execute('SELECT @_sp_cargar_conteo_desde_excel_2, @_sp_cargar_conteo_desde_excel_3')
            result = cursor.fetchone()
            registros_procesados = result['@_sp_cargar_conteo_desde_excel_2'] if result else 0
            registros_actualizados = result['@_sp_cargar_conteo_desde_excel_3'] if result else 0
        except Exception as e:
            logging.error(f"[cargar_excel_emergencia] Error en stored procedure: {str(e)}")
            # Si el stored procedure falla, hacer UPDATE directo
            logging.info(f"[cargar_excel_emergencia] Intentando UPDATE directo desde tmp_excel_conteo")
            
            # Actualizar directamente desde la tabla temporal
            cursor.execute("""
                UPDATE detalle_conteo dc
                INNER JOIN productos_inventario pi ON dc.item_producto = pi.item
                INNER JOIN tmp_excel_conteo tmp ON UPPER(TRIM(pi.codigo)) = UPPER(TRIM(tmp.codigo))
                SET dc.cantidad = tmp.cantidad,
                    dc.unidad_medida = COALESCE(tmp.unidad_excel, dc.unidad_medida),
                    dc.usuario_modificacion = %s,
                    dc.fecha_hora_modificacion = CURRENT_TIMESTAMP
                WHERE dc.conteo_id = %s
            """, (usuario, int(conteo_id)))
            
            registros_actualizados = cursor.rowcount
            registros_procesados = registros_insertados
            result = {'@_sp_cargar_conteo_desde_excel_2': registros_procesados, '@_sp_cargar_conteo_desde_excel_3': registros_actualizados}
            logging.info(f"[cargar_excel_emergencia] UPDATE directo completado: {registros_actualizados} registros actualizados")
        
        # Verificar que las cantidades se guardaron correctamente despu√©s del procesamiento
        cursor.execute("""
            SELECT 
                COUNT(*) as total_detalles,
                SUM(cantidad) as suma_cantidades,
                COUNT(CASE WHEN cantidad > 0 THEN 1 END) as detalles_con_cantidad
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        detalle_info = cursor.fetchone()
        logging.info(f"[cargar_excel_emergencia] Despu√©s de procesamiento: total_detalles={detalle_info['total_detalles']}, suma_cantidades={detalle_info['suma_cantidades']}, con_cantidad={detalle_info['detalles_con_cantidad']}")
        
        # Si no hay cantidades guardadas, intentar UPDATE directo como respaldo
        if detalle_info['suma_cantidades'] == 0 and registros_insertados > 0:
            logging.warning(f"[cargar_excel_emergencia] ‚ö†Ô∏è No se guardaron cantidades, intentando UPDATE directo de respaldo")
            cursor.execute("""
                UPDATE detalle_conteo dc
                INNER JOIN productos_inventario pi ON dc.item_producto = pi.item
                INNER JOIN tmp_excel_conteo tmp ON UPPER(TRIM(pi.codigo)) = UPPER(TRIM(tmp.codigo))
                SET dc.cantidad = tmp.cantidad,
                    dc.unidad_medida = COALESCE(tmp.unidad_excel, dc.unidad_medida),
                    dc.usuario_modificacion = %s,
                    dc.fecha_hora_modificacion = CURRENT_TIMESTAMP
                WHERE dc.conteo_id = %s
            """, (usuario, int(conteo_id)))
            
            registros_actualizados = cursor.rowcount
            logging.info(f"[cargar_excel_emergencia] UPDATE de respaldo: {registros_actualizados} registros actualizados")
        
        # Actualizar conteo para indicar que viene de Excel
        cursor.execute(
            "UPDATE conteos SET origen_datos = 'excel' WHERE id = %s",
            (conteo_id,)
        )
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_leidos': registros_insertados,
            'registros_procesados': result['@_sp_cargar_conteo_desde_excel_2'],
            'registros_actualizados': result['@_sp_cargar_conteo_desde_excel_3'],
            'detalles_con_cantidad': detalle_info['detalles_con_cantidad'],
            'suma_cantidades': int(detalle_info['suma_cantidades']) if detalle_info['suma_cantidades'] else 0,
            'message': f'Excel procesado desde hoja "{sheet_used}": {registros_insertados} filas le√≠das, {result["@_sp_cargar_conteo_desde_excel_2"]} registros procesados, {result["@_sp_cargar_conteo_desde_excel_3"]} actualizados'
        }
            
    except Exception as e:
        logging.error(f"Error en cargar_excel_emergencia: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': 'Error al procesar el archivo Excel',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTNER DETALLE CONTEO
# ============================================================
def obtener_detalle_conteo(conteo_id):
    """
    Obtiene el detalle de productos de un conteo
    Incluye TODOS los productos del cat√°logo, incluso los que tienen cantidad 0
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener informaci√≥n del conteo primero
        cursor.execute("""
            SELECT 
                c.*,
                a.nombre as almacen_nombre,
                t.nombre_tienda as tienda_nombre,
                i.numero_inventario,
                i.area,
                i.autorizado_por
            FROM conteos c
            INNER JOIN inventarios i ON c.inventario_id = i.id
            INNER JOIN almacenes a ON c.almacen_id = a.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE c.id = %s
        """, (conteo_id,))
        
        conteo_info = cursor.fetchone()
        
        if not conteo_info:
            return {
                'success': False,
                'message': 'Conteo no encontrado'
            }
        
        # Obtener TODOS los productos del cat√°logo, incluso los que no tienen registro en detalle_conteo
        # Esto asegura que se muestren todos los productos, incluso con cantidad 0
        cursor.execute("""
            SELECT 
                pi.item as item_producto,
                pi.producto,
                pi.codigo,
                COALESCE(dc.cantidad, 0) as cantidad,
                COALESCE(dc.unidad_medida, pi.unidad_medida) as unidad_medida,
                dc.id as detalle_id,
                dc.conteo_id,
                dc.fecha_hora_registro,
                dc.fecha_hora_modificacion,
                dc.usuario_modificacion,
                %s as tipo_conteo,
                %s as almacen_id,
                %s as almacen_nombre,
                %s as tienda_id,
                %s as tienda_nombre
            FROM productos_inventario pi
            LEFT JOIN detalle_conteo dc ON pi.item = dc.item_producto AND dc.conteo_id = %s
            WHERE pi.estado = 'activo'
            ORDER BY pi.item
        """, (
            conteo_info['tipo_conteo'],
            conteo_info['almacen_id'],
            conteo_info['almacen_nombre'],
            conteo_info['tienda_id'],
            conteo_info['tienda_nombre'],
            conteo_id
        ))
        
        productos = cursor.fetchall()
        
        return {
            'success': True,
            'conteo': conteo_info,
            'productos': productos,
            'total_productos': len(productos),
            'productos_con_cantidad': len([p for p in productos if p['cantidad'] > 0]),
            'productos_sin_cantidad': len([p for p in productos if p['cantidad'] == 0])
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS INICIADOS (EN PROCESO)
# ============================================================
def listar_conteos_iniciados(inventario_id=None):
    """
    Lista todos los conteos que est√°n iniciados (en proceso) para poder finalizarlos
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Si no se proporciona inventario_id, obtener el inventario activo
        if not inventario_id:
            cursor.callproc('sp_obtener_inventario_activo', [
                0,  # OUT p_inventario_id
                ''  # OUT p_numero_inventario
            ])
            cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
            result_activo = cursor.fetchone()
            inventario_id = result_activo['@_sp_obtener_inventario_activo_0']
            
            if not inventario_id:
                return {
                    'success': False,
                    'message': 'No hay inventario activo. Especifique inventario_id.'
                }
        else:
            # Convertir a int si viene como string
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                return {
                    'success': False,
                    'message': f'inventario_id inv√°lido: {inventario_id}'
                }
        
        # Log para debugging
        logging.info(f"[listar_conteos_iniciados] Buscando conteos para inventario_id={inventario_id}")
        
        # Obtener conteos en proceso para este inventario
        cursor.execute("""
            SELECT 
                c.id as conteo_id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                c.almacen_id,
                a.nombre as almacen_nombre,
                c.tienda_id,
                t.nombre_tienda as tienda_nombre,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.estado,
                c.origen_datos,
                c.archivo_pdf,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total,
                i.numero_inventario as inventario_numero,
                i.area as inventario_area
            FROM conteos c
            INNER JOIN inventarios i ON c.inventario_id = i.id
            INNER JOIN almacenes a ON c.almacen_id = a.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.estado = 'en_proceso'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.almacen_id, a.nombre, c.tienda_id, t.nombre_tienda,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.estado,
                     c.origen_datos, c.archivo_pdf, i.numero_inventario, i.area
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id,))
        
        conteos = cursor.fetchall()
        
        # Verificar si hay conteos con otros inventario_id o estados
        cursor.execute("""
            SELECT COUNT(*) as total, 
                   GROUP_CONCAT(DISTINCT c.inventario_id) as inventarios_ids,
                   GROUP_CONCAT(DISTINCT c.estado) as estados
            FROM conteos c
            WHERE c.numero_inventario = (SELECT numero_inventario FROM inventarios WHERE id = %s)
               OR c.inventario_id = %s
        """, (inventario_id, inventario_id))
        debug_info = cursor.fetchone()
        logging.info(f"[listar_conteos_iniciados] Conteos encontrados: {len(conteos)}. Debug: total={debug_info['total']}, inventarios={debug_info['inventarios_ids']}, estados={debug_info['estados']}")
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT 
                id,
                numero_inventario,
                area,
                estado,
                autorizado_por
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        
        inventario_info = cursor.fetchone()
        
        return {
            'success': True,
            'inventario': inventario_info,
            'conteos_en_proceso': conteos,
            'total_conteos': len(conteos),
            'message': f'Se encontraron {len(conteos)} conteo(s) en proceso'
        }
            
    except Exception as e:
        logging.error(f"Error en listar_conteos_iniciados: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar conteos iniciados',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LA ACTUALIZACION DE INVENTARIO (INDIVIDUAL)
# ============================================================
def actualizar_cantidad_producto_individual(data):
    """
    Actualiza la cantidad de un producto individualmente
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Validar y convertir cantidad a int
        detalle_id = data.get('detalle_id')
        nueva_cantidad_raw = data.get('nueva_cantidad')
        usuario = data.get('usuario')
        
        # Convertir cantidad a int (manejar string, float, None)
        try:
            if nueva_cantidad_raw is None:
                nueva_cantidad = 0
            elif isinstance(nueva_cantidad_raw, str):
                nueva_cantidad = int(float(nueva_cantidad_raw.strip()))
            else:
                nueva_cantidad = int(float(nueva_cantidad_raw))
        except (ValueError, TypeError) as e:
            logging.error(f"[actualizar_cantidad_producto_individual] Error al convertir cantidad: {nueva_cantidad_raw}, error: {str(e)}")
            return {
                'success': False,
                'message': f'Cantidad inv√°lida: {nueva_cantidad_raw}'
            }
        
        # Log para debugging
        logging.info(f"[actualizar_cantidad_producto_individual] Actualizando detalle_id={detalle_id}, cantidad={nueva_cantidad}, usuario={usuario}")
        
        # Verificar que el detalle existe antes de actualizar
        cursor.execute("SELECT id, cantidad, conteo_id FROM detalle_conteo WHERE id = %s", (detalle_id,))
        detalle_actual = cursor.fetchone()
        
        if not detalle_actual:
            return {
                'success': False,
                'message': f'No se encontr√≥ el detalle con ID: {detalle_id}'
            }
        
        logging.info(f"[actualizar_cantidad_producto_individual] Detalle actual: cantidad={detalle_actual['cantidad']}, conteo_id={detalle_actual['conteo_id']}")
        
        # Actualizar directamente en lugar de usar stored procedure (m√°s confiable)
        logging.info(f"[actualizar_cantidad_producto_individual] Ejecutando UPDATE: cantidad={nueva_cantidad}, usuario={usuario}, detalle_id={detalle_id}")
        
        cursor.execute("""
            UPDATE detalle_conteo 
            SET cantidad = %s,
                usuario_modificacion = %s,
                fecha_hora_modificacion = CURRENT_TIMESTAMP
            WHERE id = %s
        """, (nueva_cantidad, usuario, detalle_id))
        
        rows_affected = cursor.rowcount
        logging.info(f"[actualizar_cantidad_producto_individual] UPDATE ejecutado. Filas afectadas: {rows_affected}")
        
        # Verificar que se actualiz√≥ ANTES del commit
        cursor.execute("SELECT cantidad, usuario_modificacion FROM detalle_conteo WHERE id = %s", (detalle_id,))
        detalle_verificado = cursor.fetchone()
        
        logging.info(f"[actualizar_cantidad_producto_individual] ANTES del commit - Cantidad verificada: {detalle_verificado['cantidad'] if detalle_verificado else 'N/A'}, usuario: {detalle_verificado['usuario_modificacion'] if detalle_verificado else 'N/A'}")
        
        # CR√çTICO: Hacer commit expl√≠cito y verificar que se ejecut√≥
        try:
            conn.commit()
            logging.info(f"[actualizar_cantidad_producto_individual] ‚úì COMMIT realizado exitosamente")
        except Exception as commit_error:
            logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå ERROR en COMMIT: {str(commit_error)}")
            conn.rollback()
            raise commit_error
        
        # Verificar DESPU√âS del commit - Obtener TODOS los campos para verificar que todo se guard√≥ correctamente
        # Usar una nueva conexi√≥n para asegurar que leemos los datos persistidos
        cursor.execute("""
            SELECT 
                id, conteo_id, item_producto, producto, codigo, 
                cantidad, unidad_medida, 
                fecha_hora_registro, fecha_hora_modificacion, usuario_modificacion
            FROM detalle_conteo 
            WHERE id = %s
        """, (detalle_id,))
        detalle_despues = cursor.fetchone()
        
        if detalle_despues:
            logging.info(f"[actualizar_cantidad_producto_individual] ‚úì DESPU√âS del commit - Registro completo:")
            logging.info(f"  - id: {detalle_despues['id']}")
            logging.info(f"  - conteo_id: {detalle_despues['conteo_id']}")
            logging.info(f"  - item_producto: {detalle_despues['item_producto']}")
            logging.info(f"  - producto: {detalle_despues['producto']}")
            logging.info(f"  - codigo: {detalle_despues['codigo']}")
            logging.info(f"  - cantidad: {detalle_despues['cantidad']} ‚≠ê (esperado: {nueva_cantidad})")
            logging.info(f"  - unidad_medida: {detalle_despues['unidad_medida']}")
            logging.info(f"  - fecha_hora_registro: {detalle_despues['fecha_hora_registro']}")
            logging.info(f"  - fecha_hora_modificacion: {detalle_despues['fecha_hora_modificacion']}")
            logging.info(f"  - usuario_modificacion: {detalle_despues['usuario_modificacion']}")
            
            # Verificaci√≥n cr√≠tica: ¬øLa cantidad se guard√≥ correctamente?
            if detalle_despues['cantidad'] != nueva_cantidad:
                logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå‚ùå‚ùå ERROR CR√çTICO: La cantidad NO se guard√≥ correctamente!")
                logging.error(f"  Esperado: {nueva_cantidad}, Obtenido: {detalle_despues['cantidad']}")
            else:
                logging.info(f"[actualizar_cantidad_producto_individual] ‚úÖ‚úÖ‚úÖ VERIFICACI√ìN EXITOSA: La cantidad se guard√≥ correctamente!")
        else:
            logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå ERROR: No se encontr√≥ el registro despu√©s del commit")
        
        if rows_affected > 0:
            return {
                'success': True,
                'message': f'Cantidad actualizada correctamente a {nueva_cantidad}',
                'cantidad_anterior': detalle_actual['cantidad'],
                'cantidad_nueva': nueva_cantidad
            }
        else:
            return {
                'success': False,
                'message': 'No se pudo actualizar la cantidad. Verifique que el detalle_id sea correcto.'
            }
            
    except Exception as e:
        logging.error(f"[actualizar_cantidad_producto_individual] Error: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LA ACTUALIZACION DE INVENTARIO (MASIVO)
# ============================================================
def actualizar_masivo_productos(data):
    """
    Actualizaci√≥n masiva de cantidad y/o unidad de medida de productos
    OPTIMIZADO: Reduce consultas a la base de datos usando batch updates
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        conteo_id = data['conteo_id']
        productos = data['productos']  # Lista de productos a actualizar
        usuario = data['usuario']
        
        if not productos or len(productos) == 0:
            return {
                'success': True,
                'message': 'No hay productos para actualizar',
                'registros_actualizados': 0
            }
        
        # OPTIMIZACI√ìN: Obtener todos los datos actuales en una sola consulta
        detalle_ids = [p['detalle_id'] for p in productos if p.get('detalle_id')]
        if not detalle_ids:
            return {
                'success': False,
                'message': 'No se proporcionaron IDs de detalle v√°lidos'
            }
        
        # Obtener todos los productos actuales en batch
        placeholders = ','.join(['%s'] * len(detalle_ids))
        cursor.execute(f"""
            SELECT id, cantidad, unidad_medida 
            FROM detalle_conteo 
            WHERE id IN ({placeholders}) AND conteo_id = %s
        """, detalle_ids + [conteo_id])
        
        productos_actuales = {row['id']: row for row in cursor.fetchall()}
        
        registros_actualizados = 0
        auditorias = []  # Acumular auditor√≠as para insertar en batch
        
        # Procesar actualizaciones
        for producto in productos:
            detalle_id = producto['detalle_id']
            
            if detalle_id not in productos_actuales:
                continue
            
            producto_actual = productos_actuales[detalle_id]
            
            # Determinar qu√© campos actualizar
            nueva_cantidad_raw = producto.get('nueva_cantidad', producto_actual['cantidad'])
            nueva_unidad = producto.get('nueva_unidad_medida', producto_actual['unidad_medida'])
            
            # Convertir cantidad a int (manejar string, float, None)
            try:
                if nueva_cantidad_raw is None:
                    nueva_cantidad = producto_actual['cantidad']
                elif isinstance(nueva_cantidad_raw, str):
                    nueva_cantidad = int(float(nueva_cantidad_raw.strip()))
                else:
                    nueva_cantidad = int(float(nueva_cantidad_raw))
            except (ValueError, TypeError) as e:
                logging.error(f"[actualizar_masivo_productos] Error al convertir cantidad para detalle_id={detalle_id}: {nueva_cantidad_raw}, error: {str(e)}")
                nueva_cantidad = producto_actual['cantidad']  # Mantener valor actual si hay error
            
            # Actualizar producto
            cursor.execute("""
                UPDATE detalle_conteo 
                SET cantidad = %s, 
                    unidad_medida = %s,
                    usuario_modificacion = %s,
                    fecha_hora_modificacion = CURRENT_TIMESTAMP
                WHERE id = %s AND conteo_id = %s
            """, (nueva_cantidad, nueva_unidad, usuario, detalle_id, conteo_id))
            
            if cursor.rowcount > 0:
                registros_actualizados += 1
                
                # Acumular auditor√≠as para insertar en batch
                if str(nueva_cantidad) != str(producto_actual['cantidad']):
                    auditorias.append((
                        detalle_id, conteo_id, 'cantidad',
                        str(producto_actual['cantidad']), str(nueva_cantidad),
                        'masiva', usuario
                    ))
                
                if nueva_unidad != producto_actual['unidad_medida']:
                    auditorias.append((
                        detalle_id, conteo_id, 'unidad_medida',
                        producto_actual['unidad_medida'], nueva_unidad,
                        'masiva', usuario
                    ))
        
        # OPTIMIZACI√ìN: Insertar todas las auditor√≠as en batch
        if auditorias:
            cursor.executemany("""
                INSERT INTO auditoria_cambios (
                    detalle_conteo_id, conteo_id, campo_modificado,
                    valor_anterior, valor_nuevo, tipo_modificacion, usuario
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, auditorias)
        
        # CR√çTICO: Hacer commit expl√≠cito
        try:
            conn.commit()
            logging.info(f"[actualizar_masivo_productos] ‚úì COMMIT realizado exitosamente para {registros_actualizados} registros, {len(auditorias)} auditor√≠as")
        except Exception as commit_error:
            logging.error(f"[actualizar_masivo_productos] ‚ùå ERROR en COMMIT: {str(commit_error)}")
            conn.rollback()
            raise
            raise commit_error
        
        # Verificaci√≥n adicional: Contar cu√°ntos registros tienen cantidad > 0 despu√©s del commit
        cursor.execute("""
            SELECT COUNT(*) as total_con_cantidad
            FROM detalle_conteo
            WHERE conteo_id = %s AND cantidad > 0
        """, (conteo_id,))
        verificacion = cursor.fetchone()
        logging.info(f"[actualizar_masivo_productos] Verificaci√≥n post-commit: {verificacion['total_con_cantidad']} productos con cantidad > 0 en conteo_id {conteo_id}")
        
        return {
            'success': True,
            'registros_actualizados': registros_actualizados,
            'productos_con_cantidad': verificacion['total_con_cantidad'],
            'message': f'Actualizaci√≥n masiva completada: {registros_actualizados} productos actualizados'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        logging.error(f"[actualizar_masivo_productos] Error: {str(e)}")
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION DE DIAGN√ìSTICO PARA VERIFICAR ESTADO DE CANTIDADES
# ============================================================
def diagnosticar_cantidades_conteo(conteo_id):
    """
    Funci√≥n de diagn√≥stico para verificar el estado de las cantidades en un conteo
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener informaci√≥n del conteo
        cursor.execute("""
            SELECT c.id, c.inventario_id, c.estado, c.tipo_conteo, c.almacen_id
            FROM conteos c
            WHERE c.id = %s
        """, (conteo_id,))
        conteo_info = cursor.fetchone()
        
        if not conteo_info:
            return {
                'success': False,
                'message': f'Conteo {conteo_id} no encontrado'
            }
        
        # Estad√≠sticas de detalle_conteo
        # IMPORTANTE: Verificar el tipo de dato de cantidad
        cursor.execute("""
            SELECT 
                COUNT(*) as total_registros,
                COUNT(CASE WHEN cantidad > 0 THEN 1 END) as registros_con_cantidad,
                COUNT(CASE WHEN cantidad = 0 THEN 1 END) as registros_sin_cantidad,
                SUM(CAST(cantidad AS UNSIGNED)) as suma_total_cantidades,
                MAX(CAST(cantidad AS UNSIGNED)) as cantidad_maxima,
                COUNT(CASE WHEN usuario_modificacion IS NOT NULL THEN 1 END) as registros_modificados,
                COUNT(CASE WHEN fecha_hora_modificacion > fecha_hora_registro THEN 1 END) as registros_actualizados,
                GROUP_CONCAT(DISTINCT CAST(cantidad AS CHAR) ORDER BY cantidad DESC LIMIT 5) as valores_cantidad_ejemplos
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        estadisticas = cursor.fetchone()
        
        # Verificar espec√≠ficamente el registro que se actualiz√≥ recientemente (ID 15245)
        cursor.execute("""
            SELECT id, codigo, producto, cantidad, 
                   CAST(cantidad AS UNSIGNED) as cantidad_numerica,
                   usuario_modificacion, 
                   fecha_hora_registro, fecha_hora_modificacion
            FROM detalle_conteo
            WHERE conteo_id = %s AND id = 15245
        """, (conteo_id,))
        registro_especifico = cursor.fetchone()
        
        # Muestra algunos ejemplos de registros (los que tienen cantidad > 0 primero)
        cursor.execute("""
            SELECT id, codigo, producto, cantidad, 
                   CAST(cantidad AS UNSIGNED) as cantidad_numerica,
                   usuario_modificacion, 
                   fecha_hora_registro, fecha_hora_modificacion
            FROM detalle_conteo
            WHERE conteo_id = %s
            ORDER BY CAST(cantidad AS UNSIGNED) DESC, id ASC
            LIMIT 10
        """, (conteo_id,))
        ejemplos = cursor.fetchall()
        
        # Verificar si hay registros duplicados o problemas de integridad
        cursor.execute("""
            SELECT 
                COUNT(*) as total,
                COUNT(DISTINCT id) as ids_unicos,
                COUNT(DISTINCT codigo) as codigos_unicos
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        integridad = cursor.fetchone()
        
        return {
            'success': True,
            'conteo': conteo_info,
            'estadisticas': estadisticas,
            'registro_especifico_15245': registro_especifico,
            'integridad': integridad,
            'ejemplos': ejemplos,
            'diagnostico': {
                'total_registros': estadisticas['total_registros'],
                'con_cantidad': estadisticas['registros_con_cantidad'],
                'sin_cantidad': estadisticas['registros_sin_cantidad'],
                'porcentaje_con_cantidad': round((estadisticas['registros_con_cantidad'] / estadisticas['total_registros'] * 100) if estadisticas['total_registros'] > 0 else 0, 2),
                'suma_total': int(estadisticas['suma_total_cantidades']) if estadisticas['suma_total_cantidades'] else 0,
                'cantidad_maxima': int(estadisticas['cantidad_maxima']) if estadisticas['cantidad_maxima'] else 0,
                'registros_modificados': estadisticas['registros_modificados'],
                'registros_actualizados': estadisticas['registros_actualizados'],
                'valores_cantidad_ejemplos': estadisticas['valores_cantidad_ejemplos'],
                'ids_unicos': integridad['ids_unicos'],
                'codigos_unicos': integridad['codigos_unicos']
            }
        }
    except Exception as e:
        logging.error(f"[diagnosticar_cantidades_conteo] Error: {str(e)}")
        return {
            'success': False,
            'message': f'Error en diagn√≥stico: {str(e)}'
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN
# ============================================================
def listar_conteos_almacen(cursor, almacen_nombre):
    """Lista conteos filtrando por almac√©n (Callao o Malvinas)"""
    query = """
        SELECT c.id, c.fecha_hora_inicio, c.numero_inventario, c.registrado_por, 
               c.archivo_pdf, c.tipo_conteo, c.fecha_hora_final, t.nombre_tienda as tienda
        FROM conteos c
        JOIN almacenes a ON c.almacen_id = a.id
        LEFT JOIN tiendas t ON c.tienda_id = t.id
        WHERE a.nombre = %s
        ORDER BY c.fecha_hora_inicio DESC
    """
    cursor.execute(query, (almacen_nombre,))
    return {'success': True, 'data': cursor.fetchall()}

# ============================================================
# FUNCION FINALIZAR CONTEO
# ============================================================
def finalizar_conteo(data):
    """
    Finaliza un conteo y genera el archivo PDF
    """
    try:
        # Validar campos requeridos
        if 'conteo_id' not in data:
            return {
                'success': False,
                'message': 'Falta el campo obligatorio: conteo_id'
            }
        
        # Convertir conteo_id a int si viene como string
        conteo_id = int(data['conteo_id']) if isinstance(data['conteo_id'], str) else data['conteo_id']
        
        conn = get_connection()
        cursor = conn.cursor()
        
        archivo_pdf = data.get('archivo_pdf', '')
        
        cursor.callproc('sp_finalizar_conteo', [
            conteo_id,
            archivo_pdf,
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        # Los par√°metros OUT se acceden con √≠ndice basado en posici√≥n (empezando desde 0)
        # p_conteo_id=0, p_archivo_pdf=1, p_resultado=2, p_mensaje=3
        cursor.execute('SELECT @_sp_finalizar_conteo_2 as resultado, @_sp_finalizar_conteo_3 as mensaje')
        result = cursor.fetchone()
        
        conn.commit()
        
        # Obtener resultado y mensaje de forma segura
        resultado = result.get('resultado') if result else None
        mensaje = result.get('mensaje') if result else 'Sin mensaje'
        
        # Convertir resultado a int de forma segura
        try:
            resultado_int = int(resultado) if resultado is not None else 0
        except (ValueError, TypeError):
            # Si el resultado no es num√©rico, intentar interpretarlo
            resultado_int = 1 if resultado else 0
        
        if resultado_int > 0:
            return {
                'success': True,
                'message': mensaje
            }
        else:
            return {
                'success': False,
                'message': mensaje
            }
            
    except Exception as e:
        logging.error(f"Error en finalizar_conteo: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al finalizar conteo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION CERRAR INVENTARIO ACTIVO
# ============================================================
def cerrar_inventario(data):
    """
    Cierra un inventario usando el stored procedure sp_cerrar_inventario
    Puede recibir numero_inventario en el body, o cerrar el inventario activo autom√°ticamente
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        numero_inventario = None
        
        # Si viene numero_inventario en el body, usarlo
        if data.get('numero_inventario'):
            numero_inventario = data['numero_inventario']
        else:
            # Si no viene, obtener el inventario activo autom√°ticamente
            cursor.callproc('sp_obtener_inventario_activo', [
                0,  # OUT p_inventario_id
                ''  # OUT p_numero_inventario
            ])
            
            cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
            result_activo = cursor.fetchone()
            
            numero_inventario = result_activo['@_sp_obtener_inventario_activo_1']
            
            if not numero_inventario:
                return {
                    'success': False,
                    'message': 'No hay inventario activo para cerrar. Especifique numero_inventario en el body.'
                }
        
        # Intentar llamar al stored procedure sp_cerrar_inventario
        # Si no existe o falla, cerrar directamente sin usar fecha_cierre
        try:
            cursor.callproc('sp_cerrar_inventario', [
                numero_inventario,
                0,  # OUT p_resultado
                ''  # OUT p_mensaje
            ])
            
            cursor.execute('SELECT @_sp_cerrar_inventario_1, @_sp_cerrar_inventario_2')
            result = cursor.fetchone()
            
            resultado = int(result.get('@_sp_cerrar_inventario_1') or 0)
            mensaje = result.get('@_sp_cerrar_inventario_2', '')
            
        except Exception as sp_error:
            # Si el stored procedure no existe o falla, cerrar directamente
            logging.warning(f"Stored procedure sp_cerrar_inventario fall√≥: {str(sp_error)}")
            
            # Verificar si hay conteos en proceso
            cursor.execute("""
                SELECT COUNT(*) as conteos_abiertos
                FROM conteos
                WHERE numero_inventario = %s AND estado = 'en_proceso'
            """, (numero_inventario,))
            
            conteos_result = cursor.fetchone()
            conteos_abiertos = conteos_result.get('conteos_abiertos', 0) if conteos_result else 0
            
            if conteos_abiertos > 0:
                resultado = 0
                mensaje = f'Hay {conteos_abiertos} conteos en proceso. Final√≠celos antes de cerrar el inventario.'
            else:
                # Cerrar inventario directamente (sin fecha_cierre si no existe)
                try:
                    cursor.execute("""
                        UPDATE inventarios 
                        SET estado = 'cerrado'
                        WHERE numero_inventario = %s AND estado = 'activo'
                    """, (numero_inventario,))
                except Exception as update_error:
                    # Si falla por columna fecha_cierre, intentar sin ella
                    logging.warning(f"Error al actualizar con fecha_cierre: {str(update_error)}")
                    cursor.execute("""
                        UPDATE inventarios 
                        SET estado = 'cerrado'
                        WHERE numero_inventario = %s AND estado = 'activo'
                    """, (numero_inventario,))
                
                if cursor.rowcount > 0:
                    resultado = 1
                    mensaje = f'Inventario {numero_inventario} cerrado correctamente.'
                else:
                    resultado = 0
                    mensaje = 'No se pudo cerrar el inventario. Verifique que existe y est√° activo.'
        
        conn.commit()
        
        if resultado > 0:
            return {
                'success': True,
                'numero_inventario': numero_inventario,
                'message': mensaje
            }
        else:
            return {
                'success': False,
                'numero_inventario': numero_inventario,
                'message': mensaje
            }
            
    except Exception as e:
        logging.error(f"Error en cerrar_inventario: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': 'Error interno al cerrar inventario',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION LISTAR TODOS LOS INVENTARIOS
# ============================================================
def listar_inventarios(filtrar_activos=False):
    """
    Lista todos los inventarios o solo los activos
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if filtrar_activos:
            # Solo inventarios activos - usando solo columnas que sabemos que existen
            cursor.execute("""
                SELECT 
                    i.id,
                    i.numero_inventario,
                    i.area,
                    i.autorizado_por,
                    i.estado,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                WHERE i.estado = 'activo'
                GROUP BY i.id, i.numero_inventario, i.area, i.autorizado_por, i.estado
                ORDER BY i.id DESC
            """)
        else:
            # Todos los inventarios - usando solo columnas que sabemos que existen
            cursor.execute("""
                SELECT 
                    i.id,
                    i.numero_inventario,
                    i.area,
                    i.autorizado_por,
                    i.estado,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                GROUP BY i.id, i.numero_inventario, i.area, i.autorizado_por, i.estado
                ORDER BY i.id DESC
            """)
        
        inventarios = cursor.fetchall()
        
        return {
            'success': True,
            'inventarios': inventarios,
            'total_inventarios': len(inventarios),
            'filtro': 'activos' if filtrar_activos else 'todos'
        }
            
    except Exception as e:
        logging.error(f"Error al listar inventarios: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar inventarios',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION OBTENER INVENTARIO ACTIVO
# ============================================================
def obtener_inventario_activo():
    """
    Obtiene el inventario activo actual
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Intentar usar stored procedure, si falla usar consulta directa
        try:
            cursor.callproc('sp_obtener_inventario_activo', [
                0,  # OUT p_inventario_id
                ''  # OUT p_numero_inventario
            ])
            
            cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
            result = cursor.fetchone()
            
            if result:
                inventario_id = result.get('@_sp_obtener_inventario_activo_0')
                numero_inventario = result.get('@_sp_obtener_inventario_activo_1')
            else:
                inventario_id = None
                numero_inventario = None
        except Exception as sp_error:
            # Si el stored procedure falla, usar consulta directa
            logging.warning(f"Stored procedure sp_obtener_inventario_activo fall√≥, usando consulta directa: {str(sp_error)}")
            cursor.execute("SELECT id, numero_inventario FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario.get('id')
                numero_inventario = inventario.get('numero_inventario')
            else:
                inventario_id = None
                numero_inventario = None
        
        if inventario_id:
            # Obtener detalles completos del inventario
            cursor.execute("""
                SELECT 
                    i.*,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                WHERE i.id = %s
                GROUP BY i.id
            """, (inventario_id,))
            
            inventario_detalle = cursor.fetchone()
            
            # Obtener colaboradores
            cursor.execute("""
                SELECT * FROM colaboradores_inventario 
                WHERE inventario_id = %s 
                ORDER BY fecha_hora_union DESC
            """, (inventario_id,))
            
            colaboradores = cursor.fetchall()
            
            return {
                'success': True,
                'inventario': inventario_detalle,
                'colaboradores': colaboradores
            }
        else:
            return {
                'success': False,
                'message': 'No hay inventario activo'
            }
            
    except Exception as e:
        logging.error(f"Error en obtener_inventario_activo: {str(e)}")
        return {'success': False, 'message': str(e)}
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN CALLAO
# ============================================================
def listar_conteos_callao(inventario_id):
    """
    Lista todos los conteos realizados en almac√©n Callao para un inventario espec√≠fico
    Separados por tipo: por_cajas y por_stand
    """
    try:
        # Validar inventario_id
        if not inventario_id:
            return {
                'success': False,
                'message': 'inventario_id es requerido'
            }
        
        try:
            inventario_id = int(inventario_id)
        except (ValueError, TypeError):
            return {
                'success': False,
                'message': f'inventario_id inv√°lido: {inventario_id}'
            }
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        
        if not almacen_callao:
            return {'success': False, 'message': 'Almac√©n Callao no encontrado'}
        
        almacen_id = almacen_callao['id']
        
        # Conteos por cajas en Callao
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                COUNT(DISTINCT dc.id) as total_productos,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.tipo_conteo = 'por_cajas'
            GROUP BY c.id
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id, almacen_id))
        
        conteos_cajas = cursor.fetchall()
        
        # Conteos por stand en Callao
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                COUNT(DISTINCT dc.id) as total_productos,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.tipo_conteo = 'por_stand'
            GROUP BY c.id
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id, almacen_id))
        
        conteos_stand = cursor.fetchall()
        
        return {
            'success': True,
            'almacen': 'Callao',
            'inventario_id': inventario_id,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'total_conteos_cajas': len(conteos_cajas),
            'total_conteos_stand': len(conteos_stand),
            'total_conteos': len(conteos_cajas) + len(conteos_stand)
        }
            
    except Exception as e:
        logging.error(f"Error en listar_conteos_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar conteos de Callao: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN MALVINAS
# ============================================================
def listar_conteos_malvinas(inventario_id):
    """
    Lista todos los conteos realizados en almac√©n Malvinas para un inventario espec√≠fico
    Separados por tipo (cajas/stand) y por tienda
    """
    try:
        # Validar inventario_id
        if not inventario_id:
            return {
                'success': False,
                'message': 'inventario_id es requerido'
            }
        
        try:
            inventario_id = int(inventario_id)
        except (ValueError, TypeError):
            return {
                'success': False,
                'message': f'inventario_id inv√°lido: {inventario_id}'
            }
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        
        if not almacen_malvinas:
            return {'success': False, 'message': 'Almac√©n Malvinas no encontrado'}
        
        almacen_id = almacen_malvinas['id']
        
        # Obtener todas las tiendas de Malvinas
        cursor.execute("""
            SELECT id, nombre_tienda 
            FROM tiendas 
            WHERE almacen_id = %s 
            ORDER BY nombre_tienda
        """, (almacen_id,))
        
        tiendas = cursor.fetchall()
        
        resultado = {
            'success': True,
            'almacen': 'Malvinas',
            'inventario_id': inventario_id,
            'tiendas': {}
        }
        
        # OPTIMIZACI√ìN: Obtener todos los conteos de una vez en lugar de por tienda
        # Primero obtener todos los conteos con sus estad√≠sticas
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                c.tienda_id,
                t.nombre_tienda,
                (SELECT COUNT(*) FROM detalle_conteo WHERE conteo_id = c.id) as total_productos,
                (SELECT COALESCE(SUM(cantidad), 0) FROM detalle_conteo WHERE conteo_id = c.id) as cantidad_total
            FROM conteos c
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s
            ORDER BY c.tienda_id, c.tipo_conteo, c.fecha_hora_inicio DESC
        """, (inventario_id, almacen_id))
        
        todos_conteos = cursor.fetchall()
        
        # Agrupar por tienda y tipo
        for tienda in tiendas:
            tienda_id = tienda['id']
            nombre_tienda = tienda['nombre_tienda']
            
            # Filtrar conteos por cajas para esta tienda
            conteos_cajas = [
                c for c in todos_conteos 
                if c['tienda_id'] == tienda_id and c['tipo_conteo'] == 'por_cajas'
            ]
            
            # Filtrar conteos por stand para esta tienda
            conteos_stand = [
                c for c in todos_conteos 
                if c['tienda_id'] == tienda_id and c['tipo_conteo'] == 'por_stand'
            ]
            
            # Agregar al resultado
            resultado['tiendas'][nombre_tienda] = {
                'conteos_por_cajas': conteos_cajas,
                'conteos_por_stand': conteos_stand,
                'total_cajas': len(conteos_cajas),
                'total_stand': len(conteos_stand),
                'total': len(conteos_cajas) + len(conteos_stand)
            }

        # ‚úÖ IMPORTANTE: El return debe estar FUERA del bucle for
        return resultado
        
    except Exception as e:
        logging.error(f"Error en listar_conteos_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar conteos de Malvinas: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA OBTENER HISTORIAL DE CONTEOS CALLAO (TODOS LOS USUARIOS)
# ============================================================
def obtener_historial_conteos_callao(page=1, per_page=10):
    """
    Obtiene el historial completo de conteos finalizados en almac√©n Callao
    de TODOS los usuarios, sin filtrar por inventario_id.
    Incluye paginaci√≥n.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        
        if not almacen_callao:
            return {'success': False, 'message': 'Almac√©n Callao no encontrado'}
        
        almacen_id = almacen_callao['id']
        
        # Obtener total de conteos para paginaci√≥n
        cursor.execute("""
            SELECT COUNT(*) as total
            FROM conteos c
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
        """, (almacen_id,))
        
        total_conteos = cursor.fetchone()['total']
        total_pages = (total_conteos + per_page - 1) // per_page  # Ceiling division
        
        # Calcular offset para paginaci√≥n
        offset = (page - 1) * per_page
        
        # Obtener TODOS los conteos finalizados en Callao (TODOS los inventarios)
        # Aplicar paginaci√≥n aqu√≠ para obtener solo los de la p√°gina actual
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                c.inventario_id,
                i.numero_inventario as inventario_numero,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            LEFT JOIN inventarios i ON c.inventario_id = i.id
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.archivo_pdf,
                     c.estado, c.origen_datos, c.inventario_id, i.numero_inventario
            ORDER BY c.fecha_hora_final DESC
            LIMIT %s OFFSET %s
        """, (almacen_id, per_page, offset))
        
        todos_conteos = cursor.fetchall()
        
        # Separar por tipo de conteo despu√©s de obtener los resultados paginados
        conteos_cajas = [c for c in todos_conteos if c['tipo_conteo'] == 'por_cajas']
        conteos_stand = [c for c in todos_conteos if c['tipo_conteo'] == 'por_stand']
        
        return {
            'success': True,
            'almacen': 'Callao',
            'conteos': todos_conteos,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_conteos,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            }
        }
            
    except Exception as e:
        logging.error(f"Error en obtener_historial_conteos_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener historial de conteos de Callao: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA OBTENER HISTORIAL DE CONTEOS MALVINAS (TODOS LOS USUARIOS)
# ============================================================
def obtener_historial_conteos_malvinas(page=1, per_page=10):
    """
    Obtiene el historial completo de conteos finalizados en almac√©n Malvinas
    de TODOS los usuarios, sin filtrar por inventario_id.
    Incluye paginaci√≥n.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        
        if not almacen_malvinas:
            return {'success': False, 'message': 'Almac√©n Malvinas no encontrado'}
        
        almacen_id = almacen_malvinas['id']
        
        # Obtener total de conteos para paginaci√≥n
        cursor.execute("""
            SELECT COUNT(*) as total
            FROM conteos c
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
        """, (almacen_id,))
        
        total_conteos = cursor.fetchone()['total']
        total_pages = (total_conteos + per_page - 1) // per_page  # Ceiling division
        
        # Calcular offset para paginaci√≥n
        offset = (page - 1) * per_page
        
        # Obtener todos los conteos finalizados en Malvinas (TODOS los inventarios)
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                c.inventario_id,
                i.numero_inventario as inventario_numero,
                c.tienda_id,
                t.nombre_tienda,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            LEFT JOIN inventarios i ON c.inventario_id = i.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.archivo_pdf,
                     c.estado, c.origen_datos, c.inventario_id, i.numero_inventario,
                     c.tienda_id, t.nombre_tienda
            ORDER BY c.fecha_hora_final DESC
            LIMIT %s OFFSET %s
        """, (almacen_id, per_page, offset))
        
        conteos = cursor.fetchall()
        
        # Separar por tipo de conteo
        conteos_cajas = [c for c in conteos if c['tipo_conteo'] == 'por_cajas']
        conteos_stand = [c for c in conteos if c['tipo_conteo'] == 'por_stand']
        
        return {
            'success': True,
            'almacen': 'Malvinas',
            'conteos': conteos,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_conteos,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            }
        }
            
    except Exception as e:
        logging.error(f"Error en obtener_historial_conteos_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener historial de conteos de Malvinas: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA LISTAR PRODUCTOS DEL CATALOGO
# ============================================================
def listar_productos_inventario():
    """
    Lista los productos del cat√°logo maestro `productos_inventario`
    devolviendo solo los campos: item, producto, codigo y unidad_medida.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("""
            SELECT 
                item,
                producto,
                codigo,
                unidad_medida
            FROM productos_inventario
            WHERE estado = 'activo'
            ORDER BY producto
        """)

        productos = cursor.fetchall()

        return {
            'success': True,
            'productos': productos,
            'total_productos': len(productos)
        }
    except Exception as e:
        logging.error(f"Error al listar productos_inventario: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar productos del cat√°logo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE COMPARACION DE CONTEOS (CALLAO - MALVINAS)
# =======================================================================
# ***********************************************************************

# ============================================================
# FUNCION PARA CARGAR DATOS DEL SISTEMA DESDE EXCEL (CALLAO)
# ============================================================
def cargar_sistema_callao(request):
    """
    Carga archivo Excel para datos del sistema en almac√©n Callao
    """
    try:
        # Debug: Verificar qu√© contiene request.files
        logging.info(f"cargar_sistema_callao - request.files keys: {list(request.files.keys())}")
        logging.info(f"cargar_sistema_callao - request.content_type: {request.content_type}")
        logging.info(f"cargar_sistema_callao - request.method: {request.method}")
        
        # Obtener datos del formulario
        inventario_id = request.form.get('inventario_id')
        usuario = request.form.get('usuario')
        
        # Verificar si hay archivos en la petici√≥n
        if not request.files:
            logging.error("cargar_sistema_callao - request.files est√° vac√≠o")
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel - request.files est√° vac√≠o'}
        
        if 'excel_file' not in request.files:
            logging.error(f"cargar_sistema_callao - 'excel_file' no est√° en request.files. Keys disponibles: {list(request.files.keys())}")
            return {'success': False, 'message': f'No se encontr√≥ el archivo Excel. Claves disponibles: {", ".join(request.files.keys())}'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            logging.error("cargar_sistema_callao - file.filename est√° vac√≠o")
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        try:
            file.seek(0)
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Leer columnas espec√≠ficas por posici√≥n seg√∫n especificaci√≥n:
        # Columna A (√≠ndice 0): Nombre
        # Columna B (√≠ndice 1): C√≥digo
        # Columna E (√≠ndice 4): C√≥digo Unidad
        # Columna N (√≠ndice 13): Cantidad
        
        # Primero intentar por nombre de columna (m√°s flexible)
        column_mapping = {}
        excel_data.columns = excel_data.columns.str.strip()
        
        # Buscar columnas por nombre primero
        nombre_col = None
        codigo_col = None
        unidad_col = None
        cantidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in ['NOMBRE', 'PRODUCTO', 'NOMBRE PRODUCTO']:
                nombre_col = col
            elif col_upper in ['C√ìDIGO', 'CODIGO', 'C√ìD', 'COD']:
                codigo_col = col
            elif col_upper in ['C√ìDIGO UNIDAD', 'CODIGO UNIDAD', 'UNIDAD', 'C√ìDIGO UNIDADES']:
                unidad_col = col
            elif col_upper in ['CANTIDAD', 'CANT', 'QTY']:
                cantidad_col = col
        
        # Si no se encontraron por nombre, usar posici√≥n (A=0, B=1, E=4, N=13)
        if not nombre_col and len(excel_data.columns) > 0:
            nombre_col = excel_data.columns[0]  # Columna A
        if not codigo_col and len(excel_data.columns) > 1:
            codigo_col = excel_data.columns[1]  # Columna B
        if not unidad_col and len(excel_data.columns) > 4:
            unidad_col = excel_data.columns[4]  # Columna E
        if not cantidad_col and len(excel_data.columns) > 13:
            cantidad_col = excel_data.columns[13]  # Columna N
        
        # Validar que se encontraron las columnas necesarias
        if not nombre_col:
            return {
                'success': False,
                'message': f'Columna "Nombre" (A) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not codigo_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo" (B) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not unidad_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo Unidad" (E) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not cantidad_col:
            return {
                'success': False,
                'message': f'Columna "Cantidad" (N) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        
        column_mapping = {
            'Nombre': nombre_col,
            'C√≥digo': codigo_col,
            'C√≥digo Unidad': unidad_col,
            'Cantidad': cantidad_col
        }
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Limpiar datos anteriores para este inventario (marcar como inactivos)
        cursor.execute("""
            UPDATE datos_sistema_callao 
            SET estado = 'inactivo' 
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        # BORRAR COMPARACIONES ANTERIORES para asegurar que se regenere todo limpio con la nueva data
        cursor.execute("DELETE FROM comparaciones_callao WHERE inventario_id = %s", (inventario_id,))
        
        registros_procesados = 0
        
        # Insertar datos del Excel usando los nombres de columnas encontrados
        for _, row in excel_data.iterrows():
            try:
                # Obtener valores usando los nombres de columnas mapeados
                nombre_producto = str(row[column_mapping['Nombre']]).strip() if pd.notna(row[column_mapping['Nombre']]) else ''
                codigo_producto = str(row[column_mapping['C√≥digo']]).strip() if pd.notna(row[column_mapping['C√≥digo']]) else ''
                unidad_excel_raw = str(row[column_mapping['C√≥digo Unidad']]).strip().upper() if pd.notna(row[column_mapping['C√≥digo Unidad']]) else ''
                cantidad_raw = row[column_mapping['Cantidad']]
                
                # Validar que haya c√≥digo
                if not codigo_producto:
                    continue
                
                # Obtener producto del cat√°logo
                cursor.execute("""
                    SELECT item, unidad_medida 
                    FROM productos_inventario 
                    WHERE codigo = %s AND estado = 'activo'
                """, (codigo_producto,))
                
                producto = cursor.fetchone()
                
                # Convertir unidad de medida seg√∫n especificaci√≥n:
                # NIU ‚Üí UNIDAD
                # DC, DZN, DZP ‚Üí DOCENAS
                if unidad_excel_raw == 'NIU':
                    unidad_sistema = 'UNIDAD'
                elif unidad_excel_raw in ['DC', 'DZN', 'DZP']:
                    unidad_sistema = 'DOCENAS'
                else:
                    # Por defecto, usar UNIDAD si no coincide
                    unidad_sistema = 'UNIDAD'
                
                # Convertir cantidad a entero
                try:
                    cantidad_sistema = int(float(cantidad_raw)) if pd.notna(cantidad_raw) else 0
                except (ValueError, TypeError):
                    cantidad_sistema = 0
                
                # Insertar en datos_sistema_callao
                cursor.execute("""
                    INSERT INTO datos_sistema_callao (
                        inventario_id, producto_item, producto, codigo, 
                        cantidad_sistema, unidad_medida, archivo_origen, 
                        usuario_carga, estado
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'activo')
                """, (
                    inventario_id,
                    producto['item'] if producto else None,
                    nombre_producto,
                    codigo_producto,
                    cantidad_sistema,
                    unidad_sistema,
                    file.filename,
                    usuario
                ))
                
                registros_procesados += 1
            except Exception as e:
                logging.warning(f"Error al procesar fila del Excel en cargar_sistema_callao: {str(e)}")
                continue
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'SISTEMA_CALLAO',
            'CARGA_MASIVA',
            'callao',
            'CARGAR_SISTEMA',
            usuario,
            json.dumps({
                'archivo': file.filename,
                'registros': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_procesados': registros_procesados,
            'message': f'Se cargaron {registros_procesados} productos del sistema Callao desde hoja "{sheet_used}"'
        }
            
    except Exception as e:
        logging.error(f"Error en cargar_sistema_callao: {str(e)}")
        logging.error(f"Tipo de error: {type(e).__name__}")
        import traceback
        logging.error(f"Traceback: {traceback.format_exc()}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': f'Error al procesar el archivo Excel: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA CARGAR DATOS DEL SISTEMA DESDE EXCEL (MALVINAS)
# ============================================================
def cargar_sistema_malvinas(request):
    """
    Carga archivo Excel para datos del sistema en almac√©n Malvinas
    """
    try:
        # Obtener datos del formulario
        inventario_id = request.form.get('inventario_id')
        usuario = request.form.get('usuario')
        
        if 'excel_file' not in request.files:
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        try:
            file.seek(0)
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Leer columnas espec√≠ficas por posici√≥n seg√∫n especificaci√≥n:
        # Columna A (√≠ndice 0): Nombre
        # Columna B (√≠ndice 1): C√≥digo
        # Columna E (√≠ndice 4): C√≥digo Unidad
        # Columna N (√≠ndice 13): Cantidad
        
        # Primero intentar por nombre de columna (m√°s flexible)
        column_mapping = {}
        excel_data.columns = excel_data.columns.str.strip()
        
        # Buscar columnas por nombre primero
        nombre_col = None
        codigo_col = None
        unidad_col = None
        cantidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in ['NOMBRE', 'PRODUCTO', 'NOMBRE PRODUCTO']:
                nombre_col = col
            elif col_upper in ['C√ìDIGO', 'CODIGO', 'C√ìD', 'COD']:
                codigo_col = col
            elif col_upper in ['C√ìDIGO UNIDAD', 'CODIGO UNIDAD', 'UNIDAD', 'C√ìDIGO UNIDADES']:
                unidad_col = col
            elif col_upper in ['CANTIDAD', 'CANT', 'QTY']:
                cantidad_col = col
        
        # Si no se encontraron por nombre, usar posici√≥n (A=0, B=1, E=4, N=13)
        if not nombre_col and len(excel_data.columns) > 0:
            nombre_col = excel_data.columns[0]  # Columna A
        if not codigo_col and len(excel_data.columns) > 1:
            codigo_col = excel_data.columns[1]  # Columna B
        if not unidad_col and len(excel_data.columns) > 4:
            unidad_col = excel_data.columns[4]  # Columna E
        if not cantidad_col and len(excel_data.columns) > 13:
            cantidad_col = excel_data.columns[13]  # Columna N
        
        # Validar que se encontraron las columnas necesarias
        if not nombre_col:
            return {
                'success': False,
                'message': f'Columna "Nombre" (A) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not codigo_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo" (B) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not unidad_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo Unidad" (E) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not cantidad_col:
            return {
                'success': False,
                'message': f'Columna "Cantidad" (N) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        
        column_mapping = {
            'Nombre': nombre_col,
            'C√≥digo': codigo_col,
            'C√≥digo Unidad': unidad_col,
            'Cantidad': cantidad_col
        }
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Limpiar datos anteriores para este inventario (opcional)
        cursor.execute("""
            UPDATE datos_sistema_malvinas 
            SET estado = 'INACTIVO' 
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        # BORRAR COMPARACIONES ANTERIORES para asegurar que se regenere todo limpio con la nueva data
        cursor.execute("DELETE FROM comparaciones_malvinas WHERE inventario_id = %s", (inventario_id,))
        
        registros_procesados = 0
        
        # Insertar datos del Excel usando los nombres de columnas encontrados
        for _, row in excel_data.iterrows():
            try:
                # Obtener valores usando los nombres de columnas mapeados
                nombre_producto = str(row[column_mapping['Nombre']]).strip() if pd.notna(row[column_mapping['Nombre']]) else ''
                codigo_producto = str(row[column_mapping['C√≥digo']]).strip() if pd.notna(row[column_mapping['C√≥digo']]) else ''
                unidad_excel_raw = str(row[column_mapping['C√≥digo Unidad']]).strip().upper() if pd.notna(row[column_mapping['C√≥digo Unidad']]) else ''
                cantidad_raw = row[column_mapping['Cantidad']]
                
                # Validar que haya c√≥digo
                if not codigo_producto:
                    continue
                
                # Obtener producto del cat√°logo
                cursor.execute("""
                    SELECT item, unidad_medida 
                    FROM productos_inventario 
                    WHERE codigo = %s AND estado = 'activo'
                """, (codigo_producto,))
                
                producto = cursor.fetchone()
                
                # Convertir unidad de medida seg√∫n especificaci√≥n:
                # NIU ‚Üí UNIDAD
                # DC, DZN, DZP ‚Üí DOCENAS
                if unidad_excel_raw == 'NIU':
                    unidad_sistema = 'UNIDAD'
                elif unidad_excel_raw in ['DC', 'DZN', 'DZP']:
                    unidad_sistema = 'DOCENAS'
                else:
                    # Por defecto, usar UNIDAD si no coincide
                    unidad_sistema = 'UNIDAD'
                
                # Convertir cantidad a entero
                try:
                    cantidad_sistema = int(float(cantidad_raw)) if pd.notna(cantidad_raw) else 0
                except (ValueError, TypeError):
                    cantidad_sistema = 0
                
                # Insertar en datos_sistema_malvinas
                cursor.execute("""
                    INSERT INTO datos_sistema_malvinas (
                        inventario_id, producto_item, producto, codigo, 
                        cantidad_sistema, unidad_medida, archivo_origen, 
                        usuario_carga, estado
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'ACTIVO')
                """, (
                    inventario_id,
                    producto['item'] if producto else None,
                    nombre_producto,
                    codigo_producto,
                    cantidad_sistema,
                    unidad_sistema,
                    file.filename,
                    usuario
                ))
                
                registros_procesados += 1
            except Exception as e:
                logging.warning(f"Error al procesar fila del Excel en cargar_sistema_malvinas: {str(e)}")
                continue
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'SISTEMA_MALVINAS',
            'CARGA_MASIVA',
            'malvinas',
            'CARGAR_SISTEMA',
            usuario,
            json.dumps({
                'archivo': file.filename,
                'registros': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_procesados': registros_procesados,
            'message': f'Se cargaron {registros_procesados} productos del sistema Malvinas desde hoja "{sheet_used}"'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA GENERAR COMPARACION CALLAO
# ============================================================
def generar_comparacion_callao(data):
    """
    Genera comparaci√≥n autom√°tica para almac√©n Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        
        # Verificar que existe inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Llamar stored procedure para generar comparaci√≥n
        cursor.callproc('sp_generar_comparacion_callao', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''   # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_comparacion_callao_1, @_sp_generar_comparacion_callao_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_comparacion_callao_1']
        mensaje = result['@_sp_generar_comparacion_callao_2']
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'GENERACION_COMPARACION',
            'TODO',
            'callao',
            'GENERAR_COMPARACION',
            data.get('usuario', 'sistema'),
            json.dumps({
                'registros_procesados': registros_procesados
            })
        ))
        
        conn.commit()
        
        # Regenerar consolidado autom√°ticamente despu√©s de generar comparaci√≥n
        try:
            generar_consolidado_callao({'inventario_id': inventario_id})
            generar_consolidado_general({'inventario_id': inventario_id})
        except Exception as consolidado_error:
            # No fallar si el consolidado no se puede regenerar, solo loguear
            logging.warning(f"Error al regenerar consolidado despu√©s de generar comparaci√≥n Callao: {str(consolidado_error)}")
        
        return {
            'success': True,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA GENERAR COMPARACION MALVINAS
# ============================================================
def generar_comparacion_malvinas(data):
    """
    Genera comparaci√≥n autom√°tica para almac√©n Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        
        # Verificar que existe inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Llamar stored procedure para generar comparaci√≥n
        cursor.callproc('sp_generar_comparacion_malvinas', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''   # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_comparacion_malvinas_1, @_sp_generar_comparacion_malvinas_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_comparacion_malvinas_1']
        mensaje = result['@_sp_generar_comparacion_malvinas_2']
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'GENERACION_COMPARACION',
            'TODO',
            'malvinas',
            'GENERAR_COMPARACION',
            data.get('usuario', 'sistema'),
            json.dumps({
                'registros_procesados': registros_procesados
            })
        ))
        
        conn.commit()
        
        # Regenerar consolidado autom√°ticamente despu√©s de generar comparaci√≥n
        try:
            generar_consolidado_malvinas({'inventario_id': inventario_id})
            generar_consolidado_general({'inventario_id': inventario_id})
        except Exception as consolidado_error:
            # No fallar si el consolidado no se puede regenerar, solo loguear
            logging.warning(f"Error al regenerar consolidado despu√©s de generar comparaci√≥n Malvinas: {str(consolidado_error)}")
        
        return {
            'success': True,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER ESTADO DE CONTEOS POR TIENDA
# ============================================================
def obtener_estado_conteos_tiendas(inventario_id, almacen_id):
    """
    Obtiene el estado de los conteos por tienda, separando por tipo_conteo (por_cajas y por_stand)
    √ötil para el frontend para mostrar qu√© tiendas tienen conteos completados
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener todas las tiendas del almac√©n
        if almacen_id == 1:  # Callao
            # Callao no tiene tiendas (tienda_id = NULL)
            resultado = {
                'success': True,
                'almacen': 'Callao',
                'inventario_id': inventario_id,
                'conteos': {
                    'por_cajas': None,
                    'por_stand': None
                }
            }
            
            # Verificar conteo por cajas
            cursor.execute("""
                SELECT id, estado, tipo_conteo
                FROM conteos
                WHERE inventario_id = %s
                    AND almacen_id = %s
                    AND tienda_id IS NULL
                    AND tipo_conteo = 'por_cajas'
                    AND estado != 'anulado'
                ORDER BY id DESC
                LIMIT 1
            """, (inventario_id, almacen_id))
            conteo_cajas = cursor.fetchone()
            resultado['conteos']['por_cajas'] = {
                'existe': conteo_cajas is not None,
                'id': conteo_cajas['id'] if conteo_cajas else None,
                'estado': conteo_cajas['estado'] if conteo_cajas else None
            }
            
            # Verificar conteo por stand
            cursor.execute("""
                SELECT id, estado, tipo_conteo
                FROM conteos
                WHERE inventario_id = %s
                    AND almacen_id = %s
                    AND tienda_id IS NULL
                    AND tipo_conteo = 'por_stand'
                    AND estado != 'anulado'
                ORDER BY id DESC
                LIMIT 1
            """, (inventario_id, almacen_id))
            conteo_stand = cursor.fetchone()
            resultado['conteos']['por_stand'] = {
                'existe': conteo_stand is not None,
                'id': conteo_stand['id'] if conteo_stand else None,
                'estado': conteo_stand['estado'] if conteo_stand else None
            }
            
            return resultado
        else:  # Malvinas
            # Obtener todas las tiendas de Malvinas
            cursor.execute("""
                SELECT id, nombre_tienda 
                FROM tiendas 
                WHERE almacen_id = %s 
                ORDER BY id
            """, (almacen_id,))
            
            tiendas = cursor.fetchall()
            
            resultado = {
                'success': True,
                'almacen': 'Malvinas',
                'inventario_id': inventario_id,
                'tiendas': {}
            }
            
            # Para cada tienda, verificar estado de conteos por cajas y por stand
            for tienda in tiendas:
                tienda_id = tienda['id']
                nombre_tienda = tienda['nombre_tienda']
                
                # Verificar conteo por cajas
                cursor.execute("""
                    SELECT id, estado, tipo_conteo
                    FROM conteos
                    WHERE inventario_id = %s
                        AND almacen_id = %s
                        AND tienda_id = %s
                        AND tipo_conteo = 'por_cajas'
                        AND estado != 'anulado'
                    ORDER BY id DESC
                    LIMIT 1
                """, (inventario_id, almacen_id, tienda_id))
                conteo_cajas = cursor.fetchone()
                
                # Verificar conteo por stand
                cursor.execute("""
                    SELECT id, estado, tipo_conteo
                    FROM conteos
                    WHERE inventario_id = %s
                        AND almacen_id = %s
                        AND tienda_id = %s
                        AND tipo_conteo = 'por_stand'
                        AND estado != 'anulado'
                    ORDER BY id DESC
                    LIMIT 1
                """, (inventario_id, almacen_id, tienda_id))
                conteo_stand = cursor.fetchone()
                
                resultado['tiendas'][tienda_id] = {
                    'nombre': nombre_tienda,
                    'por_cajas': {
                        'existe': conteo_cajas is not None,
                        'id': conteo_cajas['id'] if conteo_cajas else None,
                        'estado': conteo_cajas['estado'] if conteo_cajas else None,
                        'completado': conteo_cajas['estado'] == 'finalizado' if conteo_cajas else False
                    },
                    'por_stand': {
                        'existe': conteo_stand is not None,
                        'id': conteo_stand['id'] if conteo_stand else None,
                        'estado': conteo_stand['estado'] if conteo_stand else None,
                        'completado': conteo_stand['estado'] == 'finalizado' if conteo_stand else False
                    }
                }
            
            return resultado
            
    except Exception as e:
        logging.error(f"Error en obtener_estado_conteos_tiendas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener estado de conteos: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR DATOS DEL SISTEMA CALLAO
# ============================================================
def listar_datos_sistema_callao(inventario_id):
    """
    Lista los datos del sistema cargados desde Excel para Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                id,
                producto_item as item,
                producto,
                codigo,
                cantidad_sistema,
                unidad_medida,
                DATE_FORMAT(fecha_carga, '%%d/%%m/%%Y %%H:%%i') as fecha_carga,
                archivo_origen,
                usuario_carga,
                estado
            FROM datos_sistema_callao
            WHERE inventario_id = %s AND estado = 'activo'
            ORDER BY producto
        """, (inventario_id,))
        
        datos = cursor.fetchall()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Callao',
            'datos': datos,
            'total_registros': len(datos)
        }
    except Exception as e:
        logging.error(f"Error en listar_datos_sistema_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar datos del sistema: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER COMPARACION CALLAO
# ============================================================
def obtener_comparacion_callao(inventario_id):
    """
    Obtiene la tabla de comparaci√≥n para almac√©n Callao.
    SIEMPRE inyecta la cantidad f√≠sica real sumada desde los conteos y asegura que aparezcan TODOS los items del sistema.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 1. Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        almacen_id = almacen_callao['id'] if almacen_callao else None
        
        if not almacen_id:
            return {'success': False, 'message': 'No se encontr√≥ el almac√©n Callao'}
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (SIEMPRE)
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # 3. CONSULTA MAESTRA: Unir Sistema con Comparaciones
        # Esto asegura que aparezcan todos los items cargados (ej. los 209)
        cursor.execute("""
            SELECT 
                ds.id as sistema_id,
                cc.id as comparacion_id,
                ds.producto_item as item,
                ds.producto,
                ds.codigo,
                COALESCE(cc.cantidad_sistema, ds.cantidad_sistema) as cantidad_sistema,
                cc.cantidad_fisica as cant_fisica_db,
                cc.resultado as resultado_db,
                cc.estado as estado_db,
                ds.unidad_medida,
                DATE_FORMAT(cc.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                pi.unidad_medida as unidad_catalogo
            FROM datos_sistema_callao ds
            LEFT JOIN comparaciones_callao cc ON ds.inventario_id = cc.inventario_id AND ds.codigo = cc.codigo
            LEFT JOIN productos_inventario pi ON ds.producto_item = pi.item
            WHERE ds.inventario_id = %s AND ds.estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            ORDER BY ds.producto
        """, (inventario_id,))
        
        datos_base = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales en vivo
        comparacion_final = []
        total_sistema = 0; total_fisico = 0; diferencia_total = 0
        conformes = 0; sobrantes = 0; faltantes = 0; sin_conteo = 0
        
        for item in datos_base:
            codigo = str(item.get('codigo') or '').strip().upper()
            cant_sistema = float(item['cantidad_sistema'] or 0)
            
            # Cantidad f√≠sica: Prioridad 1: Conteo real en vivo
            cant_fisica_raw = conteos_fisicos.get(codigo, None)
            # Prioridad 2: Guardado en DB
            cant_fisica_db = item.get('cant_fisica_db')
            
            cant_fisica = 0.0
            tiene_conteo = False
            
            if cant_fisica_db is not None:
                cant_fisica = float(cant_fisica_db)
                tiene_conteo = True
            elif cant_fisica_raw is not None:
                cant_fisica = float(cant_fisica_raw)
                tiene_conteo = True
            
            diferencia = cant_fisica - cant_sistema
            
            # Determinar estado REAL
            if not tiene_conteo:
                estado = 'SISTEMA'
                sin_conteo += 1
            elif diferencia == 0: 
                estado = 'CONFORME'
                conformes += 1
            elif diferencia > 0: 
                estado = 'SOBRANTE'
                sobrantes += 1
            else: 
                estado = 'FALTANTE'
                faltantes += 1
                
            total_sistema += cant_sistema
            if tiene_conteo:
                total_fisico += cant_fisica
                diferencia_total += diferencia
            
            comparacion_final.append({
                'id': item['comparacion_id'] or item['sistema_id'],
                'item': item['item'],
                'producto': item['producto'],
                'codigo': item['codigo'],
                'cantidad_sistema': int(cant_sistema),
                'cantidad_fisica': int(cant_fisica) if tiene_conteo else 0,
                'resultado': int(diferencia) if tiene_conteo else 0,
                'estado': estado,
                'unidad_medida': item['unidad_medida'] or 'UND',
                'fecha_comparacion': item['fecha_comparacion']
            })
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Callao',
            'comparaciones': comparacion_final,
            'resumen': {
                'total_productos': len(comparacion_final),
                'conformes': conformes,
                'sobrantes': sobrantes,
                'faltantes': faltantes,
                'sin_conteo': sin_conteo,
                'total_sistema': int(total_sistema),
                'total_fisico': int(total_fisico),
                'diferencia_total': int(diferencia_total)
            },
            'sistema_cargado': True,
            'total_registros': len(comparacion_final)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA LISTAR DATOS DEL SISTEMA MALVINAS
# ============================================================
def listar_datos_sistema_malvinas(inventario_id):
    """
    Lista los datos del sistema cargados desde Excel para Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                id,
                producto_item as item,
                producto,
                codigo,
                cantidad_sistema,
                unidad_medida,
                DATE_FORMAT(fecha_carga, '%%d/%%m/%%Y %%H:%%i') as fecha_carga,
                archivo_origen,
                usuario_carga,
                estado
            FROM datos_sistema_malvinas
            WHERE inventario_id = %s AND estado = 'ACTIVO'
            ORDER BY producto
        """, (inventario_id,))
        
        datos = cursor.fetchall()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Malvinas',
            'datos': datos,
            'total_registros': len(datos)
        }
    except Exception as e:
        logging.error(f"Error en listar_datos_sistema_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar datos del sistema: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER COMPARACION MALVINAS
# ============================================================
def obtener_comparacion_malvinas(inventario_id):
    """
    Obtiene la tabla de comparaci√≥n para almac√©n Malvinas.
    SIEMPRE inyecta la cantidad f√≠sica real sumada desde los conteos y asegura que aparezcan TODOS los items del sistema.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 1. Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        almacen_id = almacen_malvinas['id'] if almacen_malvinas else None
        
        if not almacen_id:
            return {'success': False, 'message': 'No se encontr√≥ el almac√©n Malvinas'}
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (SIEMPRE)
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # 3. CONSULTA MAESTRA: Unir Sistema con Comparaciones
        cursor.execute("""
            SELECT 
                ds.id as sistema_id,
                cc.id as comparacion_id,
                ds.producto_item as item,
                ds.producto,
                ds.codigo,
                COALESCE(cc.cantidad_sistema, ds.cantidad_sistema) as cantidad_sistema,
                cc.cantidad_fisica as cant_fisica_db,
                cc.resultado as resultado_db,
                cc.estado as estado_db,
                ds.unidad_medida,
                DATE_FORMAT(cc.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                pi.unidad_medida as unidad_catalogo
            FROM datos_sistema_malvinas ds
            LEFT JOIN comparaciones_malvinas cc ON ds.inventario_id = cc.inventario_id AND ds.codigo = cc.codigo
            LEFT JOIN productos_inventario pi ON ds.producto_item = pi.item
            WHERE ds.inventario_id = %s AND ds.estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            ORDER BY ds.producto
        """, (inventario_id,))
        
        datos_base = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales en vivo
        comparacion_final = []
        total_sistema = 0; total_fisico = 0; diferencia_total = 0
        conformes = 0; sobrantes = 0; faltantes = 0; sin_conteo = 0
        
        for item in datos_base:
            codigo = str(item.get('codigo') or '').strip().upper()
            cant_sistema = float(item['cantidad_sistema'] or 0)
            
            # Cantidad f√≠sica: Prioridad 1: Conteo real en vivo
            cant_fisica_raw = conteos_fisicos.get(codigo, None)
            # Prioridad 2: Guardado en DB
            cant_fisica_db = item.get('cant_fisica_db')
            
            cant_fisica = 0.0
            tiene_conteo = False
            
            if cant_fisica_db is not None:
                cant_fisica = float(cant_fisica_db)
                tiene_conteo = True
            elif cant_fisica_raw is not None:
                cant_fisica = float(cant_fisica_raw)
                tiene_conteo = True
            
            diferencia = cant_fisica - cant_sistema
            
            # Determinar estado REAL
            if not tiene_conteo:
                estado = 'SISTEMA'
                sin_conteo += 1
            elif diferencia == 0: 
                estado = 'CONFORME'
                conformes += 1
            elif diferencia > 0: 
                estado = 'SOBRANTE'
                sobrantes += 1
            else: 
                estado = 'FALTANTE'
                faltantes += 1
                
            total_sistema += cant_sistema
            if tiene_conteo:
                total_fisico += cant_fisica
                diferencia_total += diferencia
            
            comparacion_final.append({
                'id': item['comparacion_id'] or item['sistema_id'],
                'item': item['item'],
                'producto': item['producto'],
                'codigo': item['codigo'],
                'cantidad_sistema': int(cant_sistema),
                'cantidad_fisica': int(cant_fisica) if tiene_conteo else 0,
                'resultado': int(diferencia) if tiene_conteo else 0,
                'estado': estado,
                'unidad_medida': item['unidad_medida'] or 'UND',
                'fecha_comparacion': item['fecha_comparacion']
            })
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Malvinas',
            'comparaciones': comparacion_final,
            'resumen': {
                'total_productos': len(comparacion_final),
                'conformes': conformes,
                'sobrantes': sobrantes,
                'faltantes': faltantes,
                'sin_conteo': sin_conteo,
                'total_sistema': int(total_sistema),
                'total_fisico': int(total_fisico),
                'diferencia_total': int(diferencia_total)
            },
            'sistema_cargado': True,
            'total_registros': len(comparacion_final)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA EDITAR CANTIDAD FISICA
# ============================================================
def editar_cantidad_fisica(data):
    """
    Edita la cantidad f√≠sica de un producto en la comparaci√≥n
    Si la comparaci√≥n no existe, la crea primero desde datos_sistema
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        comparacion_id = data['comparacion_id']
        almacen = data['almacen']
        nueva_cantidad = data['nueva_cantidad']
        motivo = data.get('motivo', '')
        registrado_por = data['registrado_por']
        error_de = data.get('error_de', '')
        observaciones = data.get('observaciones', '')
        
        # Determinar tablas seg√∫n almac√©n
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        tabla_sistema = 'datos_sistema_callao' if almacen == 'callao' else 'datos_sistema_malvinas'
        
        # Obtener datos actuales de comparaci√≥n
        # Verificamos que el ID coincida y que pertenezca a la tabla de comparaciones
        cursor.execute(f"""
            SELECT 
                id, cantidad_fisica, producto_item, producto, codigo, inventario_id, cantidad_sistema
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (comparacion_id,))
        
        comparacion = cursor.fetchone()
        
        # SI el registro fue encontrado pero NO tiene el inventario_id correcto (overlap de IDs),
        # lo tratamos como si no existiera para buscarlo en datos_sistema
        # Esto ocurre porque comparacion_id puede ser un ID de datos_sistema o de comparaciones
        if comparacion and 'inventario_id' in data and str(comparacion['inventario_id']) != str(data.get('inventario_id', comparacion['inventario_id'])):
             comparacion = None

        # Si no existe en comparaciones, buscar en datos_sistema y crear la comparaci√≥n
        if not comparacion:
            cursor.execute(f"""
                SELECT 
                    id, inventario_id, producto_item, producto, codigo, cantidad_sistema, unidad_medida
                FROM {tabla_sistema}
                WHERE id = %s AND estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            """, (comparacion_id,))
            
            dato_sistema = cursor.fetchone()
            
            # Si no est√° en datos_sistema, buscar en productos_inventario (cat√°logo)
            if not dato_sistema:
                # El comparacion_id puede ser el item del cat√°logo
                cursor.execute("""
                    SELECT 
                        item as id, 
                        item as producto_item,
                        producto,
                        codigo,
                        unidad_medida
                    FROM productos_inventario
                    WHERE item = %s AND estado = 'activo'
                """, (comparacion_id,))
                
                producto_catalogo = cursor.fetchone()
                
                if not producto_catalogo:
                    return {'success': False, 'message': 'Comparaci√≥n o Producto no encontrado'}
                
                # Obtener inventario activo
                cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
                inventario_activo = cursor.fetchone()
                
                if not inventario_activo:
                    return {'success': False, 'message': 'No hay inventario activo'}
                
                # Crear estructura similar a dato_sistema desde el cat√°logo
                dato_sistema = {
                    'id': producto_catalogo['id'],
                    'inventario_id': inventario_activo['id'],
                    'producto_item': producto_catalogo['producto_item'],
                    'producto': producto_catalogo['producto'],
                    'codigo': producto_catalogo['codigo'],
                    'cantidad_sistema': 0,  # Sin Excel, cantidad sistema es 0
                    'unidad_medida': producto_catalogo['unidad_medida'] or 'UNIDAD'
                }
            
            if not dato_sistema:
                return {'success': False, 'message': 'Comparaci√≥n o Producto no encontrado'}
            
            # OBTENER CANTIDAD F√çSICA ACTUAL DESDE CONTEOS (Si ya existen algunos)
            cursor.execute("SELECT id FROM almacenes WHERE nombre = %s", (almacen.capitalize(),))
            almacen_row = cursor.fetchone()
            almacen_id = almacen_row['id'] if almacen_row else None
            
            cantidad_fisica_actual = 0
            if almacen_id:
                cursor.execute("""
                    SELECT SUM(dc.cantidad) as total_fisico
                    FROM detalle_conteo dc
                    JOIN conteos c ON dc.conteo_id = c.id
                    JOIN productos_inventario pi ON dc.item_producto = pi.item
                    WHERE c.inventario_id = %s AND c.almacen_id = %s 
                        AND c.estado != 'anulado' AND pi.codigo = %s
                """, (dato_sistema['inventario_id'], almacen_id, dato_sistema['codigo']))
                res_f = cursor.fetchone()
                cantidad_fisica_actual = float(res_f['total_fisico']) if res_f and res_f['total_fisico'] else 0.0

            cantidad_sistema_actual = dato_sistema['cantidad_sistema'] or 0
            cantidad_anterior = cantidad_fisica_actual # La cantidad f√≠sica anterior es lo que hab√≠a en conteos
            
            # Crear la comparaci√≥n
            cursor.execute(f"""
                INSERT INTO {tabla_comparacion} (
                    inventario_id, producto_item, producto, codigo,
                    cantidad_sistema, cantidad_fisica, resultado, estado, unidad_medida
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                dato_sistema['inventario_id'],
                dato_sistema['producto_item'],
                dato_sistema['producto'],
                dato_sistema['codigo'],
                cantidad_sistema_actual,
                nueva_cantidad, # Insertamos directamente la nueva
                nueva_cantidad - cantidad_sistema_actual,
                'CONFORME' if (nueva_cantidad - cantidad_sistema_actual) == 0 else ('SOBRANTE' if (nueva_cantidad - cantidad_sistema_actual) > 0 else 'FALTANTE'),
                dato_sistema['unidad_medida']
            ))
            
            comparacion_id = cursor.lastrowid
            comparacion = {
                'inventario_id': dato_sistema['inventario_id'],
                'producto_item': dato_sistema['producto_item'],
                'producto': dato_sistema['producto'],
                'codigo': dato_sistema['codigo']
            }
        else:
            # SI ya existe, pero la cantidad f√≠sica es 0 o null, intentamos ver si hay conteos reales
            # para que el historial no muestre "Ant: 0" injustificadamente
            cantidad_anterior = comparacion['cantidad_fisica'] if comparacion['cantidad_fisica'] is not None else 0
            
            if cantidad_anterior == 0:
                cursor.execute("SELECT id FROM almacenes WHERE nombre = %s", (almacen.capitalize(),))
                al_row = cursor.fetchone()
                if al_row:
                    cursor.execute("""
                        SELECT SUM(dc.cantidad) as total_fisico
                        FROM detalle_conteo dc
                        JOIN conteos c ON dc.conteo_id = c.id
                        JOIN productos_inventario pi ON dc.item_producto = pi.item
                        WHERE c.inventario_id = %s AND c.almacen_id = %s 
                            AND c.estado != 'anulado' AND pi.codigo = %s
                    """, (comparacion['inventario_id'], al_row['id'], comparacion['codigo']))
                    res_hist = cursor.fetchone()
                    if res_hist and res_hist['total_fisico']:
                        cantidad_anterior = float(res_hist['total_fisico'])
            
            # Actualizar comparaci√≥n existente
            cursor.execute(f"""
                UPDATE {tabla_comparacion}
                SET cantidad_fisica = %s,
                    resultado = %s - cantidad_sistema,
                    estado = CASE
                        WHEN %s = cantidad_sistema THEN 'CONFORME'
                        WHEN %s > cantidad_sistema THEN 'SOBRANTE'
                        ELSE 'FALTANTE'
                    END,
                    ultima_actualizacion = CURRENT_TIMESTAMP
                WHERE id = %s
            """, (nueva_cantidad, nueva_cantidad, nueva_cantidad, nueva_cantidad, comparacion_id))
        
        # Registrar en tabla de ediciones
        cursor.execute("""
            INSERT INTO ediciones_cantidad_fisica (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto, cantidad_fisica_anterior,
                cantidad_fisica_nueva, motivo, registrado_por,
                error_de, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion_id,
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            cantidad_anterior,
            nueva_cantidad,
            motivo,
            registrado_por,
            error_de,
            observaciones
        ))
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, cantidad_afectada,
                error_de, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'EDITAR_CANTIDAD_FISICA',
            motivo,
            nueva_cantidad - cantidad_anterior,
            error_de,
            registrado_por,
            json.dumps({
                'cantidad_anterior': cantidad_anterior,
                'cantidad_nueva': nueva_cantidad,
                'diferencia': nueva_cantidad - cantidad_anterior
            })
        ))
        
        conn.commit()
        
        # Actualizar autom√°ticamente el consolidado del almac√©n correspondiente
        try:
            inventario_id = comparacion['inventario_id']
            if almacen == 'callao':
                obtener_consolidado_callao(inventario_id)
            elif almacen == 'malvinas':
                obtener_consolidado_malvinas(inventario_id)
            # Actualizar tambi√©n el consolidado general
            obtener_consolidado_general(inventario_id)
            logging.info(f"Consolidados actualizados autom√°ticamente despu√©s de editar cantidad f√≠sica en {almacen}")
        except Exception as e:
            logging.error(f"Error al actualizar consolidados autom√°ticamente: {str(e)}")
            # No fallar la operaci√≥n principal si falla la actualizaci√≥n de consolidado
        
        return {
            'success': True,
            'message': 'Cantidad f√≠sica actualizada correctamente',
            'comparacion_id': comparacion_id,
            'diferencia': nueva_cantidad - cantidad_anterior
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA EDITAR CANTIDAD SISTEMA
# ============================================================
def editar_cantidad_sistema(data):
    """
    Edita la cantidad del sistema de un producto en la comparaci√≥n
    Si la comparaci√≥n no existe, la crea primero desde datos_sistema
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        comparacion_id = data['comparacion_id']
        almacen = data['almacen']
        nueva_cantidad = data['nueva_cantidad']
        motivo = data.get('motivo', '')
        registrado_por = data['registrado_por']
        error_de = data.get('error_de', '')
        observaciones = data.get('observaciones', '')
        
        # Determinar tablas seg√∫n almac√©n
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        tabla_sistema = 'datos_sistema_callao' if almacen == 'callao' else 'datos_sistema_malvinas'
        
        # Obtener datos actuales de comparaci√≥n
        cursor.execute(f"""
            SELECT 
                id, cantidad_sistema, producto_item, producto, codigo, inventario_id, cantidad_fisica
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (comparacion_id,))
        
        comparacion = cursor.fetchone()
        
        # SI el registro fue encontrado pero NO tiene el inventario_id correcto (overlap de IDs),
        # lo tratamos como si no existiera para buscarlo en datos_sistema
        if comparacion and 'inventario_id' in data and str(comparacion['inventario_id']) != str(data.get('inventario_id', comparacion['inventario_id'])):
             comparacion = None

        # Si no existe en comparaciones, buscar en datos_sistema y crear la comparaci√≥n
        if not comparacion:
            cursor.execute(f"""
                SELECT 
                    id, inventario_id, producto_item, producto, codigo, cantidad_sistema, unidad_medida
                FROM {tabla_sistema}
                WHERE id = %s AND estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            """, (comparacion_id,))
            
            dato_sistema = cursor.fetchone()
            
            # Si no est√° en datos_sistema, buscar en productos_inventario (cat√°logo)
            if not dato_sistema:
                # El comparacion_id puede ser el item del cat√°logo
                cursor.execute("""
                    SELECT 
                        item as id, 
                        item as producto_item,
                        producto,
                        codigo,
                        unidad_medida
                    FROM productos_inventario
                    WHERE item = %s AND estado = 'activo'
                """, (comparacion_id,))
                
                producto_catalogo = cursor.fetchone()
                
                if not producto_catalogo:
                    return {'success': False, 'message': 'Producto no encontrado en el sistema'}
                
                # Obtener inventario activo
                cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
                inventario_activo = cursor.fetchone()
                
                if not inventario_activo:
                    return {'success': False, 'message': 'No hay inventario activo'}
                
                # Crear estructura similar a dato_sistema desde el cat√°logo
                dato_sistema = {
                    'id': producto_catalogo['id'],
                    'inventario_id': inventario_activo['id'],
                    'producto_item': producto_catalogo['producto_item'],
                    'producto': producto_catalogo['producto'],
                    'codigo': producto_catalogo['codigo'],
                    'cantidad_sistema': 0,  # Sin Excel, cantidad sistema es 0
                    'unidad_medida': producto_catalogo['unidad_medida'] or 'UNIDAD'
                }
            
            if not dato_sistema:
                return {'success': False, 'message': 'Producto no encontrado en el sistema'}
            
            # Crear la comparaci√≥n en comparaciones_callao/comparaciones_malvinas
            cantidad_sistema_actual = dato_sistema['cantidad_sistema'] or 0
            cantidad_fisica_actual = 0  # Inicialmente 0
            resultado = cantidad_fisica_actual - nueva_cantidad  # Usar nueva_cantidad para el c√°lculo
            
            estado = 'CONFORME' if resultado == 0 else ('SOBRANTE' if resultado > 0 else 'FALTANTE')
            
            cursor.execute(f"""
                INSERT INTO {tabla_comparacion} (
                    inventario_id, producto_item, producto, codigo,
                    cantidad_sistema, cantidad_fisica, resultado, estado, unidad_medida
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                dato_sistema['inventario_id'],
                dato_sistema['producto_item'],
                dato_sistema['producto'],
                dato_sistema['codigo'],
                nueva_cantidad,  # Usar la nueva cantidad directamente
                cantidad_fisica_actual,
                resultado,
                estado,
                dato_sistema['unidad_medida']
            ))
            
            # Obtener el nuevo ID de comparaci√≥n creada
            nuevo_comparacion_id = cursor.lastrowid
            
            # Preparar datos para el resto del proceso
            comparacion = {
                'cantidad_sistema': cantidad_sistema_actual,
                'producto_item': dato_sistema['producto_item'],
                'producto': dato_sistema['producto'],
                'codigo': dato_sistema['codigo'],
                'inventario_id': dato_sistema['inventario_id']
            }
            cantidad_anterior = cantidad_sistema_actual
            comparacion_id = nuevo_comparacion_id  # Usar el nuevo ID
        else:
            # SI ya existe, pero la cantidad anterior es 0 o null, intentamos ver si hay datos reales
            cantidad_anterior = comparacion['cantidad_sistema'] if comparacion['cantidad_sistema'] is not None else 0
            
            # Actualizar comparaci√≥n existente 
            # (Aqu√≠ no necesitamos buscar en conteos porque esta funci√≥n edita el SISTEMA)
            # Pero para el historial f√≠sico s√≠ es importante que la cantidad f√≠sica en la comparaci√≥n
            # sea correcta. Sin embargo, esta funci√≥n es EDITAR_CANTIDAD_SISTEMA.
            
            cursor.execute(f"""
                UPDATE {tabla_comparacion}
                SET cantidad_sistema = %s,
                    resultado = cantidad_fisica - %s,
                    estado = CASE
                        WHEN cantidad_fisica = %s THEN 'CONFORME'
                        WHEN cantidad_fisica > %s THEN 'SOBRANTE'
                        ELSE 'FALTANTE'
                    END,
                    ultima_actualizacion = CURRENT_TIMESTAMP
                WHERE id = %s
            """, (nueva_cantidad, nueva_cantidad, nueva_cantidad, nueva_cantidad, comparacion_id))
            
            # Actualizar datos del sistema
            cursor.execute(f"""
                UPDATE {tabla_sistema}
                SET cantidad_sistema = %s,
                    estado = 'MODIFICADO'
                WHERE inventario_id = %s AND codigo = %s
            """, (nueva_cantidad, comparacion['inventario_id'], comparacion['codigo']))
        
        # Registrar en tabla de ediciones
        cursor.execute("""
            INSERT INTO ediciones_cantidad_sistema (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto, cantidad_sistema_anterior,
                cantidad_sistema_nueva, motivo, registrado_por,
                error_de, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion_id,
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            cantidad_anterior,
            nueva_cantidad,
            motivo,
            registrado_por,
            error_de,
            observaciones
        ))
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, cantidad_afectada,
                error_de, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'EDITAR_CANTIDAD_SISTEMA',
            motivo,
            nueva_cantidad - cantidad_anterior,
            error_de,
            registrado_por,
            json.dumps({
                'cantidad_anterior': cantidad_anterior,
                'cantidad_nueva': nueva_cantidad,
                'diferencia': nueva_cantidad - cantidad_anterior
            })
        ))
        
        conn.commit()
        
        # Actualizar autom√°ticamente los consolidados despu√©s de editar cantidad sistema
        try:
            inventario_id = comparacion['inventario_id']
            if almacen == 'callao':
                obtener_consolidado_callao(inventario_id)
            elif almacen == 'malvinas':
                obtener_consolidado_malvinas(inventario_id)
            # Actualizar tambi√©n el consolidado general
            obtener_consolidado_general(inventario_id)
            logging.info(f"Consolidados actualizados autom√°ticamente despu√©s de editar cantidad sistema en {almacen}")
        except Exception as consolidado_error:
            # No fallar si el consolidado no se puede actualizar, solo loguear
            logging.warning(f"Error al actualizar consolidado despu√©s de editar cantidad sistema: {str(consolidado_error)}")
        
        return {
            'success': True,
            'message': 'Cantidad sistema actualizada correctamente',
            'comparacion_id': comparacion_id,
            'diferencia': nueva_cantidad - cantidad_anterior
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA REGISTRAR VERIFICACION 
# ============================================================
def registrar_verificacion(data):
    """
    Registra una verificaci√≥n detallada para un producto
    Si la comparaci√≥n no existe, la crea primero desde datos_sistema
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener datos del sistema y f√≠sico
        almacen = data['almacen']
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        tabla_sistema = 'datos_sistema_callao' if almacen == 'callao' else 'datos_sistema_malvinas'
        
        cursor.execute(f"""
            SELECT 
                id, cantidad_fisica, cantidad_sistema, producto_item,
                producto, codigo, inventario_id
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (data['comparacion_id'],))
        
        comparacion = cursor.fetchone()
        
        # SI el registro fue encontrado pero NO tiene el inventario_id correcto (overlap de IDs),
        # lo tratamos como si no existiera para buscarlo en datos_sistema
        if comparacion and 'inventario_id' in data and str(comparacion['inventario_id']) != str(data.get('inventario_id', comparacion['inventario_id'])):
             comparacion = None

        # Si no existe en comparaciones, buscar en datos_sistema o productos_inventario
        if not comparacion:
            # Primero intentar buscar en datos_sistema (si hay Excel subido)
            cursor.execute(f"""
                SELECT 
                    id, inventario_id, producto_item, producto, codigo, cantidad_sistema, unidad_medida
                FROM {tabla_sistema}
                WHERE id = %s AND estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            """, (data['comparacion_id'],))
            
            dato_sistema = cursor.fetchone()
            
            # Si no est√° en datos_sistema, buscar en productos_inventario (cat√°logo)
            if not dato_sistema:
                # El comparacion_id puede ser el item del cat√°logo
                cursor.execute("""
                    SELECT 
                        item as id, 
                        item as producto_item,
                        producto,
                        codigo,
                        unidad_medida
                    FROM productos_inventario
                    WHERE item = %s AND estado = 'activo'
                """, (data['comparacion_id'],))
                
                producto_catalogo = cursor.fetchone()
                
                if not producto_catalogo:
                    return {'success': False, 'message': 'Producto no encontrado para verificar'}
                
                # Obtener inventario activo
                cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
                inventario_activo = cursor.fetchone()
                
                if not inventario_activo:
                    return {'success': False, 'message': 'No hay inventario activo'}
                
                # Crear estructura similar a dato_sistema desde el cat√°logo
                dato_sistema = {
                    'id': producto_catalogo['id'],
                    'inventario_id': inventario_activo['id'],
                    'producto_item': producto_catalogo['producto_item'],
                    'producto': producto_catalogo['producto'],
                    'codigo': producto_catalogo['codigo'],
                    'cantidad_sistema': 0,  # Sin Excel, cantidad sistema es 0
                    'unidad_medida': producto_catalogo['unidad_medida'] or 'UNIDAD'
                }
            
            if not dato_sistema:
                return {'success': False, 'message': 'Producto no encontrado para verificar'}
            
            # Obtener cantidad f√≠sica real desde los conteos
            # Obtener ID del almac√©n
            cursor.execute("SELECT id FROM almacenes WHERE nombre = %s", (almacen.capitalize(),))
            almacen_row = cursor.fetchone()
            almacen_id = almacen_row['id'] if almacen_row else None
            
            cantidad_fisica_actual = 0
            if almacen_id:
                # Sumar conteos f√≠sicos para este producto
                cursor.execute("""
                    SELECT SUM(dc.cantidad) as total_fisico
                    FROM detalle_conteo dc
                    JOIN conteos c ON dc.conteo_id = c.id
                    JOIN productos_inventario pi ON dc.item_producto = pi.item
                    WHERE c.inventario_id = %s 
                        AND c.almacen_id = %s 
                        AND c.estado != 'anulado'
                        AND pi.codigo = %s
                        AND dc.cantidad > 0
                """, (dato_sistema['inventario_id'], almacen_id, dato_sistema['codigo']))
                
                resultado_fisico = cursor.fetchone()
                cantidad_fisica_actual = float(resultado_fisico['total_fisico']) if resultado_fisico and resultado_fisico['total_fisico'] else 0.0
            
            cantidad_sistema_actual = dato_sistema['cantidad_sistema'] or 0
            resultado = cantidad_fisica_actual - cantidad_sistema_actual
            estado = 'CONFORME' if resultado == 0 else ('SOBRANTE' if resultado > 0 else 'FALTANTE')
            
            # Crear la comparaci√≥n
            cursor.execute(f"""
                INSERT INTO {tabla_comparacion} (
                    inventario_id, producto_item, producto, codigo,
                    cantidad_sistema, cantidad_fisica, resultado, estado, unidad_medida
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                dato_sistema['inventario_id'],
                dato_sistema['producto_item'],
                dato_sistema['producto'],
                dato_sistema['codigo'],
                cantidad_sistema_actual,
                cantidad_fisica_actual,
                resultado,
                estado,
                dato_sistema['unidad_medida']
            ))
            
            # Obtener el nuevo ID de comparaci√≥n creada
            nuevo_comparacion_id = cursor.lastrowid
            
            # Preparar datos para el resto del proceso
            comparacion = {
                'cantidad_fisica': cantidad_fisica_actual,
                'cantidad_sistema': cantidad_sistema_actual,
                'producto_item': dato_sistema['producto_item'],
                'producto': dato_sistema['producto'],
                'codigo': dato_sistema['codigo'],
                'inventario_id': dato_sistema['inventario_id']
            }
            data['comparacion_id'] = nuevo_comparacion_id  # Actualizar el ID para usar el nuevo
        
        # Calcular stock_existencia (Compras - Ventas)
        compras_totales = float(data.get('compras_totales', 0))
        ventas_totales = float(data.get('ventas_totales', 0))
        stock_existencia = compras_totales - ventas_totales
        
        stock_fisico = float(comparacion['cantidad_fisica'])
        stock_sistema = float(comparacion['cantidad_sistema'])
        
        # Calcular estado de verificaci√≥n seg√∫n los 4 casos
        # Caso 1: stock_existencia coincide con stock_fisico pero NO con stock_sistema ‚Üí Error de Sistema
        # Caso 2: stock_existencia coincide con stock_sistema pero NO con stock_fisico ‚Üí Error de Log√≠stica
        # Caso 3: stock_existencia NO coincide ni con stock_fisico ni con stock_sistema ‚Üí Nuevo conteo requerido
        # Caso 4: todos coinciden ‚Üí CONFORME
        
        estado_verificacion = None
        mensaje_estado = ''
        
        # Usar tolerancia peque√±a para comparaciones de decimales
        tolerancia = 0.01
        
        coincide_existencia_fisico = abs(stock_existencia - stock_fisico) < tolerancia
        coincide_existencia_sistema = abs(stock_existencia - stock_sistema) < tolerancia
        coincide_fisico_sistema = abs(stock_fisico - stock_sistema) < tolerancia
        
        if coincide_existencia_fisico and coincide_existencia_sistema and coincide_fisico_sistema:
            # Caso 4: Todos coinciden
            estado_verificacion = 'CONFORME'
            mensaje_estado = 'Todos los valores coinciden correctamente'
        elif coincide_existencia_fisico and not coincide_existencia_sistema:
            # Caso 1: Existencia = F√≠sico, pero Sistema es diferente
            estado_verificacion = 'ERROR DE SISTEMA'
            mensaje_estado = f'El sistema est√° mal. Stock existencia ({stock_existencia}) coincide con f√≠sico ({stock_fisico}) pero no con sistema ({stock_sistema})'
        elif coincide_existencia_sistema and not coincide_existencia_fisico:
            # Caso 2: Existencia = Sistema, pero F√≠sico es diferente
            estado_verificacion = 'ERROR DE LOG√çSTICA'
            mensaje_estado = f'Error de log√≠stica. Stock existencia ({stock_existencia}) coincide con sistema ({stock_sistema}) pero no con f√≠sico ({stock_fisico})'
        else:
            # Caso 3: Existencia no coincide ni con f√≠sico ni con sistema
            estado_verificacion = 'REALIZAR NUEVO CONTEO'
            mensaje_estado = f'Se requiere nuevo conteo. Stock existencia ({stock_existencia}) no coincide ni con f√≠sico ({stock_fisico}) ni con sistema ({stock_sistema})'
        
        # Insertar verificaci√≥n
        cursor.execute("""
            INSERT INTO verificaciones (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto,
                
                -- Compras
                fecha_ingreso_compra, hora_ingreso_compra,
                numero_acta, fecha_descarga_compra, hora_descarga_compra,
                
                -- Ventas
                fecha_descarga_ventas, hora_descarga_ventas,
                fecha_descarga_sistema, hora_descarga_sistema,
                
                -- Resultado General
                compras_totales, ventas_totales, stock_existencia,
                
                -- Resultado de Verificaci√≥n
                stock_fisico, stock_sistema, estado_verificacion,
                mensaje_estado,
                
                -- Metadatos
                registrado_por, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                     %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                     %s, %s, %s)
        """, (
            data['comparacion_id'],
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            
            # Compras
            data.get('fecha_ingreso_compra'),
            data.get('hora_ingreso_compra'),
            data.get('numero_acta'),
            data.get('fecha_descarga_compra'),
            data.get('hora_descarga_compra'),
            
            # Ventas
            data.get('fecha_descarga_ventas'),
            data.get('hora_descarga_ventas'),
            data.get('fecha_descarga_sistema'),
            data.get('hora_descarga_sistema'),
            
            # Resultado General
            data.get('compras_totales', 0),
            data.get('ventas_totales', 0),
            stock_existencia,
            
            # Resultado de Verificaci√≥n
            stock_fisico,
            stock_sistema,
            estado_verificacion,
            mensaje_estado,
            
            # Metadatos
            data['registrado_por'],
            data.get('observaciones', '')
        ))
        
        verificacion_id = cursor.lastrowid
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, error_de,
                registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'VERIFICACION',
            data.get('motivo', ''),
            estado_verificacion if estado_verificacion != 'CONFORME' else '',
            data['registrado_por'],
            json.dumps({
                'verificacion_id': verificacion_id,
                'stock_existencia': stock_existencia,
                'stock_fisico': stock_fisico,
                'stock_sistema': stock_sistema,
                'estado': estado_verificacion,
                'mensaje': mensaje_estado,
                'fecha_ingreso_compra': data.get('fecha_ingreso_compra'),
                'hora_ingreso_compra': data.get('hora_ingreso_compra'),
                'numero_acta': data.get('numero_acta'),
                'fecha_descarga_compra': data.get('fecha_descarga_compra'),
                'hora_descarga_compra': data.get('hora_descarga_compra'),
                'fecha_descarga_ventas': data.get('fecha_descarga_ventas'),
                'hora_descarga_ventas': data.get('hora_descarga_ventas'),
                'fecha_descarga_sistema': data.get('fecha_descarga_sistema'),
                'hora_descarga_sistema': data.get('hora_descarga_sistema'),
                'compras_totales': data.get('compras_totales', 0),
                'ventas_totales': data.get('ventas_totales', 0),
                'observaciones': data.get('observaciones', '')
            })
        ))

        # ACTUALIZAR TABLA DE COMPARACIONES PARA QUE PERSISTA EL ESTADO EN LA VISTA PRINCIPAL
        cursor.execute(f"UPDATE {tabla_comparacion} SET estado = %s WHERE id = %s", (estado_verificacion, data['comparacion_id']))
        
        conn.commit()
        
        return {
            'success': True,
            'verificacion_id': verificacion_id,
            'estado_verificacion': estado_verificacion,
            'mensaje_estado': mensaje_estado,
            'message': 'Verificaci√≥n registrada correctamente'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER EL HISTORIAL DE ACCIONES DE COMPARACION
# ============================================================
def obtener_historial_acciones(inventario_id=None, almacen=None):
    """
    Obtiene el historial completo de acciones de comparaci√≥n
    Puede filtrar por inventario_id o por almacen
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT 
                h.id,
                h.inventario_id,
                i.numero_inventario,
                h.producto_item as item,
                h.producto,
                h.codigo,
                h.almacen,
                h.tipo_accion,
                h.motivo,
                h.cantidad_afectada as cantidad,
                h.error_de,
                h.registrado_por,
                DATE_FORMAT(h.fecha_hora, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_hora,
                h.fecha_hora as fecha_hora_raw,
                h.detalles,
                -- Campos extendidos de verificaci√≥n
                v.numero_acta,
                v.fecha_ingreso_compra,
                v.hora_ingreso_compra,
                v.fecha_descarga_compra,
                v.hora_descarga_compra,
                v.fecha_descarga_ventas,
                v.hora_descarga_ventas,
                v.fecha_descarga_sistema,
                v.hora_descarga_sistema,
                v.compras_totales,
                v.ventas_totales,
                v.stock_existencia,
                v.stock_fisico,
                v.stock_sistema,
                v.estado_verificacion,
                v.observaciones as obs_verificacion
            FROM historial_acciones_comparacion h
            JOIN inventarios i ON h.inventario_id = i.id
            LEFT JOIN verificaciones v ON h.tipo_accion = 'VERIFICACION' 
                AND h.detalles LIKE CONCAT('%%"verificacion_id": ', v.id, '%%')
        """
        
        params = []
        if almacen:
            query += " WHERE h.almacen = %s"
            params.append(almacen)
        elif inventario_id:
            query += " WHERE h.inventario_id = %s"
            params.append(inventario_id)
            
        query += " ORDER BY h.fecha_hora DESC"
        
        cursor.execute(query, tuple(params))
        
        acciones = cursor.fetchall()
        
        # Convertir detalles JSON a string y mergear con campos de verificaci√≥n
        for accion in acciones:
            if accion['detalles']:
                try:
                    det = json.loads(accion['detalles'])
                    # Si es verificaci√≥n, enriquecer el objeto detalles con los campos del join
                    if accion['tipo_accion'] == 'VERIFICACION':
                        verif_fields = [
                            'numero_acta', 'fecha_ingreso_compra', 'hora_ingreso_compra',
                            'fecha_descarga_compra', 'hora_descarga_compra',
                            'fecha_descarga_ventas', 'hora_descarga_ventas',
                            'fecha_descarga_sistema', 'hora_descarga_sistema',
                            'compras_totales', 'ventas_totales', 'stock_existencia',
                            'stock_fisico', 'stock_sistema', 'estado_verificacion',
                            'obs_verificacion'
                        ]
                        for field in verif_fields:
                            if field in accion: # Check if the field exists in the fetched row (could be None from LEFT JOIN)
                                det[field] = accion[field]
                    accion['detalles'] = det
                except:
                    accion['detalles'] = str(accion['detalles'])
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'acciones': acciones,
            'total_acciones': len(acciones)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA OBTENER VERIFICACIONES DE CADA PRODUCTO
# ============================================================
def obtener_verificaciones_producto(comparacion_id, almacen):
    """
    Obtiene las verificaciones realizadas para un producto espec√≠fico
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                v.*,
                DATE_FORMAT(v.fecha_hora, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_hora_formateada,
                DATE_FORMAT(v.fecha_actualizacion, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_actualizacion_formateada
            FROM verificaciones v
            WHERE v.comparacion_id = %s AND v.almacen = %s
            ORDER BY v.fecha_hora DESC
        """, (comparacion_id, almacen))
        
        verificaciones = cursor.fetchall()
        
        return {
            'success': True,
            'comparacion_id': comparacion_id,
            'almacen': almacen,
            'verificaciones': verificaciones,
            'total_verificaciones': len(verificaciones)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE CONSOLIDADO (CALLAO - MALVINAS - GENERAL)
# =======================================================================
# ***********************************************************************

def generar_consolidado_callao(data):
    """
    Genera el consolidado de inventario para almac√©n Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Llamar al stored procedure
        cursor.callproc('sp_generar_consolidado_callao', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_consolidado_callao_1, @_sp_generar_consolidado_callao_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_consolidado_callao_1']
        mensaje = result['@_sp_generar_consolidado_callao_2']
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def generar_consolidado_malvinas(data):
    """
    Genera el consolidado de inventario para almac√©n Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Llamar al stored procedure
        cursor.callproc('sp_generar_consolidado_malvinas', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_consolidado_malvinas_1, @_sp_generar_consolidado_malvinas_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_consolidado_malvinas_1']
        mensaje = result['@_sp_generar_consolidado_malvinas_2']
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def generar_consolidado_general(data):
    """
    Genera el consolidado general que integra Callao y Malvinas
    SIN ELIMINAR registros anteriores, solo agrega nuevos o actualiza
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # 1. Obtener datos de Callao
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                unidad_medida
            FROM consolidado_inventario_callao
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        callao_data = {row['codigo']: row for row in cursor.fetchall()}
        
        # 2. Obtener datos de Malvinas
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                unidad_medida
            FROM consolidado_inventario_malvinas
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        malvinas_data = {row['codigo']: row for row in cursor.fetchall()}
        
        # 3. Obtener todos los c√≥digos √∫nicos
        todos_codigos = set(callao_data.keys()) | set(malvinas_data.keys())
        
        if not todos_codigos:
            return {
                'success': False,
                'message': 'No hay datos de consolidado para Callao o Malvinas. Genere los consolidados primero.'
            }
        
        registros_procesados = 0
        registros_actualizados = 0
        registros_nuevos = 0
        
        # 4. Procesar cada producto
        for codigo in todos_codigos:
            callao = callao_data.get(codigo, {})
            malvinas = malvinas_data.get(codigo, {})
            
            callao_sistema = callao.get('sistema', 0) if callao else 0
            callao_fisico = callao.get('fisico', 0) if callao else 0
            malvinas_sistema = malvinas.get('sistema', 0) if malvinas else 0
            malvinas_fisico = malvinas.get('fisico', 0) if malvinas else 0
            
            total_sistema = callao_sistema + malvinas_sistema
            total_fisico = callao_fisico + malvinas_fisico
            diferencia = total_fisico - total_sistema
            
            # Determinar resultado
            if total_fisico == total_sistema:
                resultado = 'CONFORME'
            elif total_fisico > total_sistema:
                resultado = 'SOBRANTE'
            else:
                resultado = 'FALTANTE'
            
            producto = callao.get('producto') if callao else malvinas.get('producto', '')
            producto_item = callao.get('producto_item') if callao else malvinas.get('producto_item')
            unidad_medida = callao.get('unidad_medida') if callao else malvinas.get('unidad_medida', '')
            
            # Verificar si ya existe en consolidado general
            cursor.execute("""
                SELECT id, total_sistema, total_fisico 
                FROM consolidado_general 
                WHERE inventario_id = %s AND codigo = %s
                ORDER BY fecha_consolidacion DESC
                LIMIT 1
            """, (inventario_id, codigo))
            
            existente = cursor.fetchone()
            
            if existente:
                # Verificar si los datos han cambiado
                if (existente['total_sistema'] != total_sistema or 
                    existente['total_fisico'] != total_fisico):
                    
                    cursor.execute("""
                        UPDATE consolidado_general
                        SET total_sistema = %s,
                            total_fisico = %s,
                            diferencia = %s,
                            resultado = %s,
                            callao_sistema = %s,
                            callao_fisico = %s,
                            malvinas_sistema = %s,
                            malvinas_fisico = %s,
                            ultima_actualizacion = CURRENT_TIMESTAMP
                        WHERE id = %s
                    """, (
                        total_sistema,
                        total_fisico,
                        diferencia,
                        resultado,
                        callao_sistema,
                        callao_fisico,
                        malvinas_sistema,
                        malvinas_fisico,
                        existente['id']
                    ))
                    registros_actualizados += 1
                else:
                    registros_procesados += 1
            else:
                # Insertar nuevo registro
                cursor.execute("""
                    INSERT INTO consolidado_general (
                        inventario_id, producto_item, producto, codigo,
                        total_sistema, total_fisico, diferencia, resultado,
                        unidad_medida, callao_sistema, callao_fisico,
                        malvinas_sistema, malvinas_fisico
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    inventario_id,
                    producto_item,
                    producto,
                    codigo,
                    total_sistema,
                    total_fisico,
                    diferencia,
                    resultado,
                    unidad_medida,
                    callao_sistema,
                    callao_fisico,
                    malvinas_sistema,
                    malvinas_fisico
                ))
                registros_nuevos += 1
        
        registros_procesados = len(todos_codigos)
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'registros_nuevos': registros_nuevos,
            'registros_actualizados': registros_actualizados,
            'message': f'Consolidado General: {registros_nuevos} nuevos, {registros_actualizados} actualizados'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
            
def generar_todos_consolidados(data):
    """
    Genera todos los consolidados (Callao, Malvinas y General) de una sola vez
    SIN ELIMINAR registros anteriores
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Generar consolidado Callao
        result_callao = generar_consolidado_callao({'inventario_id': inventario_id})
        
        # Generar consolidado Malvinas
        result_malvinas = generar_consolidado_malvinas({'inventario_id': inventario_id})
        
        # Generar consolidado General
        result_general = generar_consolidado_general({'inventario_id': inventario_id})
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'callao': {
                'success': result_callao.get('success', False),
                'nuevos': result_callao.get('registros_nuevos', 0),
                'actualizados': result_callao.get('registros_actualizados', 0),
                'message': result_callao.get('message', '')
            },
            'malvinas': {
                'success': result_malvinas.get('success', False),
                'nuevos': result_malvinas.get('registros_nuevos', 0),
                'actualizados': result_malvinas.get('registros_actualizados', 0),
                'message': result_malvinas.get('message', '')
            },
            'general': {
                'success': result_general.get('success', False),
                'nuevos': result_general.get('registros_nuevos', 0),
                'actualizados': result_general.get('registros_actualizados', 0),
                'message': result_general.get('message', '')
            },
            'message': 'Consolidados generados/actualizados correctamente'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def obtener_consolidado_callao(inventario_id=None, forzar_regenerar=False):
    """
    Obtiene el consolidado de inventario para almac√©n Callao
    
    OPTIMIZADO: Primero intenta leer de la tabla consolidado_inventario_callao.
    Solo regenera si la tabla est√° vac√≠a o si forzar_regenerar=True.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Convertir inventario_id a int si viene como string
        if inventario_id:
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                inventario_id = None

        # Si no se env√≠a inventario, buscar el activo
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo', 'consolidado': []}

        # OPTIMIZACI√ìN: Primero intentar leer directamente de la tabla
        if not forzar_regenerar:
            cursor.execute("""
                SELECT 
                    id,
                    producto_item,
                    producto,
                    codigo,
                    sistema,
                    fisico,
                    diferencia,
                    unidad_medida
                FROM consolidado_inventario_callao
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            
            datos_tabla = cursor.fetchall()
            
            if datos_tabla and len(datos_tabla) > 0:
                # Hay datos en la tabla, usarlos directamente
                consolidado = []
                total_sistema = 0
                total_fisico = 0
                diferencia_total = 0
                productos_sobrantes = 0
                productos_faltantes = 0
                productos_conformes = 0
                
                for row in datos_tabla:
                    sistema = float(row['sistema'] or 0)
                    fisico = float(row['fisico'] or 0)
                    diferencia = float(row['diferencia'] or 0)
                    
                    total_sistema += sistema
                    total_fisico += fisico
                    diferencia_total += diferencia
                    
                    if diferencia == 0 and fisico > 0:
                        productos_conformes += 1
                    elif diferencia > 0:
                        productos_sobrantes += 1
                    elif diferencia < 0:
                        productos_faltantes += 1
                    
                    consolidado.append({
                        'id': row['id'],
                        'inventario_id': inventario_id,
                        'producto_item': row['producto_item'],
                        'producto': row['producto'],
                        'codigo': row['codigo'],
                        'sistema': int(sistema),
                        'fisico': int(fisico),
                        'diferencia': int(diferencia),
                        'unidad_medida': row['unidad_medida'] or 'UND'
                    })
                
                # Resumen
                resumen = {
                    'total_productos': len(consolidado),
                    'total_sistema': int(total_sistema),
                    'total_fisico': int(total_fisico),
                    'diferencia_total': int(diferencia_total),
                    'productos_sobrantes': productos_sobrantes,
                    'productos_faltantes': productos_faltantes,
                    'productos_conformes': productos_conformes
                }
                
                # Obtener informaci√≥n del inventario
                cursor.execute("""
                    SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
                    FROM inventarios
                    WHERE id = %s
                """, (inventario_id,))
                inventario_info = cursor.fetchone()
                
                logging.info(f"obtener_consolidado_callao: Le√≠dos {len(consolidado)} productos desde tabla (optimizado)")
                
                return {
                    'success': True,
                    'inventario_id': inventario_id,
                    'inventario': inventario_info,
                    'almacen': 'Callao',
                    'consolidado': consolidado,
                    'resumen': resumen,
                    'total_registros': len(consolidado),
                    'registros_guardados': 0,
                    'registros_actualizados': 0
                }
        
        # Si llegamos aqu√≠, necesitamos regenerar (tabla vac√≠a o forzar_regenerar=True)
        logging.info(f"obtener_consolidado_callao: Regenerando consolidado para inventario_id={inventario_id}")
        
        # 1. Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        almacen_id = almacen_callao['id'] if almacen_callao else None
        
        if not almacen_id:
            return {'success': False, 'message': 'No se encontr√≥ el almac√©n Callao', 'consolidado': []}
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (igual que Comparar)
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # 3. CONSULTA MAESTRA: Unir Sistema con Comparaciones (IGUAL QUE COMPARAR)
        cursor.execute("""
            SELECT 
                ds.id as sistema_id,
                cc.id as comparacion_id,
                ds.producto_item as item,
                ds.producto,
                ds.codigo,
                COALESCE(cc.cantidad_sistema, ds.cantidad_sistema) as cantidad_sistema,
                cc.cantidad_fisica as cant_fisica_db,
                cc.resultado as resultado_db,
                cc.estado as estado_db,
                ds.unidad_medida,
                DATE_FORMAT(cc.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                pi.unidad_medida as unidad_catalogo
            FROM datos_sistema_callao ds
            LEFT JOIN comparaciones_callao cc ON ds.inventario_id = cc.inventario_id AND ds.codigo = cc.codigo
            LEFT JOIN productos_inventario pi ON ds.producto_item = pi.item
            WHERE ds.inventario_id = %s AND ds.estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            ORDER BY ds.producto
        """, (inventario_id,))
        
        datos_base = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales (IGUAL QUE COMPARAR)
        consolidado = []
        total_sistema = 0
        total_fisico = 0
        diferencia_total = 0
        productos_sobrantes = 0
        productos_faltantes = 0
        productos_conformes = 0
        
        for item in datos_base:
            codigo = str(item.get('codigo') or '').strip().upper()
            cant_sistema = float(item['cantidad_sistema'] or 0)
            
            # Cantidad f√≠sica: Prioridad 1: Conteo real en vivo
            cant_fisica_raw = conteos_fisicos.get(codigo, None)
            # Prioridad 2: Guardado en DB
            cant_fisica_db = item.get('cant_fisica_db')
            
            cant_fisica = 0.0
            tiene_conteo = False
            
            if cant_fisica_db is not None:
                cant_fisica = float(cant_fisica_db)
                tiene_conteo = True
            elif cant_fisica_raw is not None:
                cant_fisica = float(cant_fisica_raw)
                tiene_conteo = True
            
            diferencia = cant_fisica - cant_sistema
            
            # Determinar estado
            if diferencia == 0 and tiene_conteo:
                productos_conformes += 1
            elif diferencia > 0:
                productos_sobrantes += 1
            elif diferencia < 0:
                productos_faltantes += 1
            
            total_sistema += cant_sistema
            if tiene_conteo:
                total_fisico += cant_fisica
                diferencia_total += diferencia
            
            consolidado.append({
                'id': item['comparacion_id'] or item['sistema_id'],
                'inventario_id': inventario_id,
                'producto_item': item['item'],
                'producto': item['producto'],
                'codigo': item['codigo'],
                'sistema': int(cant_sistema),
                'fisico': int(cant_fisica) if tiene_conteo else 0,
                'diferencia': int(diferencia) if tiene_conteo else 0,
                'unidad_medida': item['unidad_medida'] or 'UND',
                'fecha_consolidacion_formateada': item['fecha_comparacion']
            })
        
        # 5. GUARDAR/ACTUALIZAR en tabla consolidado_inventario_callao
        registros_guardados = 0
        registros_actualizados = 0
        
        for item in consolidado:
            codigo = str(item['codigo']).strip().upper() if item.get('codigo') else ''
            if not codigo:
                continue
                
            # Verificar si ya existe
            cursor.execute("""
                SELECT id FROM consolidado_inventario_callao 
                WHERE inventario_id = %s AND codigo = %s
            """, (inventario_id, codigo))
            
            existente = cursor.fetchone()
            
            if existente:
                # Actualizar
                cursor.execute("""
                    UPDATE consolidado_inventario_callao SET
                        producto_item = %s,
                        producto = %s,
                        sistema = %s,
                        fisico = %s,
                        diferencia = %s,
                        unidad_medida = %s,
                        fecha_consolidacion = CURRENT_TIMESTAMP
                    WHERE inventario_id = %s AND codigo = %s
                """, (
                    item['producto_item'],
                    item['producto'],
                    item['sistema'],
                    item['fisico'],
                    item['diferencia'],
                    item['unidad_medida'],
                    inventario_id,
                    codigo
                ))
                registros_actualizados += 1
            else:
                # Insertar nuevo
                cursor.execute("""
                    INSERT INTO consolidado_inventario_callao (
                        inventario_id, producto_item, producto, codigo,
                        sistema, fisico, diferencia, unidad_medida
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    inventario_id,
                    item['producto_item'],
                    item['producto'],
                    codigo,
                    item['sistema'],
                    item['fisico'],
                    item['diferencia'],
                    item['unidad_medida']
                ))
                registros_guardados += 1
        
        conn.commit()
        
        # Resumen
        resumen = {
            'total_productos': len(consolidado),
            'total_sistema': int(total_sistema),
            'total_fisico': int(total_fisico),
            'diferencia_total': int(diferencia_total),
            'productos_sobrantes': productos_sobrantes,
            'productos_faltantes': productos_faltantes,
            'productos_conformes': productos_conformes
        }
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        inventario_info = cursor.fetchone()
        
        logging.info(f"obtener_consolidado_callao: Guardados {registros_guardados} nuevos, actualizados {registros_actualizados} para inventario_id={inventario_id}")
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'almacen': 'Callao',
            'consolidado': consolidado or [],
            'resumen': resumen,
            'total_registros': len(consolidado) if consolidado else 0,
            'registros_guardados': registros_guardados,
            'registros_actualizados': registros_actualizados
        }
        
    except Exception as e:
        logging.error(f"Error en consolidado Callao: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        return {'success': False, 'message': f'Error al obtener consolidado Callao: {str(e)}', 'consolidado': []}
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def obtener_consolidado_malvinas(inventario_id=None, forzar_regenerar=False):
    """
    Obtiene el consolidado de inventario para almac√©n Malvinas
    
    OPTIMIZADO: Primero intenta leer de la tabla consolidado_inventario_malvinas.
    Solo regenera si la tabla est√° vac√≠a o si forzar_regenerar=True.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Convertir inventario_id a int si viene como string
        if inventario_id:
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                inventario_id = None

        # Si no se env√≠a inventario, buscar el activo
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo', 'consolidado': []}

        # OPTIMIZACI√ìN: Primero intentar leer directamente de la tabla
        if not forzar_regenerar:
            cursor.execute("""
                SELECT 
                    id,
                    producto_item,
                    producto,
                    codigo,
                    sistema,
                    fisico,
                    diferencia,
                    unidad_medida
                FROM consolidado_inventario_malvinas
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            
            datos_tabla = cursor.fetchall()
            
            if datos_tabla and len(datos_tabla) > 0:
                # Hay datos en la tabla, usarlos directamente
                consolidado = []
                total_sistema = 0
                total_fisico = 0
                diferencia_total = 0
                productos_sobrantes = 0
                productos_faltantes = 0
                productos_conformes = 0
                
                for row in datos_tabla:
                    sistema = float(row['sistema'] or 0)
                    fisico = float(row['fisico'] or 0)
                    diferencia = float(row['diferencia'] or 0)
                    
                    total_sistema += sistema
                    total_fisico += fisico
                    diferencia_total += diferencia
                    
                    if diferencia == 0 and fisico > 0:
                        productos_conformes += 1
                    elif diferencia > 0:
                        productos_sobrantes += 1
                    elif diferencia < 0:
                        productos_faltantes += 1
                    
                    consolidado.append({
                        'id': row['id'],
                        'inventario_id': inventario_id,
                        'producto_item': row['producto_item'],
                        'producto': row['producto'],
                        'codigo': row['codigo'],
                        'sistema': int(sistema),
                        'fisico': int(fisico),
                        'diferencia': int(diferencia),
                        'unidad_medida': row['unidad_medida'] or 'UND'
                    })
                
                # Resumen
                resumen = {
                    'total_productos': len(consolidado),
                    'total_sistema': int(total_sistema),
                    'total_fisico': int(total_fisico),
                    'diferencia_total': int(diferencia_total),
                    'productos_sobrantes': productos_sobrantes,
                    'productos_faltantes': productos_faltantes,
                    'productos_conformes': productos_conformes
                }
                
                # Obtener informaci√≥n del inventario
                cursor.execute("""
                    SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
                    FROM inventarios
                    WHERE id = %s
                """, (inventario_id,))
                inventario_info = cursor.fetchone()
                
                logging.info(f"obtener_consolidado_malvinas: Le√≠dos {len(consolidado)} productos desde tabla (optimizado)")
                
                return {
                    'success': True,
                    'inventario_id': inventario_id,
                    'inventario': inventario_info,
                    'almacen': 'Malvinas',
                    'consolidado': consolidado,
                    'resumen': resumen,
                    'total_registros': len(consolidado),
                    'registros_guardados': 0,
                    'registros_actualizados': 0
                }
        
        # Si llegamos aqu√≠, necesitamos regenerar (tabla vac√≠a o forzar_regenerar=True)
        logging.info(f"obtener_consolidado_malvinas: Regenerando consolidado para inventario_id={inventario_id}")
        
        # 1. Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        almacen_id = almacen_malvinas['id'] if almacen_malvinas else None
        
        if not almacen_id:
            return {'success': False, 'message': 'No se encontr√≥ el almac√©n Malvinas', 'consolidado': []}
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (igual que Comparar)
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # 3. CONSULTA MAESTRA: Unir Sistema con Comparaciones (IGUAL QUE COMPARAR)
        cursor.execute("""
            SELECT 
                ds.id as sistema_id,
                cc.id as comparacion_id,
                ds.producto_item as item,
                ds.producto,
                ds.codigo,
                COALESCE(cc.cantidad_sistema, ds.cantidad_sistema) as cantidad_sistema,
                cc.cantidad_fisica as cant_fisica_db,
                cc.resultado as resultado_db,
                cc.estado as estado_db,
                ds.unidad_medida,
                DATE_FORMAT(cc.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                pi.unidad_medida as unidad_catalogo
            FROM datos_sistema_malvinas ds
            LEFT JOIN comparaciones_malvinas cc ON ds.inventario_id = cc.inventario_id AND ds.codigo = cc.codigo
            LEFT JOIN productos_inventario pi ON ds.producto_item = pi.item
            WHERE ds.inventario_id = %s AND ds.estado IN ('activo', 'ACTIVO', 'modificado', 'MODIFICADO')
            ORDER BY ds.producto
        """, (inventario_id,))
        
        datos_base = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales (IGUAL QUE COMPARAR)
        consolidado = []
        total_sistema = 0
        total_fisico = 0
        diferencia_total = 0
        productos_sobrantes = 0
        productos_faltantes = 0
        productos_conformes = 0
        
        for item in datos_base:
            codigo = str(item.get('codigo') or '').strip().upper()
            cant_sistema = float(item['cantidad_sistema'] or 0)
            
            # Cantidad f√≠sica: Prioridad 1: Conteo real en vivo
            cant_fisica_raw = conteos_fisicos.get(codigo, None)
            # Prioridad 2: Guardado en DB
            cant_fisica_db = item.get('cant_fisica_db')
            
            cant_fisica = 0.0
            tiene_conteo = False
            
            if cant_fisica_db is not None:
                cant_fisica = float(cant_fisica_db)
                tiene_conteo = True
            elif cant_fisica_raw is not None:
                cant_fisica = float(cant_fisica_raw)
                tiene_conteo = True
            
            diferencia = cant_fisica - cant_sistema
            
            # Determinar estado
            if diferencia == 0 and tiene_conteo:
                productos_conformes += 1
            elif diferencia > 0:
                productos_sobrantes += 1
            elif diferencia < 0:
                productos_faltantes += 1
            
            total_sistema += cant_sistema
            if tiene_conteo:
                total_fisico += cant_fisica
                diferencia_total += diferencia
            
            consolidado.append({
                'id': item['comparacion_id'] or item['sistema_id'],
                'inventario_id': inventario_id,
                'producto_item': item['item'],
                'producto': item['producto'],
                'codigo': item['codigo'],
                'sistema': int(cant_sistema),
                'fisico': int(cant_fisica) if tiene_conteo else 0,
                'diferencia': int(diferencia) if tiene_conteo else 0,
                'unidad_medida': item['unidad_medida'] or 'UND',
                'fecha_consolidacion_formateada': item['fecha_comparacion']
            })
        
        # 5. GUARDAR/ACTUALIZAR en tabla consolidado_inventario_malvinas
        registros_guardados = 0
        registros_actualizados = 0
        
        for item in consolidado:
            codigo = str(item['codigo']).strip().upper() if item.get('codigo') else ''
            if not codigo:
                continue
                
            # Verificar si ya existe
            cursor.execute("""
                SELECT id FROM consolidado_inventario_malvinas 
                WHERE inventario_id = %s AND codigo = %s
            """, (inventario_id, codigo))
            
            existente = cursor.fetchone()
            
            if existente:
                # Actualizar
                cursor.execute("""
                    UPDATE consolidado_inventario_malvinas SET
                        producto_item = %s,
                        producto = %s,
                        sistema = %s,
                        fisico = %s,
                        diferencia = %s,
                        unidad_medida = %s,
                        fecha_consolidacion = CURRENT_TIMESTAMP
                    WHERE inventario_id = %s AND codigo = %s
                """, (
                    item['producto_item'],
                    item['producto'],
                    item['sistema'],
                    item['fisico'],
                    item['diferencia'],
                    item['unidad_medida'],
                    inventario_id,
                    codigo
                ))
                registros_actualizados += 1
            else:
                # Insertar nuevo
                cursor.execute("""
                    INSERT INTO consolidado_inventario_malvinas (
                        inventario_id, producto_item, producto, codigo,
                        sistema, fisico, diferencia, unidad_medida
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    inventario_id,
                    item['producto_item'],
                    item['producto'],
                    codigo,
                    item['sistema'],
                    item['fisico'],
                    item['diferencia'],
                    item['unidad_medida']
                ))
                registros_guardados += 1
        
        conn.commit()
        
        # Actualizar autom√°ticamente consolidado_general despu√©s de guardar Malvinas
        try:
            cursor.close()
            conn.close()
            obtener_consolidado_general(inventario_id)
            logging.info(f"obtener_consolidado_malvinas: Consolidado general actualizado autom√°ticamente despu√©s de guardar Malvinas")
            # Reabrir conexi√≥n para continuar
            conn = get_connection()
            cursor = conn.cursor()
        except Exception as e:
            logging.error(f"Error al actualizar consolidado_general autom√°ticamente: {str(e)}")
            # Reabrir conexi√≥n si se cerr√≥
            try:
                conn = get_connection()
                cursor = conn.cursor()
            except:
                pass
        
        # Resumen
        resumen = {
            'total_productos': len(consolidado),
            'total_sistema': int(total_sistema),
            'total_fisico': int(total_fisico),
            'diferencia_total': int(diferencia_total),
            'productos_sobrantes': productos_sobrantes,
            'productos_faltantes': productos_faltantes,
            'productos_conformes': productos_conformes
        }
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        inventario_info = cursor.fetchone()
        
        logging.info(f"obtener_consolidado_malvinas: Guardados {registros_guardados} nuevos, actualizados {registros_actualizados} para inventario_id={inventario_id}")
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'almacen': 'Malvinas',
            'consolidado': consolidado or [],
            'resumen': resumen,
            'total_registros': len(consolidado) if consolidado else 0,
            'registros_guardados': registros_guardados,
            'registros_actualizados': registros_actualizados
        }
        
    except Exception as e:
        logging.error(f"Error en consolidado Malvinas: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        return {'success': False, 'message': f'Error al obtener consolidado Malvinas: {str(e)}', 'consolidado': []}
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def obtener_consolidado_general(inventario_id=None):
    """
    Obtiene el consolidado general que integra Callao y Malvinas
    
    Ahora se arma din√°micamente a partir de los consolidados de Callao y
    Malvinas (que ya traen TODOS los productos de cada almac√©n), sin
    depender estrictamente de la tabla `consolidado_general`. De esta forma
    el listado de "Conteo General" refleja en tiempo real la suma Callao +
    Malvinas para cada producto.
    """
    try:
        # Convertir inventario_id a int si viene como string
        if inventario_id:
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                inventario_id = None

        # Si no se especifica inventario, buscar el activo
        if not inventario_id:
            conn_tmp = get_connection()
            cursor_tmp = conn_tmp.cursor()
            cursor_tmp.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor_tmp.fetchone()
            cursor_tmp.close()
            conn_tmp.close()

            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener datos directamente desde las tablas de consolidado
        # Si las tablas est√°n vac√≠as, primero asegurar que Callao y Malvinas est√©n guardados
        conn = get_connection()
        cursor = conn.cursor()
        
        # Verificar si hay datos en las tablas
        cursor.execute("SELECT COUNT(*) as count FROM consolidado_inventario_callao WHERE inventario_id = %s", (inventario_id,))
        callao_count = cursor.fetchone()['count']
        
        cursor.execute("SELECT COUNT(*) as count FROM consolidado_inventario_malvinas WHERE inventario_id = %s", (inventario_id,))
        malvinas_count = cursor.fetchone()['count']
        
        # Si alguna tabla est√° vac√≠a, generar los consolidados primero
        if callao_count == 0 or malvinas_count == 0:
            cursor.close()
            conn.close()
            # Generar consolidados primero
            try:
                obtener_consolidado_callao(inventario_id)
                obtener_consolidado_malvinas(inventario_id)
            except Exception as e:
                logging.error(f"Error al generar consolidados antes de obtener general: {str(e)}")
            
            # Reabrir conexi√≥n
            conn = get_connection()
            cursor = conn.cursor()
        
        # 1. Obtener datos de Callao desde tabla
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                diferencia,
                unidad_medida
            FROM consolidado_inventario_callao
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        # Normalizar c√≥digos al crear los diccionarios
        def normalizar_codigo(codigo):
            return str(codigo or '').strip().upper()
        
        callao_rows = cursor.fetchall()
        callao_data = {}
        for row in callao_rows:
            codigo_norm = normalizar_codigo(row['codigo'])
            if codigo_norm:
                callao_data[codigo_norm] = row
        
        logging.info(f"obtener_consolidado_general: Callao - {len(callao_data)} productos desde tabla")
        
        # 2. Obtener datos de Malvinas desde tabla
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                diferencia,
                unidad_medida
            FROM consolidado_inventario_malvinas
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        malvinas_rows = cursor.fetchall()
        malvinas_data = {}
        for row in malvinas_rows:
            codigo_norm = normalizar_codigo(row['codigo'])
            if codigo_norm:
                malvinas_data[codigo_norm] = row
        
        logging.info(f"obtener_consolidado_general: Malvinas - {len(malvinas_data)} productos desde tabla")
        
        # 3. Obtener todos los c√≥digos √∫nicos (ya normalizados)
        todos_codigos = set(callao_data.keys()) | set(malvinas_data.keys())
        logging.info(f"obtener_consolidado_general: Total c√≥digos √∫nicos: {len(todos_codigos)}")
        
        # Mapear por c√≥digo para unir Callao + Malvinas
        productos = {}
        
        for codigo in todos_codigos:
            callao = callao_data.get(codigo) or {}
            malvinas = malvinas_data.get(codigo) or {}
            
            productos[codigo] = {
                'producto_item': callao.get('producto_item') or malvinas.get('producto_item'),
                'producto': callao.get('producto') or malvinas.get('producto', ''),
                'codigo': codigo,
                'unidad_medida': callao.get('unidad_medida') or malvinas.get('unidad_medida') or 'UND',
                'callao_sistema': int(callao.get('sistema') or 0),
                'callao_fisico': int(callao.get('fisico') or 0),
                'callao_diferencia': int(callao.get('diferencia') or 0),
                'malvinas_sistema': int(malvinas.get('sistema') or 0),
                'malvinas_fisico': int(malvinas.get('fisico') or 0),
                'malvinas_diferencia': int(malvinas.get('diferencia') or 0)
            }

        # Construir listado general
        consolidado = []
        gran_total_sistema = 0
        gran_total_fisico = 0
        diferencia_total = 0
        total_sobrantes = 0
        total_faltantes = 0
        total_conformes = 0
        total_callao_sistema = 0
        total_callao_fisico = 0
        total_malvinas_sistema = 0
        total_malvinas_fisico = 0

        # 4. Construir listado general y guardar en tabla
        consolidado = []
        gran_total_sistema = 0
        gran_total_fisico = 0
        diferencia_total = 0
        total_sobrantes = 0
        total_faltantes = 0
        total_conformes = 0
        total_callao_sistema = 0
        total_callao_fisico = 0
        total_malvinas_sistema = 0
        total_malvinas_fisico = 0
        
        idx = 1
        registros_insertados = 0
        registros_actualizados = 0
        
        for codigo, prod in productos.items():
            callao_sistema = int(prod['callao_sistema'] or 0)
            callao_fisico = int(prod['callao_fisico'] or 0)
            callao_diferencia = int(prod['callao_diferencia'] or 0)
            malvinas_sistema = int(prod['malvinas_sistema'] or 0)
            malvinas_fisico = int(prod['malvinas_fisico'] or 0)
            malvinas_diferencia = int(prod['malvinas_diferencia'] or 0)

            # SUMAR: Total Sistema = Callao Sistema + Malvinas Sistema
            total_sistema = callao_sistema + malvinas_sistema
            # SUMAR: Total F√≠sico = Callao F√≠sico + Malvinas F√≠sico
            total_fisico = callao_fisico + malvinas_fisico
            # CALCULAR: Diferencia = Total F√≠sico - Total Sistema (NO suma de diferencias)
            diferencia = total_fisico - total_sistema
            
            # Log para debugging (solo primeros 5 productos)
            if idx <= 5:
                logging.info(f"obtener_consolidado_general: Producto {idx} - Codigo={codigo}, Callao(S={callao_sistema},F={callao_fisico}), Malvinas(S={malvinas_sistema},F={malvinas_fisico}), Total(S={total_sistema},F={total_fisico},D={diferencia})")

            # Determinar resultado basado en diferencia total
            if diferencia == 0:
                resultado = 'CONFORME'
                total_conformes += 1
            elif diferencia > 0:
                resultado = 'SOBRANTE'
                total_sobrantes += 1
            else:
                resultado = 'FALTANTE'
                total_faltantes += 1

            gran_total_sistema += total_sistema
            gran_total_fisico += total_fisico
            diferencia_total += diferencia
            total_callao_sistema += callao_sistema
            total_callao_fisico += callao_fisico
            total_malvinas_sistema += malvinas_sistema
            total_malvinas_fisico += malvinas_fisico

            consolidado.append({
                'id': idx,
                'inventario_id': inventario_id,
                'producto_item': prod['producto_item'],
                'producto': prod['producto'],
                'codigo': codigo,
                'total_sistema': total_sistema,
                'total_fisico': total_fisico,
                'diferencia': diferencia,
                'resultado': resultado,
                'unidad_medida': prod['unidad_medida'],
                'callao_sistema': callao_sistema,
                'callao_fisico': callao_fisico,
                'malvinas_sistema': malvinas_sistema,
                'malvinas_fisico': malvinas_fisico
            })
            
            # Guardar en consolidado_general (INSERT o UPDATE)
            # Asegurar que el c√≥digo est√© normalizado antes de guardar
            codigo_normalizado = str(codigo).strip().upper() if codigo else ''
            
            cursor.execute("""
                SELECT id FROM consolidado_general
                WHERE inventario_id = %s AND codigo = %s
                LIMIT 1
            """, (inventario_id, codigo_normalizado))
            existente = cursor.fetchone()
            
            if existente:
                # Actualizar registro existente
                cursor.execute("""
                    UPDATE consolidado_general SET
                        producto_item = %s,
                        producto = %s,
                        total_sistema = %s,
                        total_fisico = %s,
                        diferencia = %s,
                        resultado = %s,
                        unidad_medida = %s,
                        callao_sistema = %s,
                        callao_fisico = %s,
                        malvinas_sistema = %s,
                        malvinas_fisico = %s,
                        ultima_actualizacion = CURRENT_TIMESTAMP
                    WHERE id = %s
                """, (
                    prod['producto_item'],
                    prod['producto'],
                    total_sistema,
                    total_fisico,
                    diferencia,
                    resultado,
                    prod['unidad_medida'],
                    callao_sistema,
                    callao_fisico,
                    malvinas_sistema,
                    malvinas_fisico,
                    existente['id']
                ))
                registros_actualizados += 1
                # Log para debugging (solo primeros 5 productos)
                if idx <= 5:
                    logging.info(f"obtener_consolidado_general: ACTUALIZADO registro id={existente['id']} - Codigo={codigo}, total_sistema={total_sistema}, total_fisico={total_fisico}")
            else:
                # Insertar nuevo registro
                cursor.execute("""
                    INSERT INTO consolidado_general (
                        inventario_id,
                        producto_item,
                        producto,
                        codigo,
                        total_sistema,
                        total_fisico,
                        diferencia,
                        resultado,
                        unidad_medida,
                        callao_sistema,
                        callao_fisico,
                        malvinas_sistema,
                        malvinas_fisico
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    inventario_id,
                    prod['producto_item'],
                    prod['producto'],
                    codigo_normalizado,
                    total_sistema,
                    total_fisico,
                    diferencia,
                    resultado,
                    prod['unidad_medida'],
                    callao_sistema,
                    callao_fisico,
                    malvinas_sistema,
                    malvinas_fisico
                ))
                registros_insertados += 1
                # Log para debugging (solo primeros 5 productos)
                if idx <= 5:
                    logging.info(f"obtener_consolidado_general: INSERTADO nuevo registro - Codigo={codigo}, total_sistema={total_sistema}, total_fisico={total_fisico}")
            
            idx += 1
        
        # Commit de los cambios en consolidado_general
        conn.commit()
        
        resumen = {
            'total_productos': len(consolidado),
            'gran_total_sistema': int(gran_total_sistema),
            'gran_total_fisico': int(gran_total_fisico),
            'diferencia_total': int(diferencia_total),
            'total_sobrantes': int(total_sobrantes),
            'total_faltantes': int(total_faltantes),
            'total_conformes': int(total_conformes),
            'total_callao_sistema': int(total_callao_sistema),
            'total_callao_fisico': int(total_callao_fisico),
            'total_malvinas_sistema': int(total_malvinas_sistema),
            'total_malvinas_fisico': int(total_malvinas_fisico)
        }

        # Obtener informaci√≥n b√°sica del inventario para cabecera
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        inventario_info = cursor.fetchone()
        
        logging.info(f"obtener_consolidado_general: Generado y guardado para inventario_id={inventario_id}, total productos={len(consolidado)}, insertados={registros_insertados}, actualizados={registros_actualizados} en consolidado_general")
        
        # Cerrar cursor y conexi√≥n antes de retornar
        cursor.close()
        conn.close()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'tipo': 'CONSOLIDADO_GENERAL',
            'consolidado': consolidado or [],
            'resumen': resumen,
            'total_registros': len(consolidado) if consolidado else 0
        }
        
    except Exception as e:
        logging.error(f"Error en consolidado General: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        # Asegurar que las conexiones se cierren en caso de error
        if 'cursor' in locals() and cursor:
            try:
                cursor.close()
            except:
                pass
        if 'conn' in locals() and conn:
            try:
                conn.close()
            except:
                pass
        return {'success': False, 'message': f'Error al obtener consolidado General: {str(e)}', 'consolidado': []}

def obtener_consolidados_completos(inventario_id=None):
    """
    Obtiene todos los consolidados (Callao, Malvinas y General) en una sola respuesta
    """
    try:
        # Convertir inventario_id a int si viene como string
        if inventario_id:
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                inventario_id = None
        
        if not inventario_id:
            # Intentar obtener inventario activo directamente sin stored procedure
            try:
                conn_temp = get_connection()
                cursor_temp = conn_temp.cursor()
                cursor_temp.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
                inventario = cursor_temp.fetchone()
                if inventario and inventario.get('id'):
                    inventario_id = inventario['id']
                else:
                    cursor_temp.close()
                    conn_temp.close()
                    return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
                cursor_temp.close()
                conn_temp.close()
            except Exception as e:
                logging.error(f"Error al obtener inventario activo: {str(e)}")
                import traceback
                logging.error(traceback.format_exc())
                return {'success': False, 'message': f'Error al obtener inventario activo: {str(e)}'}
        
        # Obtener cada consolidado con manejo de errores individual
        callao = None
        malvinas = None
        general = None
        
        try:
            callao = obtener_consolidado_callao(inventario_id)
            logging.info(f"obtener_consolidados_completos: Callao - success={callao.get('success') if callao else False}, items={len(callao.get('consolidado', [])) if callao else 0}")
        except Exception as e:
            logging.error(f"Error al obtener consolidado Callao: {str(e)}")
            import traceback
            logging.error(traceback.format_exc())
            callao = {'success': False, 'message': f'Error al obtener consolidado Callao: {str(e)}', 'consolidado': []}
        
        try:
            malvinas = obtener_consolidado_malvinas(inventario_id)
            logging.info(f"obtener_consolidados_completos: Malvinas - success={malvinas.get('success') if malvinas else False}, items={len(malvinas.get('consolidado', [])) if malvinas else 0}")
        except Exception as e:
            logging.error(f"Error al obtener consolidado Malvinas: {str(e)}")
            import traceback
            logging.error(traceback.format_exc())
            malvinas = {'success': False, 'message': f'Error al obtener consolidado Malvinas: {str(e)}', 'consolidado': []}
        
        try:
            general = obtener_consolidado_general(inventario_id)
            logging.info(f"obtener_consolidados_completos: General - success={general.get('success') if general else False}, items={len(general.get('consolidado', [])) if general else 0}")
        except Exception as e:
            logging.error(f"Error al obtener consolidado General: {str(e)}")
            import traceback
            logging.error(traceback.format_exc())
            general = {'success': False, 'message': f'Error al obtener consolidado General: {str(e)}', 'consolidado': []}
        
        # Incluir siempre los datos, incluso si est√°n vac√≠os o hay errores
        return {
            'success': True,
            'inventario_id': inventario_id,
            'callao': callao if callao else {'success': False, 'message': 'No se pudo obtener consolidado Callao', 'consolidado': []},
            'malvinas': malvinas if malvinas else {'success': False, 'message': 'No se pudo obtener consolidado Malvinas', 'consolidado': []},
            'general': general if general else {'success': False, 'message': 'No se pudo obtener consolidado General', 'consolidado': []}
        }
        
    except Exception as e:
        logging.error(f"Error en obtener_consolidados_completos: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        return {'success': False, 'message': f'Error al obtener consolidados: {str(e)}'}

def exportar_consolidado_excel(inventario_id=None, tipo='general'):
    """
    Exporta los consolidados a formato Excel (CSV para descarga)
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener informaci√≥n del inventario
        cursor.execute("SELECT numero_inventario FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        numero_inventario = inventario['numero_inventario'] if inventario else 'INV-' + str(inventario_id)
        
        # Determinar qu√© consolidado exportar
        if tipo == 'callao':
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    sistema as 'SISTEMA',
                    fisico as 'FISICO',
                    diferencia as 'DIFERENCIA',
                    unidad_medida as 'UNIDAD',
                    fecha_consolidacion as 'FECHA'
                FROM consolidado_inventario_callao
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_callao_{numero_inventario}.csv"
            
        elif tipo == 'malvinas':
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    sistema as 'SISTEMA',
                    fisico as 'FISICO',
                    diferencia as 'DIFERENCIA',
                    unidad_medida as 'UNIDAD',
                    fecha_consolidacion as 'FECHA'
                FROM consolidado_inventario_malvinas
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_malvinas_{numero_inventario}.csv"
            
        else:  # general
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    total_sistema as 'TOTAL SISTEMA',
                    total_fisico as 'TOTAL FISICO',
                    diferencia as 'DIFERENCIA',
                    resultado as 'RESULTADO',
                    unidad_medida as 'UNIDAD',
                    callao_sistema as 'CALLAO SISTEMA',
                    callao_fisico as 'CALLAO FISICO',
                    malvinas_sistema as 'MALVINAS SISTEMA',
                    malvinas_fisico as 'MALVINAS FISICO'
                FROM consolidado_general
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_general_{numero_inventario}.csv"
        
        if not data:
            return {'success': False, 'message': 'No hay datos para exportar'}
        
        # Convertir a DataFrame de pandas
        df = pd.DataFrame(data)
        
        # Crear archivo CSV en memoria
        csv_buffer = io.StringIO()
        df.to_csv(csv_buffer, index=False, encoding='utf-8')
        csv_content = csv_buffer.getvalue()
        
        return {
            'success': True,
            'filename': filename,
            'content': csv_content,
            'content_type': 'text/csv'
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

def verificar_consolidados_generados(inventario_id=None):
    """
    Verifica si ya se generaron los consolidados para un inventario
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Verificar Callao
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_inventario_callao 
            WHERE inventario_id = %s
        """, (inventario_id,))
        callao_count = cursor.fetchone()['count']
        
        # Verificar Malvinas
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_inventario_malvinas 
            WHERE inventario_id = %s
        """, (inventario_id,))
        malvinas_count = cursor.fetchone()['count']
        
        # Verificar General
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_general 
            WHERE inventario_id = %s
        """, (inventario_id,))
        general_count = cursor.fetchone()['count']
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'consolidados_generados': {
                'callao': callao_count > 0,
                'malvinas': malvinas_count > 0,
                'general': general_count > 0
            },
            'registros': {
                'callao': callao_count,
                'malvinas': malvinas_count,
                'general': general_count
            }
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE PROFORMAS
# =======================================================================
# ***********************************************************************


def registrar_proforma(data):
    """
    Registra una nueva proforma y aplica descuentos al f√≠sico del almac√©n correspondiente
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Validar datos requeridos
        required_fields = ['inventario_id', 'numero_proforma', 'asesor', 'almacen', 'registrado_por', 'productos']
        for field in required_fields:
            if field not in data:
                return {'success': False, 'message': f'Campo requerido: {field}'}
        
        # Validar que el almac√©n sea v√°lido
        if data['almacen'] not in ['callao', 'malvinas']:
            return {'success': False, 'message': 'Almac√©n debe ser "callao" o "malvinas"'}
        
        # Validar que hay productos
        if not data['productos'] or len(data['productos']) == 0:
            return {'success': False, 'message': 'Debe incluir al menos un producto'}
        
        # Obtener ID del almac√©n
        almacen_nombre = 'Callao' if data['almacen'] == 'callao' else 'Malvinas'
        cursor.execute("SELECT id FROM almacenes WHERE nombre = %s", (almacen_nombre,))
        almacen_row = cursor.fetchone()
        if not almacen_row:
            return {'success': False, 'message': f'Almac√©n {almacen_nombre} no encontrado'}
        almacen_id = almacen_row['id']
        
        # Validar que el inventario est√© activo
        cursor.execute("SELECT id FROM inventarios WHERE id = %s AND estado = 'activo'", (data['inventario_id'],))
        inventario_row = cursor.fetchone()
        if not inventario_row:
            return {'success': False, 'message': 'No hay un inventario activo con ese ID.'}
        
        # Validar que el n√∫mero de proforma no exista en este inventario
        cursor.execute("""
            SELECT id FROM proformas 
            WHERE numero_proforma = %s AND inventario_id = %s AND estado = 'activa'
        """, (data['numero_proforma'], data['inventario_id']))
        if cursor.fetchone():
            return {'success': False, 'message': f'El n√∫mero de proforma "{data["numero_proforma"]}" ya existe en este inventario.'}
        
        # Iniciar transacci√≥n
        conn.begin()
        
        try:
            # 1. Insertar cabecera de la proforma
            cursor.execute("""
                INSERT INTO proformas (
                    inventario_id, numero_proforma, asesor,
                    almacen, registrado_por, estado
                ) VALUES (%s, %s, %s, %s, %s, 'activa')
            """, (
                data['inventario_id'],
                data['numero_proforma'],
                data['asesor'],
                data['almacen'],
                data['registrado_por']
            ))
            
            proforma_id = cursor.lastrowid
            
            # 2. Procesar cada producto y aplicar descuentos
            for producto in data['productos']:
                codigo = str(producto.get('codigo', '')).strip().upper()
                cantidad = float(producto.get('cantidad', 0))
                unidad_medida = producto.get('unidad_medida', 'UNIDAD')
                
                if not codigo or cantidad <= 0:
                    continue
                
                # Obtener datos del cat√°logo
                cursor.execute("""
                    SELECT item, producto FROM productos_inventario WHERE codigo = %s LIMIT 1
                """, (codigo,))
                producto_catalogo = cursor.fetchone()
                producto_item = producto_catalogo['item'] if producto_catalogo else None
                producto_nombre = producto_catalogo['producto'] if producto_catalogo else codigo
                
                # Calcular f√≠sico actual del producto seg√∫n almac√©n (suma de todos los conteos finalizados)
                cursor.execute("""
                    SELECT COALESCE(SUM(dc.cantidad), 0) as total_fisico
                    FROM detalle_conteo dc
                    JOIN conteos c ON dc.conteo_id = c.id
                    JOIN productos_inventario pi ON dc.item_producto = pi.item
                    WHERE c.inventario_id = %s
                      AND c.almacen_id = %s
                      AND pi.codigo = %s
                      AND c.estado = 'finalizado'
                """, (data['inventario_id'], almacen_id, codigo))
                
                fisico_row = cursor.fetchone()
                fisico_actual = float(fisico_row['total_fisico'] if fisico_row else 0)
                fisico_nuevo = fisico_actual - cantidad
                
                # Insertar l√≠nea del detalle
                cursor.execute("""
                    INSERT INTO detalle_proformas (
                        proforma_id, producto_item, producto, codigo,
                        unidad_medida, cantidad,
                        cantidad_fisico_antes, cantidad_fisico_despues,
                        descuento_aplicado, fecha_descuento
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, TRUE, NOW())
                """, (
                    proforma_id, producto_item, producto_nombre, codigo,
                    unidad_medida, cantidad, fisico_actual, fisico_nuevo
                ))
                
                detalle_id = cursor.lastrowid
                
                # 3. Aplicar el descuento en los conteos del almac√©n correspondiente
                # Descontar de detalle_conteo donde el conteo pertenece al almac√©n y est√° finalizado
                cursor.execute("""
                    SELECT dc.id, dc.cantidad
                    FROM detalle_conteo dc
                    JOIN conteos c ON dc.conteo_id = c.id
                    JOIN productos_inventario pi ON dc.item_producto = pi.item
                    WHERE c.inventario_id = %s
                      AND c.almacen_id = %s
                      AND pi.codigo = %s
                      AND c.estado = 'finalizado'
                      AND dc.cantidad > 0
                    ORDER BY c.fecha_hora_inicio ASC
                """, (data['inventario_id'], almacen_id, codigo))
                
                detalles_conteo = cursor.fetchall()
                restante = cantidad
                conteos_afectados = []
                
                for detalle_conteo in detalles_conteo:
                    if restante <= 0:
                        break
                    
                    cantidad_conteo = float(detalle_conteo['cantidad'])
                    a_descontar = min(cantidad_conteo, restante)
                    
                    # Actualizar la cantidad en detalle_conteo
                    cursor.execute("""
                        UPDATE detalle_conteo
                        SET cantidad = cantidad - %s
                        WHERE id = %s
                    """, (a_descontar, detalle_conteo['id']))
                    
                    conteos_afectados.append({
                        'detalle_conteo_id': detalle_conteo['id'],
                        'descontado': a_descontar
                    })
                    
                    restante -= a_descontar
                
                # Registrar en historial de auditor√≠a
                cursor.execute("""
                    INSERT INTO historial_descuentos_proforma (
                        proforma_id, detalle_proforma_id, inventario_id, almacen,
                        producto_item, producto, codigo, cantidad_descontada,
                        fisico_antes, fisico_despues, conteos_afectados, numero_proforma, registrado_por
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    proforma_id, detalle_id, data['inventario_id'], data['almacen'],
                    producto_item, producto_nombre, codigo, cantidad,
                    fisico_actual, fisico_nuevo, json.dumps(conteos_afectados),
                    data['numero_proforma'], data['registrado_por']
                ))
            
            # Commit de la transacci√≥n
            conn.commit()
            
            mensaje = f'Proforma "{data["numero_proforma"]}" registrada exitosamente con {len(data["productos"])} producto(s).'
            
            logging.info(f"Proforma {proforma_id} registrada exitosamente")
            
            # Actualizar comparaciones y consolidados con los nuevos valores f√≠sicos
            try:
                # Crear nueva conexi√≥n para actualizar comparaciones
                conn_update = get_connection()
                cursor_update = conn_update.cursor()
                
                # Obtener ID del almac√©n
                almacen_nombre = 'Callao' if data['almacen'] == 'callao' else 'Malvinas'
                cursor_update.execute("SELECT id FROM almacenes WHERE nombre = %s", (almacen_nombre,))
                almacen_row = cursor_update.fetchone()
                almacen_id = almacen_row['id'] if almacen_row else None
                
                if almacen_id:
                    # Actualizar tabla de comparaci√≥n con los nuevos valores f√≠sicos desde detalle_conteo
                    tabla_comparacion = 'comparaciones_callao' if data['almacen'] == 'callao' else 'comparaciones_malvinas'
                    
                    # Para cada producto afectado, actualizar la comparaci√≥n
                    for producto in data['productos']:
                        codigo = str(producto.get('codigo', '')).strip().upper()
                        if not codigo:
                            continue
                        
                        # Calcular nuevo f√≠sico total desde detalle_conteo
                        cursor_update.execute("""
                            SELECT COALESCE(SUM(dc.cantidad), 0) as total_fisico
                            FROM detalle_conteo dc
                            JOIN conteos c ON dc.conteo_id = c.id
                            JOIN productos_inventario pi ON dc.item_producto = pi.item
                            WHERE c.inventario_id = %s
                              AND c.almacen_id = %s
                              AND pi.codigo = %s
                              AND c.estado != 'anulado'
                        """, (data['inventario_id'], almacen_id, codigo))
                        
                        fisico_row = cursor_update.fetchone()
                        nuevo_fisico = float(fisico_row['total_fisico'] if fisico_row else 0)
                        
                        # Actualizar o insertar en comparaciones
                        cursor_update.execute(f"""
                            SELECT id, cantidad_sistema FROM {tabla_comparacion}
                            WHERE inventario_id = %s AND UPPER(TRIM(codigo)) = %s
                        """, (data['inventario_id'], codigo))
                        
                        comparacion_existente = cursor_update.fetchone()
                        
                        if comparacion_existente:
                            cantidad_sistema = float(comparacion_existente['cantidad_sistema'] or 0)
                            resultado = nuevo_fisico - cantidad_sistema
                            estado = 'CONFORME' if resultado == 0 else ('SOBRANTE' if resultado > 0 else 'FALTANTE')
                            
                            cursor_update.execute(f"""
                                UPDATE {tabla_comparacion}
                                SET cantidad_fisica = %s,
                                    resultado = %s,
                                    estado = %s,
                                    ultima_actualizacion = CURRENT_TIMESTAMP
                                WHERE id = %s
                            """, (nuevo_fisico, resultado, estado, comparacion_existente['id']))
                        else:
                            # Si no existe, buscar en datos_sistema para crear
                            tabla_sistema = 'datos_sistema_callao' if data['almacen'] == 'callao' else 'datos_sistema_malvinas'
                            cursor_update.execute(f"""
                                SELECT producto_item, producto, codigo, cantidad_sistema, unidad_medida
                                FROM {tabla_sistema}
                                WHERE inventario_id = %s AND UPPER(TRIM(codigo)) = %s
                            """, (data['inventario_id'], codigo))
                            
                            dato_sistema = cursor_update.fetchone()
                            if dato_sistema:
                                cantidad_sistema = float(dato_sistema['cantidad_sistema'] or 0)
                                resultado = nuevo_fisico - cantidad_sistema
                                estado = 'CONFORME' if resultado == 0 else ('SOBRANTE' if resultado > 0 else 'FALTANTE')
                                
                                cursor_update.execute(f"""
                                    INSERT INTO {tabla_comparacion} (
                                        inventario_id, producto_item, producto, codigo,
                                        cantidad_sistema, cantidad_fisica, resultado, estado, unidad_medida
                                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                                """, (
                                    data['inventario_id'],
                                    dato_sistema['producto_item'],
                                    dato_sistema['producto'],
                                    dato_sistema['codigo'],
                                    cantidad_sistema,
                                    nuevo_fisico,
                                    resultado,
                                    estado,
                                    dato_sistema['unidad_medida'] or 'UNIDAD'
                                ))
                    
                    conn_update.commit()
                    cursor_update.close()
                    conn_update.close()
                    
                    # Regenerar completamente las tablas de comparaci√≥n para asegurar que reflejen los cambios
                    if data['almacen'] == 'callao':
                        obtener_comparacion_callao(data['inventario_id'])
                        obtener_consolidado_callao(data['inventario_id'])
                    elif data['almacen'] == 'malvinas':
                        obtener_comparacion_malvinas(data['inventario_id'])
                        obtener_consolidado_malvinas(data['inventario_id'])
                    
                    # Actualizar consolidado general siempre
                    obtener_consolidado_general(data['inventario_id'])
                    
                    logging.info(f"Comparaciones y consolidados regenerados completamente despu√©s de registrar proforma en {data['almacen']}")
            except Exception as e:
                logging.error(f"Error al recalcular comparaciones y consolidados despu√©s de proforma: {str(e)}")
                logging.error(traceback.format_exc())
            
            return {
                'success': True,
                'proforma_id': proforma_id,
                'message': mensaje
            }
            
        except Exception as e:
            conn.rollback()
            error_msg = str(e)
            error_trace = traceback.format_exc()
            logging.error(f"Error en registrar_proforma: {error_msg}")
            logging.error(f"Traceback completo: {error_trace}")
            return {'success': False, 'message': f'Error interno al registrar la proforma: {error_msg}'}
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        error_msg = str(e)
        error_trace = traceback.format_exc()
        logging.error(f"Error en registrar_proforma: {error_msg}")
        logging.error(f"Traceback completo: {error_trace}")
        return {'success': False, 'message': f'Error interno al registrar la proforma: {error_msg}'}
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def obtener_productos_para_proforma(inventario_id, almacen):
    """
    Obtiene el listado de productos disponibles para proforma con su stock f√≠sico actual
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if almacen == 'callao':
            # Obtener productos del consolidado Callao
            cursor.execute("""
                SELECT 
                    cc.producto_item as item,
                    cc.producto,
                    cc.codigo,
                    cc.fisico as stock_fisico,
                    cc.unidad_medida
                FROM consolidado_inventario_callao cc
                WHERE cc.inventario_id = %s
                ORDER BY cc.producto
            """, (inventario_id,))
        else:
            # Obtener productos del consolidado Malvinas
            cursor.execute("""
                SELECT 
                    cm.producto_item as item,
                    cm.producto,
                    cm.codigo,
                    cm.fisico as stock_fisico,
                    cm.unidad_medida
                FROM consolidado_inventario_malvinas cm
                WHERE cm.inventario_id = %s
                ORDER BY cm.producto
            """, (inventario_id,))
        
        productos = cursor.fetchall()
        
        # Filtrar solo productos con stock > 0
        productos_disponibles = [p for p in productos if p['stock_fisico'] > 0]
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': almacen,
            'productos': productos_disponibles,
            'total_productos': len(productos_disponibles)
        }
        
    except Exception as e:
        logging.error(f"Error en obtener_productos_para_proforma: {str(e)}")
        return {'success': False, 'message': f'Error al obtener productos: {str(e)}'}
    finally:
        cursor.close()
        conn.close()

def listar_proformas(inventario_id=None):
    """
    Lista todas las proformas de un inventario
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Consultar directamente desde la tabla proformas
        cursor.execute("""
            SELECT 
                p.id,
                p.inventario_id,
                i.numero_inventario,
                p.numero_proforma,
                p.asesor,
                p.almacen,
                p.registrado_por,
                p.fecha_hora_registro,
                DATE_FORMAT(p.fecha_hora_registro, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_formateada,
                p.archivo_pdf,
                p.estado,
                (SELECT COUNT(*) FROM detalle_proformas dp WHERE dp.proforma_id = p.id) as total_productos
            FROM proformas p
            JOIN inventarios i ON p.inventario_id = i.id
            WHERE p.inventario_id = %s
            ORDER BY p.fecha_hora_registro DESC
        """, (inventario_id,))
        
        proformas = cursor.fetchall()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'proformas': proformas,
            'total_proformas': len(proformas)
        }
        
    except Exception as e:
        logging.error(f"Error en listar_proformas: {str(e)}")
        return {'success': False, 'message': f'Error al listar proformas: {str(e)}'}
    finally:
        cursor.close()
        conn.close()

def obtener_detalle_proforma(proforma_id):
    """
    Obtiene el detalle completo de una proforma espec√≠fica
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener cabecera
        cursor.execute("""
            SELECT 
                p.*,
                i.numero_inventario,
                i.area,
                i.autorizado_por,
                DATE_FORMAT(p.fecha_hora_registro, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_formateada
            FROM proformas p
            JOIN inventarios i ON p.inventario_id = i.id
            WHERE p.id = %s
        """, (proforma_id,))
        
        proforma = cursor.fetchone()
        
        if not proforma:
            return {'success': False, 'message': 'Proforma no encontrada'}
        
        # Obtener detalle de productos
        cursor.execute("""
            SELECT 
                dp.*,
                pi.producto as producto_catalogo,
                pi.unidad_medida as unidad_catalogo,
                CASE 
                    WHEN dp.descuento_aplicado = 1 THEN 'Aplicado'
                    ELSE 'Pendiente'
                END as estado_descuento,
                DATE_FORMAT(dp.fecha_descuento, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_descuento_formateada
            FROM detalle_proformas dp
            LEFT JOIN productos_inventario pi ON dp.producto_item = pi.item
            WHERE dp.proforma_id = %s
            ORDER BY dp.id
        """, (proforma_id,))
        
        detalle = cursor.fetchall()
        
        # Obtener historial de descuentos
        cursor.execute("""
            SELECT 
                h.*,
                DATE_FORMAT(h.fecha_hora, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_formateada
            FROM historial_descuentos_proforma h
            WHERE h.proforma_id = %s
            ORDER BY h.fecha_hora
        """, (proforma_id,))
        
        historial = cursor.fetchall()
        
        return {
            'success': True,
            'proforma': proforma,
            'detalle': detalle,
            'historial_descuentos': historial,
            'total_productos': len(detalle)
        }
        
    except Exception as e:
        logging.error(f"Error en obtener_detalle_proforma: {str(e)}")
        return {'success': False, 'message': f'Error al obtener detalle: {str(e)}'}
    finally:
        cursor.close()
        conn.close()

def verificar_disponibilidad_productos(data):
    """
    Verifica si hay stock suficiente para los productos antes de registrar la proforma
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        almacen = data['almacen']
        productos = data['productos']
        
        resultados = []
        hay_stock_suficiente = True
        
        for producto in productos:
            codigo = producto['codigo']
            cantidad_solicitada = producto['cantidad']
            
            if almacen == 'callao':
                cursor.execute("""
                    SELECT 
                        cc.fisico as stock_fisico,
                        cc.producto,
                        cc.unidad_medida
                    FROM consolidado_inventario_callao cc
                    WHERE cc.inventario_id = %s AND cc.codigo = %s
                """, (inventario_id, codigo))
            else:
                cursor.execute("""
                    SELECT 
                        cm.fisico as stock_fisico,
                        cm.producto,
                        cm.unidad_medida
                    FROM consolidado_inventario_malvinas cm
                    WHERE cm.inventario_id = %s AND cm.codigo = %s
                """, (inventario_id, codigo))
            
            stock = cursor.fetchone()
            
            if not stock:
                resultados.append({
                    'codigo': codigo,
                    'producto': producto.get('producto', 'Desconocido'),
                    'stock_fisico': 0,
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': False,
                    'mensaje': 'Producto no encontrado en el consolidado'
                })
                hay_stock_suficiente = False
            elif stock['stock_fisico'] < cantidad_solicitada:
                resultados.append({
                    'codigo': codigo,
                    'producto': stock['producto'],
                    'stock_fisico': stock['stock_fisico'],
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': False,
                    'mensaje': f'Stock insuficiente. Disponible: {stock["stock_fisico"]} {stock["unidad_medida"]}'
                })
                hay_stock_suficiente = False
            else:
                resultados.append({
                    'codigo': codigo,
                    'producto': stock['producto'],
                    'stock_fisico': stock['stock_fisico'],
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': True,
                    'mensaje': 'Stock disponible'
                })
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': almacen,
            'hay_stock_suficiente': hay_stock_suficiente,
            'verificacion': resultados
        }
        
    except Exception as e:
        logging.error(f"Error en verificar_disponibilidad_productos: {str(e)}")
        return {'success': False, 'message': f'Error al verificar disponibilidad: {str(e)}'}
    finally:
        cursor.close()
        conn.close()

def verificar_disponibilidad_productos(data):
    """
    Verifica si hay stock suficiente para los productos antes de registrar la proforma
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        almacen = data['almacen']
        productos = data['productos']
        
        resultados = []
        hay_stock_suficiente = True
        
        for producto in productos:
            codigo = producto['codigo']
            cantidad_solicitada = producto['cantidad']
            
            if almacen == 'callao':
                cursor.execute("""
                    SELECT 
                        cc.fisico as stock_fisico,
                        cc.producto,
                        cc.unidad_medida
                    FROM consolidado_inventario_callao cc
                    WHERE cc.inventario_id = %s AND cc.codigo = %s
                """, (inventario_id, codigo))
            else:
                cursor.execute("""
                    SELECT 
                        cm.fisico as stock_fisico,
                        cm.producto,
                        cm.unidad_medida
                    FROM consolidado_inventario_malvinas cm
                    WHERE cm.inventario_id = %s AND cm.codigo = %s
                """, (inventario_id, codigo))
            
            stock = cursor.fetchone()
            
            if not stock:
                resultados.append({
                    'codigo': codigo,
                    'producto': producto.get('producto', 'Desconocido'),
                    'stock_fisico': 0,
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': False,
                    'mensaje': 'Producto no encontrado en el consolidado'
                })
                hay_stock_suficiente = False
            elif stock['stock_fisico'] < cantidad_solicitada:
                resultados.append({
                    'codigo': codigo,
                    'producto': stock['producto'],
                    'stock_fisico': stock['stock_fisico'],
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': False,
                    'mensaje': f'Stock insuficiente. Disponible: {stock["stock_fisico"]} {stock["unidad_medida"]}'
                })
                hay_stock_suficiente = False
            else:
                resultados.append({
                    'codigo': codigo,
                    'producto': stock['producto'],
                    'stock_fisico': stock['stock_fisico'],
                    'cantidad_solicitada': cantidad_solicitada,
                    'disponible': True,
                    'mensaje': 'Stock disponible'
                })
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': almacen,
            'hay_stock_suficiente': hay_stock_suficiente,
            'verificacion': resultados
        }
        
    except Exception as e:
        logging.error(f"Error en verificar_disponibilidad_productos: {str(e)}")
        return {'success': False, 'message': f'Error al verificar disponibilidad: {str(e)}'}
    finally:
        cursor.close()
        conn.close()
        
def actualizar_estado_proforma(data):
    """
    Actualiza el estado de una proforma (PROFORMA INGRESADA, TIENE COMPROBANTE)
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        proforma_id = data['proforma_id']
        nuevo_estado = data['estado']
        observaciones = data.get('observaciones', '')
        
        # Validar que el estado sea v√°lido
        estados_validos = ['PROFORMA INGRESADA', 'TIENE COMPROBANTE']
        if nuevo_estado not in estados_validos:
            return {'success': False, 'message': f'Estado no v√°lido. Debe ser: {", ".join(estados_validos)}'}
        
        cursor.execute("""
            UPDATE proformas
            SET estado = %s,
                observaciones = CONCAT(IFNULL(observaciones, ''), '\n', %s)
            WHERE id = %s
        """, (nuevo_estado, f'[{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}] Estado cambiado a {nuevo_estado}: {observaciones}', proforma_id))
        
        conn.commit()
        
        return {
            'success': True,
            'proforma_id': proforma_id,
            'estado': nuevo_estado,
            'message': f'Estado de proforma actualizado a: {nuevo_estado}'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        logging.error(f"Error en actualizar_estado_proforma: {str(e)}")
        return {'success': False, 'message': f'Error al actualizar estado: {str(e)}'}
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
 
# ============================================================
# FUNCI√ìN PRINCIPAL
# ============================================================
@functions_framework.http
def inventario_general_logistica(request):
    headers = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type"
    }

    if request.method == "OPTIONS":
        return ("", 200, headers)

    # Identificar el m√©todo HTTP actual
    method = request.method

    # Variable para guardar la respuesta temporalmente
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener acci√≥n y datos
        # IMPORTANTE: No llamar get_json() si es multipart/form-data (archivos)
        # porque consume el stream y luego request.files queda vac√≠o
        content_type = request.content_type or ''
        is_multipart = 'multipart/form-data' in content_type
        
        if is_multipart:
            # Para multipart, solo usar form y args
            request_json = {}
            action = request.args.get('action') or request.form.get('action')
        else:
            # Para JSON, obtener el JSON
            request_json = request.get_json(silent=True) or {}
            action = request.args.get('action') or request_json.get('action') or request.form.get('action')
        
        response_data = {'success': False, 'message': f'Acci√≥n "{action}" no reconocida'}

        # --- Enrutador de Acciones con Validaci√≥n de M√©todos ---
        # =========================================================================
        # ACCIONES PARA M√ìDULO DE CONTEO (CAJAS/STANDS - TIENDAS) CALLAO Y MALVINAS 
        # =========================================================================
        # ASIGNAR INVENTARIO (POST)
        if action == 'asignar_inventario' and method == 'POST':
            response_data = asignar_inventario(request_json)
            
        # UNIR COLABORADOR (POST)
        elif action == 'unir_colaborador' and method == 'POST':
            response_data = unir_colaborador_inventario(request_json)

        # ACTUALIZAR UBICACI√ìN DEL COLABORADOR (POST)
        elif action == 'actualizar_ubicacion' and method == 'POST':
            response_data = actualizar_ubicacion_colaborador(
                request_json.get('nombre_colaborador'),
                request_json.get('inventario_id'),
                request_json.get('conteo_id') # Puede ser None si sale de la tienda
            )

        # OBTENER PRESENCIA DE COLABORADORES (GET)
        elif action == 'obtener_presencia' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if not inventario_id:
                # Intento obtener el activo si no env√≠an ID
                activo = obtener_inventario_activo()
                inventario_id = activo['inventario']['id'] if activo['success'] else None
            
            if inventario_id:
                response_data = obtener_presencia_colaboradores(inventario_id)
            else:
                response_data = {'success': False, 'message': 'Falta inventario_id'}    
            
        # INICIAR CONTEO (POST)
        elif action == 'iniciar_conteo' and method == 'POST':
            response_data = iniciar_conteo(request_json)
            
        # CARGAR EXCEL EMERGENCIA (POST con archivo)
        elif action == 'cargar_excel_emergencia' and method == 'POST':
            response_data = cargar_excel_emergencia(request)
            
        # OBTENER DETALLE DE CONTEO (GET)
        elif action == 'obtener_detalle_conteo' and method == 'GET':
            conteo_id = request.args.get('conteo_id')
            response_data = obtener_detalle_conteo(conteo_id)
            
        # DIAGN√ìSTICO DE CANTIDADES (GET) - Para debugging
        elif action == 'diagnosticar_cantidades' and method == 'GET':
            conteo_id = request.args.get('conteo_id')
            if not conteo_id:
                response_data = {'success': False, 'message': 'Falta par√°metro conteo_id'}
            else:
                try:
                    conteo_id = int(conteo_id)
                    response_data = diagnosticar_cantidades_conteo(conteo_id)
                except (ValueError, TypeError):
                    response_data = {'success': False, 'message': 'conteo_id inv√°lido'}
            
        # LISTAR CONTEOS INICIADOS (EN PROCESO) (GET)
        elif action == 'listar_conteos_iniciados' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = listar_conteos_iniciados(inventario_id)
            
        # ACTUALIZAR CANTIDAD INDIVIDUAL (POST)
        elif action == 'actualizar_cantidad_individual' and method == 'POST':
            # Log para debugging: ver qu√© datos est√°n llegando
            logging.info(f"[ROUTER] actualizar_cantidad_individual recibido. Datos: {request_json}")
            response_data = actualizar_cantidad_producto_individual(request_json)
            logging.info(f"[ROUTER] actualizar_cantidad_individual respuesta: {response_data}")
            
        # ACTUALIZACI√ìN MASIVA (POST) - FUNCI√ìN SOLICITADA
        elif action == 'actualizar_masivo' and method == 'POST':
            # Log para debugging: ver qu√© datos est√°n llegando
            logging.info(f"[ROUTER] actualizar_masivo recibido. Conteo ID: {request_json.get('conteo_id')}, Productos: {len(request_json.get('productos', []))}")
            response_data = actualizar_masivo_productos(request_json)
            logging.info(f"[ROUTER] actualizar_masivo respuesta: success={response_data.get('success')}, registros={response_data.get('registros_actualizados', 0)}")
            
        # FINALIZAR CONTEO (POST)
        elif action == 'finalizar_conteo' and method == 'POST':
            response_data = finalizar_conteo(request_json)
            
        # CERRAR INVENTARIO ACTIVO (POST)
        elif action == 'cerrar_inventario' and method == 'POST':
            response_data = cerrar_inventario(request_json)
            
        # LISTAR INVENTARIOS (GET) - Todos o solo activos
        elif action == 'listar_inventarios' and method == 'GET':
            solo_activos = request.args.get('solo_activos', 'false').lower() == 'true'
            response_data = listar_inventarios(filtrar_activos=solo_activos)
            
        # OBTENER INVENTARIO ACTIVO (GET)
        elif action == 'obtener_inventario_activo' and method == 'GET':
            response_data = obtener_inventario_activo()
            
        # LISTAR CONTEO CALLAO (GET) - FUNCI√ìN SOLICITADA
        elif action == 'listar_conteos_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = listar_conteos_callao(inventario_id)
            else:
                # Si no se especifica inventario, buscar el activo
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = listar_conteos_callao(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # LISTAR CONTEO MALVINAS (GET) - FUNCI√ìN SOLICITADA
        # OBTENER ESTADO DE CONTEOS POR TIENDA (GET) - Para frontend
        elif action == 'obtener_estado_conteos_tiendas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            almacen_id = request.args.get('almacen_id')
            
            if not inventario_id or not almacen_id:
                response_data = {
                    'success': False,
                    'message': 'Faltan par√°metros: inventario_id y almacen_id son requeridos'
                }
            else:
                try:
                    inventario_id = int(inventario_id)
                    almacen_id = int(almacen_id)
                    response_data = obtener_estado_conteos_tiendas(inventario_id, almacen_id)
                except (ValueError, TypeError):
                    response_data = {
                        'success': False,
                        'message': 'inventario_id y almacen_id deben ser n√∫meros v√°lidos'
                    }
                    
        elif action == 'listar_conteos_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = listar_conteos_malvinas(inventario_id)
            else:
                # Si no se especifica inventario, buscar el activo
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = listar_conteos_malvinas(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER HISTORIAL DE CONTEOS CALLAO (GET) - TODOS LOS USUARIOS
        elif action == 'obtener_historial_conteos_callao' and method == 'GET':
            try:
                page = int(request.args.get('page', 1))
                per_page = int(request.args.get('per_page', 10))
                response_data = obtener_historial_conteos_callao(page, per_page)
            except (ValueError, TypeError):
                response_data = {
                    'success': False,
                    'message': 'page y per_page deben ser n√∫meros v√°lidos'
                }
                    
        # OBTENER HISTORIAL DE CONTEOS MALVINAS (GET) - TODOS LOS USUARIOS
        elif action == 'obtener_historial_conteos_malvinas' and method == 'GET':
            try:
                page = int(request.args.get('page', 1))
                per_page = int(request.args.get('per_page', 10))
                response_data = obtener_historial_conteos_malvinas(page, per_page)
            except (ValueError, TypeError):
                response_data = {
                    'success': False,
                    'message': 'page y per_page deben ser n√∫meros v√°lidos'
                }
                    
        # LISTAR PRODUCTOS DEL CATALOGO (GET)
        elif action == 'listar_productos_inventario' and method == 'GET':
            response_data = listar_productos_inventario()

        # ======================================================
        # ACCIONES PARA M√ìDULO DE COMPARACI√ìN
        # ======================================================
        
        # CARGAR SISTEMA CALLAO (POST con archivo)
        elif action == 'cargar_sistema_callao' and method == 'POST':
            response_data = cargar_sistema_callao(request)
            
        # CARGAR SISTEMA MALVINAS (POST con archivo)
        elif action == 'cargar_sistema_malvinas' and method == 'POST':
            response_data = cargar_sistema_malvinas(request)
            
        # GENERAR COMPARACI√ìN CALLAO (POST)
        elif action == 'generar_comparacion_callao' and method == 'POST':
            response_data = generar_comparacion_callao(request_json)
            
        # GENERAR COMPARACI√ìN MALVINAS (POST)
        elif action == 'generar_comparacion_malvinas' and method == 'POST':
            response_data = generar_comparacion_malvinas(request_json)
            
        # OBTENER COMPARACI√ìN CALLAO (GET)
        elif action == 'obtener_comparacion_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = obtener_comparacion_callao(inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_comparacion_callao(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER COMPARACI√ìN MALVINAS (GET)
        elif action == 'obtener_comparacion_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = obtener_comparacion_malvinas(inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_comparacion_malvinas(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # EDITAR CANTIDAD F√çSICA (POST)
        elif action == 'editar_cantidad_fisica' and method == 'POST':
            response_data = editar_cantidad_fisica(request_json)
            
        # EDITAR CANTIDAD SISTEMA (POST)
        elif action == 'editar_cantidad_sistema' and method == 'POST':
            response_data = editar_cantidad_sistema(request_json)
            
        # REGISTRAR VERIFICACI√ìN (POST)
        elif action == 'registrar_verificacion' and method == 'POST':
            response_data = registrar_verificacion(request_json)
            
        # OBTENER HISTORIAL DE ACCIONES (GET)
        elif action == 'obtener_historial_acciones' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            almacen = request.args.get('almacen')
            if almacen:
                response_data = obtener_historial_acciones(almacen=almacen)
            elif inventario_id:
                response_data = obtener_historial_acciones(inventario_id=inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_historial_acciones(inventario_id=inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER VERIFICACIONES PRODUCTO (GET)
        elif action == 'obtener_verificaciones_producto' and method == 'GET':
            comparacion_id = request.args.get('comparacion_id')
            almacen = request.args.get('almacen')
            if comparacion_id and almacen:
                response_data = obtener_verificaciones_producto(comparacion_id, almacen)
            else:
                response_data = {'success': False, 'message': 'Se requiere comparacion_id y almacen'}

        # ======================================================
        # ACCIONES PARA M√ìDULO DE CONSOLIDADO 
        # ======================================================
        
        # GENERAR CONSOLIDADO CALLAO (POST)
        elif action == 'generar_consolidado_callao' and method == 'POST':
            response_data = generar_consolidado_callao(request_json)
            
        # GENERAR CONSOLIDADO MALVINAS (POST)
        elif action == 'generar_consolidado_malvinas' and method == 'POST':
            response_data = generar_consolidado_malvinas(request_json)
            
        # GENERAR CONSOLIDADO GENERAL (POST)
        elif action == 'generar_consolidado_general' and method == 'POST':
            response_data = generar_consolidado_general(request_json)
            
        # GENERAR TODOS LOS CONSOLIDADOS (POST)
        elif action == 'generar_todos_consolidados' and method == 'POST':
            response_data = generar_todos_consolidados(request_json)
            
        # OBTENER CONSOLIDADO CALLAO (GET)
        elif action == 'obtener_consolidado_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                try:
                    inventario_id = int(inventario_id)
                except (ValueError, TypeError):
                    inventario_id = None
            response_data = obtener_consolidado_callao(inventario_id)
            
        # OBTENER CONSOLIDADO MALVINAS (GET)
        elif action == 'obtener_consolidado_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                try:
                    inventario_id = int(inventario_id)
                except (ValueError, TypeError):
                    inventario_id = None
            response_data = obtener_consolidado_malvinas(inventario_id)
            
        # OBTENER CONSOLIDADO GENERAL (GET)
        elif action == 'obtener_consolidado_general' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                try:
                    inventario_id = int(inventario_id)
                except (ValueError, TypeError):
                    inventario_id = None
            response_data = obtener_consolidado_general(inventario_id)
            
        # OBTENER CONSOLIDADOS COMPLETOS (GET)
        elif action == 'obtener_consolidados_completos' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            # Convertir a int si viene como string
            if inventario_id:
                try:
                    inventario_id = int(inventario_id)
                except (ValueError, TypeError):
                    inventario_id = None
            response_data = obtener_consolidados_completos(inventario_id)
            
        # EXPORTAR CONSOLIDADO EXCEL (GET)
        elif action == 'exportar_consolidado_excel' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            tipo = request.args.get('tipo', 'general')
            response_data = exportar_consolidado_excel(inventario_id, tipo)
            
        # VERIFICAR CONSOLIDADOS GENERADOS (GET)
        elif action == 'verificar_consolidados' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = verificar_consolidados_generados(inventario_id)
        
        # ======================================================
        # ACCIONES PARA M√ìDULO DE PROFORMAS 
        # ======================================================
        
        # REGISTRAR PROFORMA (POST)
        elif action == 'registrar_proforma' and method == 'POST':
            response_data = registrar_proforma(request_json)
            
        # OBTENER PRODUCTOS PARA PROFORMA (GET)
        elif action == 'obtener_productos_proforma' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            almacen = request.args.get('almacen')
            
            if not inventario_id:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                else:
                    response_data = inventario_activo
            
            if inventario_id and almacen:
                response_data = obtener_productos_para_proforma(inventario_id, almacen)
            else:
                response_data = {'success': False, 'message': 'Se requiere inventario_id y almac√©n'}
            
        # LISTAR PROFORMAS (GET)
        elif action == 'listar_proformas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if not inventario_id:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = listar_proformas(inventario_id)
                else:
                    response_data = inventario_activo
            else:
                response_data = listar_proformas(inventario_id)
            
        # OBTENER DETALLE PROFORMA (GET)
        elif action == 'obtener_detalle_proforma' and method == 'GET':
            proforma_id = request.args.get('proforma_id')
            if proforma_id:
                try:
                    proforma_id = int(proforma_id)
                    response_data = obtener_detalle_proforma(proforma_id)
                except (ValueError, TypeError):
                    response_data = {'success': False, 'message': 'proforma_id debe ser un n√∫mero v√°lido'}
            else:
                response_data = {'success': False, 'message': 'Se requiere proforma_id'}
            
        # VERIFICAR DISPONIBILIDAD PRODUCTOS (POST)
        elif action == 'verificar_disponibilidad' and method == 'POST':
            response_data = verificar_disponibilidad_productos(request_json)
            
        # ACTUALIZAR ESTADO PROFORMA (POST)
        elif action == 'actualizar_estado_proforma' and method == 'POST':
            response_data = actualizar_estado_proforma(request_json)

        return (json.dumps(response_data, default=str), 200, headers)
        
    except Exception as e:
        if 'conn' in locals() and conn.open: 
            conn.rollback()
        import traceback
        error_trace = traceback.format_exc()
        logging.error(f"Error en inventario: {str(e)}")
        logging.error(f"Traceback completo: {error_trace}")
        return (json.dumps({'success': False, 'error': str(e), 'traceback': error_trace}), 500, headers)
    finally:
        if 'cursor' in locals(): 
            cursor.close()
        if 'conn' in locals(): 
            conn.close()