import functions_framework
import pymysql
import json
import requests
import logging
import io
import os
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseUpload
from google.cloud import storage
import pandas as pd 
from datetime import datetime

# üîß Conexi√≥n a MySQL
def get_connection():
    return pymysql.connect(
        user="zeussafety-2024",
        password="ZeusSafety2025",
        db="Zeus_Safety_Data_Integration",
        unix_socket="/cloudsql/stable-smithy-435414-m6:us-central1:zeussafety-2024",
        cursorclass=pymysql.cursors.DictCursor
    )

## Funci√≥n de Subida a Cloud Storage (LOCAL STORAGE)
# Variables globales para el cliente y el bucket de GCS
storage_client = storage.Client()
BUCKET_NAME = "archivos_sistema"
GCS_FOLDER = "incidencias_areas_zeus"

def upload_to_gcs(file):
    """
    Sube un archivo a Google Cloud Storage y devuelve la URL p√∫blica.
    Args: file: El objeto de archivo multipart/form-data.
    Returns: La URL del archivo subido o None si hay un error.
    """
    try:
        bucket = storage_client.bucket(BUCKET_NAME)
        # La ruta del archivo en el bucket
        object_name = f"{GCS_FOLDER}/{file.filename}"
        blob = bucket.blob(object_name)

        # Sube el archivo directamente
        blob.upload_from_file(file, content_type=file.content_type)
        
        # Genera la URL p√∫blica
        gcs_url = f"https://storage.googleapis.com/{BUCKET_NAME}/{object_name}"
        return gcs_url
    except Exception as e:
        print(f"Error al subir a Cloud Storage: {e}")
        return None
    
# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE CONTEO MALVINAS / CALLAO
# =======================================================================
# ***********************************************************************

# ============================================================
# FUNCION ASIGNAR INVENTARIO
# ============================================================
def asignar_inventario(data):
    """
    Asigna un nuevo inventario
    """
    try:
        # Validar que lleguen los campos m√≠nimos requeridos
        # Verificar que los campos existan y no est√©n vac√≠os
        required_fields = ['numero_inventario', 'contrasena', 'area', 'autorizado_por']
        missing_fields = []
        
        for field in required_fields:
            value = data.get(field)
            # Verificar que el campo exista y no est√© vac√≠o (None, '', o solo espacios)
            if not value or (isinstance(value, str) and not value.strip()):
                missing_fields.append(field)
        
        if missing_fields:
            return {
                'success': False,
                'message': f'Faltan campos obligatorios: {", ".join(missing_fields)}'
            }

        conn = get_connection()
        cursor = conn.cursor()
        
        # Llamar al stored procedure
        cursor.callproc('sp_asignar_inventario', [
            data['numero_inventario'],
            data['contrasena'],
            data['area'],
            data['autorizado_por'],
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        # Obtener resultados
        cursor.execute('SELECT @_sp_asignar_inventario_4, @_sp_asignar_inventario_5')
        result = cursor.fetchone()
        
        conn.commit()
        
        if result['@_sp_asignar_inventario_4'] > 0:
            return {
                'success': True,
                'inventario_id': result['@_sp_asignar_inventario_4'],
                'message': result['@_sp_asignar_inventario_5']
            }
        else:
            return {
                'success': False,
                'message': result['@_sp_asignar_inventario_5']
            }
            
    except Exception as e:
        # Devolver el error de forma controlada para que el frontend pueda verlo
        logging.error(f"Error en asignar_inventario: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al asignar inventario',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION UNIRSE AL INVENTARIO
# ============================================================
def unir_colaborador_inventario(data):
    """
    Une un colaborador a un inventario activo
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.callproc('sp_unir_colaborador_inventario', [
            data['numero_inventario'],
            data['nombre_colaborador'],
            data.get('rol', 'contador'),
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_unir_colaborador_inventario_3, @_sp_unir_colaborador_inventario_4')
        result = cursor.fetchone()
        
        conn.commit()
        
        if result['@_sp_unir_colaborador_inventario_3'] > 0:
            return {
                'success': True,
                'colaborador_id': result['@_sp_unir_colaborador_inventario_3'],
                'message': result['@_sp_unir_colaborador_inventario_4']
            }
        else:
            return {
                'success': False,
                'message': result['@_sp_unir_colaborador_inventario_4']
            }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION INICIAR CONTEO
# ============================================================
def iniciar_conteo(data):
    """
    Inicia un conteo (por cajas o por stand)
    """
    try:
        # Validar campos requeridos
        required_fields = ['numero_inventario', 'almacen_id', 'registrado_por', 'tipo_conteo']
        missing_fields = []
        
        for field in required_fields:
            value = data.get(field)
            # Verificar que el campo exista y no est√© vac√≠o (None, '', o solo espacios)
            if not value or (isinstance(value, str) and not value.strip()):
                missing_fields.append(field)
        
        if missing_fields:
            return {
                'success': False,
                'message': f'Faltan campos obligatorios: {", ".join(missing_fields)}'
            }

        conn = get_connection()
        cursor = conn.cursor()
        
        # Convertir tienda_id a None si viene vac√≠o
        tienda_id = data.get('tienda_id')
        if tienda_id == '' or tienda_id == 'null' or tienda_id is None:
            tienda_id = None
        else:
            try:
                tienda_id = int(tienda_id)
            except (ValueError, TypeError):
                tienda_id = None
        
        # Obtener inventario_id desde numero_inventario
        cursor.execute("SELECT id FROM inventarios WHERE numero_inventario = %s", (data['numero_inventario'],))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {
                'success': False,
                'message': f'No se encontr√≥ el inventario con n√∫mero: {data["numero_inventario"]}'
            }
        
        inventario_id = inventario['id']
        
        # VALIDACI√ìN: Verificar si ya existe un conteo del mismo tipo para este inventario, almac√©n y tienda
        # IMPORTANTE: La validaci√≥n debe ser espec√≠fica por tipo_conteo (por_cajas o por_stand)
        # Esto permite: 1 conteo por_cajas + 1 conteo por_stand por cada tienda
        # Solo considerar conteos que NO est√©n anulados (en_proceso o finalizado)
        
        logging.info(f"[iniciar_conteo] Validando conteo duplicado: inventario_id={inventario_id}, almacen_id={data['almacen_id']}, tienda_id={tienda_id}, tipo_conteo={data['tipo_conteo']}")
        
        if tienda_id is None:
            cursor.execute("""
                SELECT 
                    c.id,
                    c.estado,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%d/%%m/%%Y %%H:%%i') as fecha_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%d/%%m/%%Y %%H:%%i') as fecha_final
                FROM conteos c
                WHERE c.inventario_id = %s
                    AND c.almacen_id = %s
                    AND c.tienda_id IS NULL
                    AND c.tipo_conteo = %s
                    AND c.estado != 'anulado'
                ORDER BY c.id DESC
                LIMIT 1
            """, (inventario_id, data['almacen_id'], data['tipo_conteo']))
        else:
            cursor.execute("""
                SELECT 
                    c.id,
                    c.estado,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%d/%%m/%%Y %%H:%%i') as fecha_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%d/%%m/%%Y %%H:%%i') as fecha_final
                FROM conteos c
                WHERE c.inventario_id = %s
                    AND c.almacen_id = %s
                    AND c.tienda_id = %s
                    AND c.tipo_conteo = %s
                    AND c.estado != 'anulado'
                ORDER BY c.id DESC
                LIMIT 1
            """, (inventario_id, data['almacen_id'], tienda_id, data['tipo_conteo']))
        
        conteo_existente = cursor.fetchone()
        
        if conteo_existente:
            estado_mensaje = "finalizado" if conteo_existente['estado'] == 'finalizado' else "en proceso"
            tipo_mensaje = "por cajas" if conteo_existente['tipo_conteo'] == 'por_cajas' else "por stand"
            mensaje = f"Este conteo {tipo_mensaje} ya fue {estado_mensaje}. Conteo ID: {conteo_existente['id']}, Inicio: {conteo_existente['fecha_inicio']}"
            if conteo_existente['fecha_final']:
                mensaje += f", Finalizaci√≥n: {conteo_existente['fecha_final']}"
            
            logging.warning(f"[iniciar_conteo] ‚ö†Ô∏è Conteo duplicado encontrado: {conteo_existente}")
            
            return {
                'success': False,
                'message': mensaje,
                'conteo_existente': {
                    'id': conteo_existente['id'],
                    'estado': conteo_existente['estado'],
                    'tipo_conteo': conteo_existente['tipo_conteo'],
                    'fecha_inicio': conteo_existente['fecha_inicio'],
                    'fecha_final': conteo_existente['fecha_final']
                }
            }
        
        logging.info(f"[iniciar_conteo] ‚úì No se encontr√≥ conteo duplicado, procediendo a crear nuevo conteo")
        
        # Log antes de crear el conteo
        logging.info(f"[iniciar_conteo] Creando conteo con numero_inventario='{data['numero_inventario']}', inventario_id={inventario_id}, almacen_id={data['almacen_id']}, tienda_id={tienda_id}, tipo={data['tipo_conteo']}")
        
        cursor.callproc('sp_iniciar_conteo', [
            data['numero_inventario'],
            data['almacen_id'],
            tienda_id,
            data['registrado_por'],
            data['tipo_conteo'],
            data.get('origen_datos', 'sistema'),
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_iniciar_conteo_6, @_sp_iniciar_conteo_7')
        result = cursor.fetchone()
        
        conteo_id = result['@_sp_iniciar_conteo_6']
        
        # Verificar qu√© inventario_id tiene el conteo creado
        if conteo_id > 0:
            cursor.execute("""
                SELECT c.id, c.inventario_id, i.numero_inventario, c.estado, c.almacen_id, a.nombre as almacen
                FROM conteos c
                LEFT JOIN inventarios i ON c.inventario_id = i.id
                LEFT JOIN almacenes a ON c.almacen_id = a.id
                WHERE c.id = %s
            """, (conteo_id,))
            conteo_info = cursor.fetchone()
            if conteo_info:
                logging.info(f"[iniciar_conteo] Conteo creado: ID={conteo_id}, inventario_id={conteo_info['inventario_id']}, numero_inventario={conteo_info['numero_inventario']}, estado={conteo_info['estado']}, almacen={conteo_info['almacen']}")
            else:
                logging.warning(f"[iniciar_conteo] ‚ö†Ô∏è Conteo {conteo_id} creado pero no se pudo obtener informaci√≥n")
        
        # Si el origen es 'sistema', cargar productos del sistema
        if data.get('origen_datos', 'sistema') == 'sistema' and conteo_id > 0:
            cursor.callproc('sp_cargar_productos_conteo', [
                conteo_id,
                0,  # OUT p_resultado
                ''  # OUT p_mensaje
            ])
            
            cursor.execute('SELECT @_sp_cargar_productos_conteo_1, @_sp_cargar_productos_conteo_2')
            carga_result = cursor.fetchone()
            
        conn.commit()
        
        if conteo_id > 0:
            response = {
                'success': True,
                'conteo_id': conteo_id,
                'message': result['@_sp_iniciar_conteo_7']
            }
            if data.get('origen_datos', 'sistema') == 'sistema':
                response['productos_cargados'] = carga_result['@_sp_cargar_productos_conteo_1']
            return response
        else:
            return {
                'success': False,
                'message': result['@_sp_iniciar_conteo_7']
            }
            
    except Exception as e:
        logging.error(f"Error en iniciar_conteo: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al iniciar conteo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# =================================================================================
# FUNCION ACTUALIZAR UBICACION COLABORADOR (PARA VER EN DONDE ESTA HACIENDO CONTEO)
# =================================================================================
def actualizar_ubicacion_colaborador(nombre_colaborador, inventario_id, conteo_id=None):
    """
    Registra en qu√© conteo (tienda/stand) est√° trabajando el usuario actualmente.
    Si conteo_id es None, significa que sali√≥ de la tienda al men√∫ principal.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        query = """
            UPDATE colaboradores_inventario 
            SET conteo_actual_id = %s 
            WHERE nombre_colaborador = %s AND inventario_id = %s
        """
        cursor.execute(query, (conteo_id, nombre_colaborador, inventario_id))
        conn.commit()
        return {'success': True}
    except Exception as e:
        logging.error(f"Error al ubicar colaborador: {e}")
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()


# =================================================================================
# FUNCION PARA MONITOREAR USUARIOS DURANTE EL CONTEO
# =================================================================================
def obtener_presencia_colaboradores(inventario_id):
    """
    Muestra qu√© personas est√°n activas y en qu√© tienda/conteo est√°n metidas.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        query = """
            SELECT 
                ci.nombre_colaborador,
                ci.rol,
                COALESCE(t.nombre_tienda, 'Men√∫ Principal / Callao') as ubicacion,
                c.tipo_conteo
            FROM colaboradores_inventario ci
            LEFT JOIN conteos c ON ci.conteo_actual_id = c.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE ci.inventario_id = %s
        """
        cursor.execute(query, (inventario_id,))
        return {'success': True, 'usuarios_activos': cursor.fetchall()}
    except Exception as e:
        return {'success': False, 'error': str(e)}
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION (SUBIDA DE EXCEL EMERGENCIA)
# ============================================================
def cargar_excel_emergencia(request):
    """
    Procesa archivo Excel de emergencia para un conteo
    """
    try:
        # Obtener datos del formulario
        conteo_id = request.form.get('conteo_id')
        usuario = request.form.get('usuario')
        
        if 'excel_file' not in request.files:
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        # Primero intentar leer la hoja 'Products'
        try:
            file.seek(0)  # Asegurar que el archivo est√© al inicio
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                # Usar la primera hoja disponible
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Normalizar nombres de columnas (convertir a may√∫sculas y eliminar espacios extra)
        excel_data.columns = excel_data.columns.str.strip().str.upper()
        
        # Mapear columnas posibles (aceptar diferentes nombres)
        column_mapping = {
            'CODIGO': ['CODIGO', 'C√ìDIGO', 'COD'],
            'CANTIDAD': ['CANTIDAD', 'CANT', 'QTY'],
            'UNIDAD_MEDIDA': ['UNIDAD DE MEDIDA', 'UNIDAD_MEDIDA', 'UNIDAD', 'UNIDAD DE MED', 'C√ìDIGO UNIDAD']
        }
        
        # Buscar las columnas correctas
        codigo_col = None
        cantidad_col = None
        unidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in column_mapping['CODIGO']:
                codigo_col = col
            elif col_upper in column_mapping['CANTIDAD']:
                cantidad_col = col
            elif col_upper in column_mapping['UNIDAD_MEDIDA']:
                unidad_col = col
        
        # Verificar que se encontraron las columnas necesarias
        if not codigo_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna CODIGO. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        if not cantidad_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna CANTIDAD. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        if not unidad_col:
            return {'success': False, 'message': f'No se encontr√≥ la columna UNIDAD DE MEDIDA. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'}
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Crear la tabla temporal si no existe (las tablas temporales solo existen en la sesi√≥n actual)
        # Usar CREATE TEMPORARY TABLE IF NOT EXISTS para evitar errores si ya existe
        try:
            cursor.execute("""
                CREATE TEMPORARY TABLE IF NOT EXISTS tmp_excel_conteo (
                    codigo VARCHAR(100),
                    cantidad INT,
                    unidad_excel VARCHAR(50)
                )
            """)
        except Exception as e:
            logging.warning(f"Error al crear tabla temporal tmp_excel_conteo: {str(e)}")
            # Si falla, intentar sin IF NOT EXISTS (puede que ya exista en esta sesi√≥n)
            try:
                cursor.execute("""
                    CREATE TEMPORARY TABLE tmp_excel_conteo (
                        codigo VARCHAR(100),
                        cantidad INT,
                        unidad_excel VARCHAR(50)
                    )
                """)
            except Exception:
                # Si ya existe, simplemente limpiarla
                pass
        
        # Limpiar tabla temporal (las tablas temporales se limpian autom√°ticamente al cerrar conexi√≥n)
        # Pero es mejor limpiarla manualmente para evitar datos residuales
        try:
            cursor.execute("DELETE FROM tmp_excel_conteo")
        except Exception as e:
            logging.warning(f"Error al limpiar tabla tmp_excel_conteo: {str(e)}")
            # Si falla, la tabla puede estar vac√≠a o no existir, continuar de todas formas
        
        # Insertar datos en tabla temporal
        registros_insertados = 0
        for _, row in excel_data.iterrows():
            try:
                codigo = str(row[codigo_col]).strip() if pd.notna(row[codigo_col]) else None
                
                # Convertir cantidad a int (manejar diferentes tipos)
                cantidad_raw = row[cantidad_col] if pd.notna(row[cantidad_col]) else 0
                try:
                    if isinstance(cantidad_raw, str):
                        cantidad = int(float(cantidad_raw.strip()))
                    else:
                        cantidad = int(float(cantidad_raw))
                except (ValueError, TypeError):
                    logging.warning(f"[cargar_excel_emergencia] Error al convertir cantidad para c√≥digo {codigo}: {cantidad_raw}, usando 0")
                    cantidad = 0
                
                unidad = str(row[unidad_col]).strip() if pd.notna(row[unidad_col]) else ''
                
                if codigo:  # Solo insertar si hay c√≥digo
                    cursor.execute(
                        "INSERT INTO tmp_excel_conteo (codigo, cantidad, unidad_excel) VALUES (%s, %s, %s)",
                        (codigo, cantidad, unidad)
                    )
                    registros_insertados += 1
                    logging.debug(f"[cargar_excel_emergencia] Insertado en tmp: codigo={codigo}, cantidad={cantidad}, unidad={unidad}")
            except Exception as e:
                logging.warning(f"[cargar_excel_emergencia] Error al procesar fila del Excel: {str(e)}")
                continue
        
        logging.info(f"[cargar_excel_emergencia] Total registros insertados en tmp_excel_conteo: {registros_insertados}")
        
        # Verificar datos en tabla temporal antes de procesar
        cursor.execute("SELECT COUNT(*) as total, SUM(cantidad) as suma_cantidades FROM tmp_excel_conteo")
        tmp_info = cursor.fetchone()
        logging.info(f"[cargar_excel_emergencia] Datos en tmp_excel_conteo: {tmp_info['total']} registros, suma_cantidades={tmp_info['suma_cantidades']}")
        
        # Llamar al stored procedure para procesar el Excel
        try:
            cursor.callproc('sp_cargar_conteo_desde_excel', [
                int(conteo_id),
                usuario,
                0,  # OUT p_registros_procesados
                0   # OUT p_registros_actualizados
            ])
            
            cursor.execute('SELECT @_sp_cargar_conteo_desde_excel_2, @_sp_cargar_conteo_desde_excel_3')
            result = cursor.fetchone()
            registros_procesados = result['@_sp_cargar_conteo_desde_excel_2'] if result else 0
            registros_actualizados = result['@_sp_cargar_conteo_desde_excel_3'] if result else 0
        except Exception as e:
            logging.error(f"[cargar_excel_emergencia] Error en stored procedure: {str(e)}")
            # Si el stored procedure falla, hacer UPDATE directo
            logging.info(f"[cargar_excel_emergencia] Intentando UPDATE directo desde tmp_excel_conteo")
            
            # Actualizar directamente desde la tabla temporal
            cursor.execute("""
                UPDATE detalle_conteo dc
                INNER JOIN productos_inventario pi ON dc.item_producto = pi.item
                INNER JOIN tmp_excel_conteo tmp ON UPPER(TRIM(pi.codigo)) = UPPER(TRIM(tmp.codigo))
                SET dc.cantidad = tmp.cantidad,
                    dc.unidad_medida = COALESCE(tmp.unidad_excel, dc.unidad_medida),
                    dc.usuario_modificacion = %s,
                    dc.fecha_hora_modificacion = CURRENT_TIMESTAMP
                WHERE dc.conteo_id = %s
            """, (usuario, int(conteo_id)))
            
            registros_actualizados = cursor.rowcount
            registros_procesados = registros_insertados
            result = {'@_sp_cargar_conteo_desde_excel_2': registros_procesados, '@_sp_cargar_conteo_desde_excel_3': registros_actualizados}
            logging.info(f"[cargar_excel_emergencia] UPDATE directo completado: {registros_actualizados} registros actualizados")
        
        # Verificar que las cantidades se guardaron correctamente despu√©s del procesamiento
        cursor.execute("""
            SELECT 
                COUNT(*) as total_detalles,
                SUM(cantidad) as suma_cantidades,
                COUNT(CASE WHEN cantidad > 0 THEN 1 END) as detalles_con_cantidad
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        detalle_info = cursor.fetchone()
        logging.info(f"[cargar_excel_emergencia] Despu√©s de procesamiento: total_detalles={detalle_info['total_detalles']}, suma_cantidades={detalle_info['suma_cantidades']}, con_cantidad={detalle_info['detalles_con_cantidad']}")
        
        # Si no hay cantidades guardadas, intentar UPDATE directo como respaldo
        if detalle_info['suma_cantidades'] == 0 and registros_insertados > 0:
            logging.warning(f"[cargar_excel_emergencia] ‚ö†Ô∏è No se guardaron cantidades, intentando UPDATE directo de respaldo")
            cursor.execute("""
                UPDATE detalle_conteo dc
                INNER JOIN productos_inventario pi ON dc.item_producto = pi.item
                INNER JOIN tmp_excel_conteo tmp ON UPPER(TRIM(pi.codigo)) = UPPER(TRIM(tmp.codigo))
                SET dc.cantidad = tmp.cantidad,
                    dc.unidad_medida = COALESCE(tmp.unidad_excel, dc.unidad_medida),
                    dc.usuario_modificacion = %s,
                    dc.fecha_hora_modificacion = CURRENT_TIMESTAMP
                WHERE dc.conteo_id = %s
            """, (usuario, int(conteo_id)))
            
            registros_actualizados = cursor.rowcount
            logging.info(f"[cargar_excel_emergencia] UPDATE de respaldo: {registros_actualizados} registros actualizados")
        
        # Actualizar conteo para indicar que viene de Excel
        cursor.execute(
            "UPDATE conteos SET origen_datos = 'excel' WHERE id = %s",
            (conteo_id,)
        )
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_leidos': registros_insertados,
            'registros_procesados': result['@_sp_cargar_conteo_desde_excel_2'],
            'registros_actualizados': result['@_sp_cargar_conteo_desde_excel_3'],
            'detalles_con_cantidad': detalle_info['detalles_con_cantidad'],
            'suma_cantidades': int(detalle_info['suma_cantidades']) if detalle_info['suma_cantidades'] else 0,
            'message': f'Excel procesado desde hoja "{sheet_used}": {registros_insertados} filas le√≠das, {result["@_sp_cargar_conteo_desde_excel_2"]} registros procesados, {result["@_sp_cargar_conteo_desde_excel_3"]} actualizados'
        }
            
    except Exception as e:
        logging.error(f"Error en cargar_excel_emergencia: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': 'Error al procesar el archivo Excel',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTNER DETALLE CONTEO
# ============================================================
def obtener_detalle_conteo(conteo_id):
    """
    Obtiene el detalle de productos de un conteo
    Incluye TODOS los productos del cat√°logo, incluso los que tienen cantidad 0
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener informaci√≥n del conteo primero
        cursor.execute("""
            SELECT 
                c.*,
                a.nombre as almacen_nombre,
                t.nombre_tienda as tienda_nombre,
                i.numero_inventario,
                i.area,
                i.autorizado_por
            FROM conteos c
            INNER JOIN inventarios i ON c.inventario_id = i.id
            INNER JOIN almacenes a ON c.almacen_id = a.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE c.id = %s
        """, (conteo_id,))
        
        conteo_info = cursor.fetchone()
        
        if not conteo_info:
            return {
                'success': False,
                'message': 'Conteo no encontrado'
            }
        
        # Obtener TODOS los productos del cat√°logo, incluso los que no tienen registro en detalle_conteo
        # Esto asegura que se muestren todos los productos, incluso con cantidad 0
        cursor.execute("""
            SELECT 
                pi.item as item_producto,
                pi.producto,
                pi.codigo,
                COALESCE(dc.cantidad, 0) as cantidad,
                COALESCE(dc.unidad_medida, pi.unidad_medida) as unidad_medida,
                dc.id as detalle_id,
                dc.conteo_id,
                dc.fecha_hora_registro,
                dc.fecha_hora_modificacion,
                dc.usuario_modificacion,
                %s as tipo_conteo,
                %s as almacen_id,
                %s as almacen_nombre,
                %s as tienda_id,
                %s as tienda_nombre
            FROM productos_inventario pi
            LEFT JOIN detalle_conteo dc ON pi.item = dc.item_producto AND dc.conteo_id = %s
            WHERE pi.estado = 'activo'
            ORDER BY pi.item
        """, (
            conteo_info['tipo_conteo'],
            conteo_info['almacen_id'],
            conteo_info['almacen_nombre'],
            conteo_info['tienda_id'],
            conteo_info['tienda_nombre'],
            conteo_id
        ))
        
        productos = cursor.fetchall()
        
        return {
            'success': True,
            'conteo': conteo_info,
            'productos': productos,
            'total_productos': len(productos),
            'productos_con_cantidad': len([p for p in productos if p['cantidad'] > 0]),
            'productos_sin_cantidad': len([p for p in productos if p['cantidad'] == 0])
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS INICIADOS (EN PROCESO)
# ============================================================
def listar_conteos_iniciados(inventario_id=None):
    """
    Lista todos los conteos que est√°n iniciados (en proceso) para poder finalizarlos
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Si no se proporciona inventario_id, obtener el inventario activo
        if not inventario_id:
            cursor.callproc('sp_obtener_inventario_activo', [
                0,  # OUT p_inventario_id
                ''  # OUT p_numero_inventario
            ])
            cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
            result_activo = cursor.fetchone()
            inventario_id = result_activo['@_sp_obtener_inventario_activo_0']
            
            if not inventario_id:
                return {
                    'success': False,
                    'message': 'No hay inventario activo. Especifique inventario_id.'
                }
        else:
            # Convertir a int si viene como string
            try:
                inventario_id = int(inventario_id)
            except (ValueError, TypeError):
                return {
                    'success': False,
                    'message': f'inventario_id inv√°lido: {inventario_id}'
                }
        
        # Log para debugging
        logging.info(f"[listar_conteos_iniciados] Buscando conteos para inventario_id={inventario_id}")
        
        # Obtener conteos en proceso para este inventario
        cursor.execute("""
            SELECT 
                c.id as conteo_id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                c.almacen_id,
                a.nombre as almacen_nombre,
                c.tienda_id,
                t.nombre_tienda as tienda_nombre,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.estado,
                c.origen_datos,
                c.archivo_pdf,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total,
                i.numero_inventario as inventario_numero,
                i.area as inventario_area
            FROM conteos c
            INNER JOIN inventarios i ON c.inventario_id = i.id
            INNER JOIN almacenes a ON c.almacen_id = a.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.estado = 'en_proceso'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.almacen_id, a.nombre, c.tienda_id, t.nombre_tienda,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.estado,
                     c.origen_datos, c.archivo_pdf, i.numero_inventario, i.area
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id,))
        
        conteos = cursor.fetchall()
        
        # Verificar si hay conteos con otros inventario_id o estados
        cursor.execute("""
            SELECT COUNT(*) as total, 
                   GROUP_CONCAT(DISTINCT c.inventario_id) as inventarios_ids,
                   GROUP_CONCAT(DISTINCT c.estado) as estados
            FROM conteos c
            WHERE c.numero_inventario = (SELECT numero_inventario FROM inventarios WHERE id = %s)
               OR c.inventario_id = %s
        """, (inventario_id, inventario_id))
        debug_info = cursor.fetchone()
        logging.info(f"[listar_conteos_iniciados] Conteos encontrados: {len(conteos)}. Debug: total={debug_info['total']}, inventarios={debug_info['inventarios_ids']}, estados={debug_info['estados']}")
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT 
                id,
                numero_inventario,
                area,
                estado,
                autorizado_por
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        
        inventario_info = cursor.fetchone()
        
        return {
            'success': True,
            'inventario': inventario_info,
            'conteos_en_proceso': conteos,
            'total_conteos': len(conteos),
            'message': f'Se encontraron {len(conteos)} conteo(s) en proceso'
        }
            
    except Exception as e:
        logging.error(f"Error en listar_conteos_iniciados: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar conteos iniciados',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LA ACTUALIZACION DE INVENTARIO (INDIVIDUAL)
# ============================================================
def actualizar_cantidad_producto_individual(data):
    """
    Actualiza la cantidad de un producto individualmente
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Validar y convertir cantidad a int
        detalle_id = data.get('detalle_id')
        nueva_cantidad_raw = data.get('nueva_cantidad')
        usuario = data.get('usuario')
        
        # Convertir cantidad a int (manejar string, float, None)
        try:
            if nueva_cantidad_raw is None:
                nueva_cantidad = 0
            elif isinstance(nueva_cantidad_raw, str):
                nueva_cantidad = int(float(nueva_cantidad_raw.strip()))
            else:
                nueva_cantidad = int(float(nueva_cantidad_raw))
        except (ValueError, TypeError) as e:
            logging.error(f"[actualizar_cantidad_producto_individual] Error al convertir cantidad: {nueva_cantidad_raw}, error: {str(e)}")
            return {
                'success': False,
                'message': f'Cantidad inv√°lida: {nueva_cantidad_raw}'
            }
        
        # Log para debugging
        logging.info(f"[actualizar_cantidad_producto_individual] Actualizando detalle_id={detalle_id}, cantidad={nueva_cantidad}, usuario={usuario}")
        
        # Verificar que el detalle existe antes de actualizar
        cursor.execute("SELECT id, cantidad, conteo_id FROM detalle_conteo WHERE id = %s", (detalle_id,))
        detalle_actual = cursor.fetchone()
        
        if not detalle_actual:
            return {
                'success': False,
                'message': f'No se encontr√≥ el detalle con ID: {detalle_id}'
            }
        
        logging.info(f"[actualizar_cantidad_producto_individual] Detalle actual: cantidad={detalle_actual['cantidad']}, conteo_id={detalle_actual['conteo_id']}")
        
        # Actualizar directamente en lugar de usar stored procedure (m√°s confiable)
        logging.info(f"[actualizar_cantidad_producto_individual] Ejecutando UPDATE: cantidad={nueva_cantidad}, usuario={usuario}, detalle_id={detalle_id}")
        
        cursor.execute("""
            UPDATE detalle_conteo 
            SET cantidad = %s,
                usuario_modificacion = %s,
                fecha_hora_modificacion = CURRENT_TIMESTAMP
            WHERE id = %s
        """, (nueva_cantidad, usuario, detalle_id))
        
        rows_affected = cursor.rowcount
        logging.info(f"[actualizar_cantidad_producto_individual] UPDATE ejecutado. Filas afectadas: {rows_affected}")
        
        # Verificar que se actualiz√≥ ANTES del commit
        cursor.execute("SELECT cantidad, usuario_modificacion FROM detalle_conteo WHERE id = %s", (detalle_id,))
        detalle_verificado = cursor.fetchone()
        
        logging.info(f"[actualizar_cantidad_producto_individual] ANTES del commit - Cantidad verificada: {detalle_verificado['cantidad'] if detalle_verificado else 'N/A'}, usuario: {detalle_verificado['usuario_modificacion'] if detalle_verificado else 'N/A'}")
        
        # CR√çTICO: Hacer commit expl√≠cito y verificar que se ejecut√≥
        try:
            conn.commit()
            logging.info(f"[actualizar_cantidad_producto_individual] ‚úì COMMIT realizado exitosamente")
        except Exception as commit_error:
            logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå ERROR en COMMIT: {str(commit_error)}")
            conn.rollback()
            raise commit_error
        
        # Verificar DESPU√âS del commit - Obtener TODOS los campos para verificar que todo se guard√≥ correctamente
        # Usar una nueva conexi√≥n para asegurar que leemos los datos persistidos
        cursor.execute("""
            SELECT 
                id, conteo_id, item_producto, producto, codigo, 
                cantidad, unidad_medida, 
                fecha_hora_registro, fecha_hora_modificacion, usuario_modificacion
            FROM detalle_conteo 
            WHERE id = %s
        """, (detalle_id,))
        detalle_despues = cursor.fetchone()
        
        if detalle_despues:
            logging.info(f"[actualizar_cantidad_producto_individual] ‚úì DESPU√âS del commit - Registro completo:")
            logging.info(f"  - id: {detalle_despues['id']}")
            logging.info(f"  - conteo_id: {detalle_despues['conteo_id']}")
            logging.info(f"  - item_producto: {detalle_despues['item_producto']}")
            logging.info(f"  - producto: {detalle_despues['producto']}")
            logging.info(f"  - codigo: {detalle_despues['codigo']}")
            logging.info(f"  - cantidad: {detalle_despues['cantidad']} ‚≠ê (esperado: {nueva_cantidad})")
            logging.info(f"  - unidad_medida: {detalle_despues['unidad_medida']}")
            logging.info(f"  - fecha_hora_registro: {detalle_despues['fecha_hora_registro']}")
            logging.info(f"  - fecha_hora_modificacion: {detalle_despues['fecha_hora_modificacion']}")
            logging.info(f"  - usuario_modificacion: {detalle_despues['usuario_modificacion']}")
            
            # Verificaci√≥n cr√≠tica: ¬øLa cantidad se guard√≥ correctamente?
            if detalle_despues['cantidad'] != nueva_cantidad:
                logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå‚ùå‚ùå ERROR CR√çTICO: La cantidad NO se guard√≥ correctamente!")
                logging.error(f"  Esperado: {nueva_cantidad}, Obtenido: {detalle_despues['cantidad']}")
            else:
                logging.info(f"[actualizar_cantidad_producto_individual] ‚úÖ‚úÖ‚úÖ VERIFICACI√ìN EXITOSA: La cantidad se guard√≥ correctamente!")
        else:
            logging.error(f"[actualizar_cantidad_producto_individual] ‚ùå ERROR: No se encontr√≥ el registro despu√©s del commit")
        
        if rows_affected > 0:
            return {
                'success': True,
                'message': f'Cantidad actualizada correctamente a {nueva_cantidad}',
                'cantidad_anterior': detalle_actual['cantidad'],
                'cantidad_nueva': nueva_cantidad
            }
        else:
            return {
                'success': False,
                'message': 'No se pudo actualizar la cantidad. Verifique que el detalle_id sea correcto.'
            }
            
    except Exception as e:
        logging.error(f"[actualizar_cantidad_producto_individual] Error: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LA ACTUALIZACION DE INVENTARIO (MASIVO)
# ============================================================
def actualizar_masivo_productos(data):
    """
    Actualizaci√≥n masiva de cantidad y/o unidad de medida de productos
    Permite actualizar uno o ambos campos manteniendo el otro sin cambios
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        conteo_id = data['conteo_id']
        productos = data['productos']  # Lista de productos a actualizar
        usuario = data['usuario']
        
        registros_actualizados = 0
        
        for producto in productos:
            detalle_id = producto['detalle_id']
            
            # Obtener datos actuales del producto
            cursor.execute("""
                SELECT cantidad, unidad_medida 
                FROM detalle_conteo 
                WHERE id = %s AND conteo_id = %s
            """, (detalle_id, conteo_id))
            
            producto_actual = cursor.fetchone()
            
            if producto_actual:
                # Determinar qu√© campos actualizar
                nueva_cantidad_raw = producto.get('nueva_cantidad', producto_actual['cantidad'])
                nueva_unidad = producto.get('nueva_unidad_medida', producto_actual['unidad_medida'])
                
                # Convertir cantidad a int (manejar string, float, None)
                try:
                    if nueva_cantidad_raw is None:
                        nueva_cantidad = producto_actual['cantidad']
                    elif isinstance(nueva_cantidad_raw, str):
                        nueva_cantidad = int(float(nueva_cantidad_raw.strip()))
                    else:
                        nueva_cantidad = int(float(nueva_cantidad_raw))
                except (ValueError, TypeError) as e:
                    logging.error(f"[actualizar_masivo_productos] Error al convertir cantidad para detalle_id={detalle_id}: {nueva_cantidad_raw}, error: {str(e)}")
                    nueva_cantidad = producto_actual['cantidad']  # Mantener valor actual si hay error
                
                # Log para debugging
                logging.info(f"[actualizar_masivo_productos] Actualizando detalle_id={detalle_id}, cantidad_anterior={producto_actual['cantidad']}, cantidad_nueva={nueva_cantidad}")
                
                # Actualizar producto
                cursor.execute("""
                    UPDATE detalle_conteo 
                    SET cantidad = %s, 
                        unidad_medida = %s,
                        usuario_modificacion = %s,
                        fecha_hora_modificacion = CURRENT_TIMESTAMP
                    WHERE id = %s AND conteo_id = %s
                """, (nueva_cantidad, nueva_unidad, usuario, detalle_id, conteo_id))
                
                # Verificar que se actualiz√≥ correctamente
                cursor.execute("SELECT cantidad FROM detalle_conteo WHERE id = %s", (detalle_id,))
                detalle_verificado = cursor.fetchone()
                if detalle_verificado:
                    logging.info(f"[actualizar_masivo_productos] ‚úì Cantidad verificada despu√©s de UPDATE: {detalle_verificado['cantidad']}")
                else:
                    logging.warning(f"[actualizar_masivo_productos] ‚ö†Ô∏è No se pudo verificar detalle_id={detalle_id} despu√©s de UPDATE")
                
                if cursor.rowcount > 0:
                    registros_actualizados += 1
                    
                    # Registrar auditor√≠a para cantidad si cambi√≥
                    if str(nueva_cantidad) != str(producto_actual['cantidad']):
                        cursor.execute("""
                            INSERT INTO auditoria_cambios (
                                detalle_conteo_id, conteo_id, campo_modificado,
                                valor_anterior, valor_nuevo, tipo_modificacion, usuario
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                        """, (
                            detalle_id, conteo_id, 'cantidad',
                            str(producto_actual['cantidad']), str(nueva_cantidad),
                            'masiva', usuario
                        ))
                    
                    # Registrar auditor√≠a para unidad si cambi√≥
                    if nueva_unidad != producto_actual['unidad_medida']:
                        cursor.execute("""
                            INSERT INTO auditoria_cambios (
                                detalle_conteo_id, conteo_id, campo_modificado,
                                valor_anterior, valor_nuevo, tipo_modificacion, usuario
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                        """, (
                            detalle_id, conteo_id, 'unidad_medida',
                            producto_actual['unidad_medida'], nueva_unidad,
                            'masiva', usuario
                        ))
        
        # CR√çTICO: Hacer commit expl√≠cito y verificar que se ejecut√≥
        try:
            conn.commit()
            logging.info(f"[actualizar_masivo_productos] ‚úì COMMIT realizado exitosamente para {registros_actualizados} registros")
        except Exception as commit_error:
            logging.error(f"[actualizar_masivo_productos] ‚ùå ERROR en COMMIT: {str(commit_error)}")
            conn.rollback()
            raise commit_error
        
        # Verificaci√≥n adicional: Contar cu√°ntos registros tienen cantidad > 0 despu√©s del commit
        cursor.execute("""
            SELECT COUNT(*) as total_con_cantidad
            FROM detalle_conteo
            WHERE conteo_id = %s AND cantidad > 0
        """, (conteo_id,))
        verificacion = cursor.fetchone()
        logging.info(f"[actualizar_masivo_productos] Verificaci√≥n post-commit: {verificacion['total_con_cantidad']} productos con cantidad > 0 en conteo_id {conteo_id}")
        
        return {
            'success': True,
            'registros_actualizados': registros_actualizados,
            'productos_con_cantidad': verificacion['total_con_cantidad'],
            'message': f'Actualizaci√≥n masiva completada: {registros_actualizados} productos actualizados'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        logging.error(f"[actualizar_masivo_productos] Error: {str(e)}")
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION DE DIAGN√ìSTICO PARA VERIFICAR ESTADO DE CANTIDADES
# ============================================================
def diagnosticar_cantidades_conteo(conteo_id):
    """
    Funci√≥n de diagn√≥stico para verificar el estado de las cantidades en un conteo
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener informaci√≥n del conteo
        cursor.execute("""
            SELECT c.id, c.inventario_id, c.estado, c.tipo_conteo, c.almacen_id
            FROM conteos c
            WHERE c.id = %s
        """, (conteo_id,))
        conteo_info = cursor.fetchone()
        
        if not conteo_info:
            return {
                'success': False,
                'message': f'Conteo {conteo_id} no encontrado'
            }
        
        # Estad√≠sticas de detalle_conteo
        # IMPORTANTE: Verificar el tipo de dato de cantidad
        cursor.execute("""
            SELECT 
                COUNT(*) as total_registros,
                COUNT(CASE WHEN cantidad > 0 THEN 1 END) as registros_con_cantidad,
                COUNT(CASE WHEN cantidad = 0 THEN 1 END) as registros_sin_cantidad,
                SUM(CAST(cantidad AS UNSIGNED)) as suma_total_cantidades,
                MAX(CAST(cantidad AS UNSIGNED)) as cantidad_maxima,
                COUNT(CASE WHEN usuario_modificacion IS NOT NULL THEN 1 END) as registros_modificados,
                COUNT(CASE WHEN fecha_hora_modificacion > fecha_hora_registro THEN 1 END) as registros_actualizados,
                GROUP_CONCAT(DISTINCT CAST(cantidad AS CHAR) ORDER BY cantidad DESC LIMIT 5) as valores_cantidad_ejemplos
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        estadisticas = cursor.fetchone()
        
        # Verificar espec√≠ficamente el registro que se actualiz√≥ recientemente (ID 15245)
        cursor.execute("""
            SELECT id, codigo, producto, cantidad, 
                   CAST(cantidad AS UNSIGNED) as cantidad_numerica,
                   usuario_modificacion, 
                   fecha_hora_registro, fecha_hora_modificacion
            FROM detalle_conteo
            WHERE conteo_id = %s AND id = 15245
        """, (conteo_id,))
        registro_especifico = cursor.fetchone()
        
        # Muestra algunos ejemplos de registros (los que tienen cantidad > 0 primero)
        cursor.execute("""
            SELECT id, codigo, producto, cantidad, 
                   CAST(cantidad AS UNSIGNED) as cantidad_numerica,
                   usuario_modificacion, 
                   fecha_hora_registro, fecha_hora_modificacion
            FROM detalle_conteo
            WHERE conteo_id = %s
            ORDER BY CAST(cantidad AS UNSIGNED) DESC, id ASC
            LIMIT 10
        """, (conteo_id,))
        ejemplos = cursor.fetchall()
        
        # Verificar si hay registros duplicados o problemas de integridad
        cursor.execute("""
            SELECT 
                COUNT(*) as total,
                COUNT(DISTINCT id) as ids_unicos,
                COUNT(DISTINCT codigo) as codigos_unicos
            FROM detalle_conteo
            WHERE conteo_id = %s
        """, (conteo_id,))
        integridad = cursor.fetchone()
        
        return {
            'success': True,
            'conteo': conteo_info,
            'estadisticas': estadisticas,
            'registro_especifico_15245': registro_especifico,
            'integridad': integridad,
            'ejemplos': ejemplos,
            'diagnostico': {
                'total_registros': estadisticas['total_registros'],
                'con_cantidad': estadisticas['registros_con_cantidad'],
                'sin_cantidad': estadisticas['registros_sin_cantidad'],
                'porcentaje_con_cantidad': round((estadisticas['registros_con_cantidad'] / estadisticas['total_registros'] * 100) if estadisticas['total_registros'] > 0 else 0, 2),
                'suma_total': int(estadisticas['suma_total_cantidades']) if estadisticas['suma_total_cantidades'] else 0,
                'cantidad_maxima': int(estadisticas['cantidad_maxima']) if estadisticas['cantidad_maxima'] else 0,
                'registros_modificados': estadisticas['registros_modificados'],
                'registros_actualizados': estadisticas['registros_actualizados'],
                'valores_cantidad_ejemplos': estadisticas['valores_cantidad_ejemplos'],
                'ids_unicos': integridad['ids_unicos'],
                'codigos_unicos': integridad['codigos_unicos']
            }
        }
    except Exception as e:
        logging.error(f"[diagnosticar_cantidades_conteo] Error: {str(e)}")
        return {
            'success': False,
            'message': f'Error en diagn√≥stico: {str(e)}'
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN
# ============================================================
def listar_conteos_almacen(cursor, almacen_nombre):
    """Lista conteos filtrando por almac√©n (Callao o Malvinas)"""
    query = """
        SELECT c.id, c.fecha_hora_inicio, c.numero_inventario, c.registrado_por, 
               c.archivo_pdf, c.tipo_conteo, c.fecha_hora_final, t.nombre_tienda as tienda
        FROM conteos c
        JOIN almacenes a ON c.almacen_id = a.id
        LEFT JOIN tiendas t ON c.tienda_id = t.id
        WHERE a.nombre = %s
        ORDER BY c.fecha_hora_inicio DESC
    """
    cursor.execute(query, (almacen_nombre,))
    return {'success': True, 'data': cursor.fetchall()}

# ============================================================
# FUNCION FINALIZAR CONTEO
# ============================================================
def finalizar_conteo(data):
    """
    Finaliza un conteo y genera el archivo PDF
    """
    try:
        # Validar campos requeridos
        if 'conteo_id' not in data:
            return {
                'success': False,
                'message': 'Falta el campo obligatorio: conteo_id'
            }
        
        # Convertir conteo_id a int si viene como string
        conteo_id = int(data['conteo_id']) if isinstance(data['conteo_id'], str) else data['conteo_id']
        
        conn = get_connection()
        cursor = conn.cursor()
        
        archivo_pdf = data.get('archivo_pdf', '')
        
        cursor.callproc('sp_finalizar_conteo', [
            conteo_id,
            archivo_pdf,
            0,  # OUT p_resultado
            ''  # OUT p_mensaje
        ])
        
        # Los par√°metros OUT se acceden con √≠ndice basado en posici√≥n (empezando desde 0)
        # p_conteo_id=0, p_archivo_pdf=1, p_resultado=2, p_mensaje=3
        cursor.execute('SELECT @_sp_finalizar_conteo_2 as resultado, @_sp_finalizar_conteo_3 as mensaje')
        result = cursor.fetchone()
        
        conn.commit()
        
        # Obtener resultado y mensaje de forma segura
        resultado = result.get('resultado') if result else None
        mensaje = result.get('mensaje') if result else 'Sin mensaje'
        
        # Convertir resultado a int de forma segura
        try:
            resultado_int = int(resultado) if resultado is not None else 0
        except (ValueError, TypeError):
            # Si el resultado no es num√©rico, intentar interpretarlo
            resultado_int = 1 if resultado else 0
        
        if resultado_int > 0:
            return {
                'success': True,
                'message': mensaje
            }
        else:
            return {
                'success': False,
                'message': mensaje
            }
            
    except Exception as e:
        logging.error(f"Error en finalizar_conteo: {str(e)}")
        return {
            'success': False,
            'message': 'Error interno al finalizar conteo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION CERRAR INVENTARIO ACTIVO
# ============================================================
def cerrar_inventario(data):
    """
    Cierra un inventario usando el stored procedure sp_cerrar_inventario
    Puede recibir numero_inventario en el body, o cerrar el inventario activo autom√°ticamente
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        numero_inventario = None
        
        # Si viene numero_inventario en el body, usarlo
        if data.get('numero_inventario'):
            numero_inventario = data['numero_inventario']
        else:
            # Si no viene, obtener el inventario activo autom√°ticamente
            cursor.callproc('sp_obtener_inventario_activo', [
                0,  # OUT p_inventario_id
                ''  # OUT p_numero_inventario
            ])
            
            cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
            result_activo = cursor.fetchone()
            
            numero_inventario = result_activo['@_sp_obtener_inventario_activo_1']
            
            if not numero_inventario:
                return {
                    'success': False,
                    'message': 'No hay inventario activo para cerrar. Especifique numero_inventario en el body.'
                }
        
        # Intentar llamar al stored procedure sp_cerrar_inventario
        # Si no existe o falla, cerrar directamente sin usar fecha_cierre
        try:
            cursor.callproc('sp_cerrar_inventario', [
                numero_inventario,
                0,  # OUT p_resultado
                ''  # OUT p_mensaje
            ])
            
            cursor.execute('SELECT @_sp_cerrar_inventario_1, @_sp_cerrar_inventario_2')
            result = cursor.fetchone()
            
            resultado = int(result.get('@_sp_cerrar_inventario_1') or 0)
            mensaje = result.get('@_sp_cerrar_inventario_2', '')
            
        except Exception as sp_error:
            # Si el stored procedure no existe o falla, cerrar directamente
            logging.warning(f"Stored procedure sp_cerrar_inventario fall√≥: {str(sp_error)}")
            
            # Verificar si hay conteos en proceso
            cursor.execute("""
                SELECT COUNT(*) as conteos_abiertos
                FROM conteos
                WHERE numero_inventario = %s AND estado = 'en_proceso'
            """, (numero_inventario,))
            
            conteos_result = cursor.fetchone()
            conteos_abiertos = conteos_result.get('conteos_abiertos', 0) if conteos_result else 0
            
            if conteos_abiertos > 0:
                resultado = 0
                mensaje = f'Hay {conteos_abiertos} conteos en proceso. Final√≠celos antes de cerrar el inventario.'
            else:
                # Cerrar inventario directamente (sin fecha_cierre si no existe)
                try:
                    cursor.execute("""
                        UPDATE inventarios 
                        SET estado = 'cerrado'
                        WHERE numero_inventario = %s AND estado = 'activo'
                    """, (numero_inventario,))
                except Exception as update_error:
                    # Si falla por columna fecha_cierre, intentar sin ella
                    logging.warning(f"Error al actualizar con fecha_cierre: {str(update_error)}")
                    cursor.execute("""
                        UPDATE inventarios 
                        SET estado = 'cerrado'
                        WHERE numero_inventario = %s AND estado = 'activo'
                    """, (numero_inventario,))
                
                if cursor.rowcount > 0:
                    resultado = 1
                    mensaje = f'Inventario {numero_inventario} cerrado correctamente.'
                else:
                    resultado = 0
                    mensaje = 'No se pudo cerrar el inventario. Verifique que existe y est√° activo.'
        
        conn.commit()
        
        if resultado > 0:
            return {
                'success': True,
                'numero_inventario': numero_inventario,
                'message': mensaje
            }
        else:
            return {
                'success': False,
                'numero_inventario': numero_inventario,
                'message': mensaje
            }
            
    except Exception as e:
        logging.error(f"Error en cerrar_inventario: {str(e)}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': 'Error interno al cerrar inventario',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION LISTAR TODOS LOS INVENTARIOS
# ============================================================
def listar_inventarios(filtrar_activos=False):
    """
    Lista todos los inventarios o solo los activos
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if filtrar_activos:
            # Solo inventarios activos - usando solo columnas que sabemos que existen
            cursor.execute("""
                SELECT 
                    i.id,
                    i.numero_inventario,
                    i.area,
                    i.autorizado_por,
                    i.estado,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                WHERE i.estado = 'activo'
                GROUP BY i.id, i.numero_inventario, i.area, i.autorizado_por, i.estado
                ORDER BY i.id DESC
            """)
        else:
            # Todos los inventarios - usando solo columnas que sabemos que existen
            cursor.execute("""
                SELECT 
                    i.id,
                    i.numero_inventario,
                    i.area,
                    i.autorizado_por,
                    i.estado,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                GROUP BY i.id, i.numero_inventario, i.area, i.autorizado_por, i.estado
                ORDER BY i.id DESC
            """)
        
        inventarios = cursor.fetchall()
        
        return {
            'success': True,
            'inventarios': inventarios,
            'total_inventarios': len(inventarios),
            'filtro': 'activos' if filtrar_activos else 'todos'
        }
            
    except Exception as e:
        logging.error(f"Error al listar inventarios: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar inventarios',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION OBTENER INVENTARIO ACTIVO
# ============================================================
def obtener_inventario_activo():
    """
    Obtiene el inventario activo actual
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.callproc('sp_obtener_inventario_activo', [
            0,  # OUT p_inventario_id
            ''  # OUT p_numero_inventario
        ])
        
        cursor.execute('SELECT @_sp_obtener_inventario_activo_0, @_sp_obtener_inventario_activo_1')
        result = cursor.fetchone()
        
        inventario_id = result['@_sp_obtener_inventario_activo_0']
        numero_inventario = result['@_sp_obtener_inventario_activo_1']
        
        if inventario_id:
            # Obtener detalles completos del inventario
            cursor.execute("""
                SELECT 
                    i.*,
                    COUNT(DISTINCT c.id) as total_conteos,
                    COUNT(DISTINCT col.id) as total_colaboradores
                FROM inventarios i
                LEFT JOIN conteos c ON i.id = c.inventario_id
                LEFT JOIN colaboradores_inventario col ON i.id = col.inventario_id
                WHERE i.id = %s
                GROUP BY i.id
            """, (inventario_id,))
            
            inventario_detalle = cursor.fetchone()
            
            # Obtener colaboradores
            cursor.execute("""
                SELECT * FROM colaboradores_inventario 
                WHERE inventario_id = %s 
                ORDER BY fecha_hora_union DESC
            """, (inventario_id,))
            
            colaboradores = cursor.fetchall()
            
            return {
                'success': True,
                'inventario': inventario_detalle,
                'colaboradores': colaboradores
            }
        else:
            return {
                'success': False,
                'message': 'No hay inventario activo'
            }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN CALLAO
# ============================================================
def listar_conteos_callao(inventario_id):
    """
    Lista todos los conteos realizados en almac√©n Callao para un inventario espec√≠fico
    Separados por tipo: por_cajas y por_stand
    """
    try:
        # Validar inventario_id
        if not inventario_id:
            return {
                'success': False,
                'message': 'inventario_id es requerido'
            }
        
        try:
            inventario_id = int(inventario_id)
        except (ValueError, TypeError):
            return {
                'success': False,
                'message': f'inventario_id inv√°lido: {inventario_id}'
            }
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        
        if not almacen_callao:
            return {'success': False, 'message': 'Almac√©n Callao no encontrado'}
        
        almacen_id = almacen_callao['id']
        
        # Conteos por cajas en Callao
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                COUNT(DISTINCT dc.id) as total_productos,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.tipo_conteo = 'por_cajas'
            GROUP BY c.id
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id, almacen_id))
        
        conteos_cajas = cursor.fetchall()
        
        # Conteos por stand en Callao
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                COUNT(DISTINCT dc.id) as total_productos,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.tipo_conteo = 'por_stand'
            GROUP BY c.id
            ORDER BY c.fecha_hora_inicio DESC
        """, (inventario_id, almacen_id))
        
        conteos_stand = cursor.fetchall()
        
        return {
            'success': True,
            'almacen': 'Callao',
            'inventario_id': inventario_id,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'total_conteos_cajas': len(conteos_cajas),
            'total_conteos_stand': len(conteos_stand),
            'total_conteos': len(conteos_cajas) + len(conteos_stand)
        }
            
    except Exception as e:
        logging.error(f"Error en listar_conteos_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar conteos de Callao: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR CONTEOS POR ALMACEN MALVINAS
# ============================================================
def listar_conteos_malvinas(inventario_id):
    """
    Lista todos los conteos realizados en almac√©n Malvinas para un inventario espec√≠fico
    Separados por tipo (cajas/stand) y por tienda
    """
    try:
        # Validar inventario_id
        if not inventario_id:
            return {
                'success': False,
                'message': 'inventario_id es requerido'
            }
        
        try:
            inventario_id = int(inventario_id)
        except (ValueError, TypeError):
            return {
                'success': False,
                'message': f'inventario_id inv√°lido: {inventario_id}'
            }
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        
        if not almacen_malvinas:
            return {'success': False, 'message': 'Almac√©n Malvinas no encontrado'}
        
        almacen_id = almacen_malvinas['id']
        
        # Obtener todas las tiendas de Malvinas
        cursor.execute("""
            SELECT id, nombre_tienda 
            FROM tiendas 
            WHERE almacen_id = %s 
            ORDER BY nombre_tienda
        """, (almacen_id,))
        
        tiendas = cursor.fetchall()
        
        resultado = {
            'success': True,
            'almacen': 'Malvinas',
            'inventario_id': inventario_id,
            'tiendas': {}
        }
        
        # Para cada tienda, obtener conteos por cajas y por stand
        for tienda in tiendas:
            tienda_id = tienda['id']
            nombre_tienda = tienda['nombre_tienda']
            
            # Conteos por cajas para esta tienda
            cursor.execute("""
                SELECT 
                    c.id,
                    c.numero_inventario,
                    c.registrado_por,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                    c.archivo_pdf,
                    c.estado,
                    c.origen_datos,
                    t.nombre_tienda,
                    COUNT(DISTINCT dc.id) as total_productos,
                    SUM(dc.cantidad) as cantidad_total
                FROM conteos c
                LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
                LEFT JOIN tiendas t ON c.tienda_id = t.id
                WHERE c.inventario_id = %s 
                    AND c.almacen_id = %s 
                    AND c.tienda_id = %s
                    AND c.tipo_conteo = 'por_cajas'
                GROUP BY c.id
                ORDER BY c.fecha_hora_inicio DESC
            """, (inventario_id, almacen_id, tienda_id))
            
            conteos_cajas = cursor.fetchall()
            
            # Conteos por stand para esta tienda
            cursor.execute("""
                SELECT 
                    c.id,
                    c.numero_inventario,
                    c.registrado_por,
                    c.tipo_conteo,
                    DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                    DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                    c.archivo_pdf,
                    c.estado,
                    c.origen_datos,
                    t.nombre_tienda,
                    COUNT(DISTINCT dc.id) as total_productos,
                    SUM(dc.cantidad) as cantidad_total
                FROM conteos c
                LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
                LEFT JOIN tiendas t ON c.tienda_id = t.id
                WHERE c.inventario_id = %s 
                    AND c.almacen_id = %s 
                    AND c.tienda_id = %s
                    AND c.tipo_conteo = 'por_stand'
                GROUP BY c.id
                ORDER BY c.fecha_hora_inicio DESC
            """, (inventario_id, almacen_id, tienda_id))
            
            conteos_stand = cursor.fetchall()
            
            # Agregar al resultado
            resultado['tiendas'][nombre_tienda] = {
                'conteos_por_cajas': conteos_cajas,
                'conteos_por_stand': conteos_stand,
                'total_cajas': len(conteos_cajas),
                'total_stand': len(conteos_stand),
                'total': len(conteos_cajas) + len(conteos_stand)
            }

        # ‚úÖ IMPORTANTE: El return debe estar FUERA del bucle for
        return resultado
        
    except Exception as e:
        logging.error(f"Error en listar_conteos_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar conteos de Malvinas: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA OBTENER HISTORIAL DE CONTEOS CALLAO (TODOS LOS USUARIOS)
# ============================================================
def obtener_historial_conteos_callao(page=1, per_page=10):
    """
    Obtiene el historial completo de conteos finalizados en almac√©n Callao
    de TODOS los usuarios, sin filtrar por inventario_id.
    Incluye paginaci√≥n.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Callao
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        
        if not almacen_callao:
            return {'success': False, 'message': 'Almac√©n Callao no encontrado'}
        
        almacen_id = almacen_callao['id']
        
        # Obtener total de conteos para paginaci√≥n
        cursor.execute("""
            SELECT COUNT(*) as total
            FROM conteos c
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
        """, (almacen_id,))
        
        total_conteos = cursor.fetchone()['total']
        total_pages = (total_conteos + per_page - 1) // per_page  # Ceiling division
        
        # Calcular offset para paginaci√≥n
        offset = (page - 1) * per_page
        
        # Obtener TODOS los conteos finalizados en Callao (TODOS los inventarios)
        # Aplicar paginaci√≥n aqu√≠ para obtener solo los de la p√°gina actual
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                c.inventario_id,
                i.numero_inventario as inventario_numero,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            LEFT JOIN inventarios i ON c.inventario_id = i.id
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.archivo_pdf,
                     c.estado, c.origen_datos, c.inventario_id, i.numero_inventario
            ORDER BY c.fecha_hora_final DESC
            LIMIT %s OFFSET %s
        """, (almacen_id, per_page, offset))
        
        todos_conteos = cursor.fetchall()
        
        # Separar por tipo de conteo despu√©s de obtener los resultados paginados
        conteos_cajas = [c for c in todos_conteos if c['tipo_conteo'] == 'por_cajas']
        conteos_stand = [c for c in todos_conteos if c['tipo_conteo'] == 'por_stand']
        
        return {
            'success': True,
            'almacen': 'Callao',
            'conteos': todos_conteos,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_conteos,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            }
        }
            
    except Exception as e:
        logging.error(f"Error en obtener_historial_conteos_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener historial de conteos de Callao: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA OBTENER HISTORIAL DE CONTEOS MALVINAS (TODOS LOS USUARIOS)
# ============================================================
def obtener_historial_conteos_malvinas(page=1, per_page=10):
    """
    Obtiene el historial completo de conteos finalizados en almac√©n Malvinas
    de TODOS los usuarios, sin filtrar por inventario_id.
    Incluye paginaci√≥n.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener ID del almac√©n Malvinas
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        
        if not almacen_malvinas:
            return {'success': False, 'message': 'Almac√©n Malvinas no encontrado'}
        
        almacen_id = almacen_malvinas['id']
        
        # Obtener total de conteos para paginaci√≥n
        cursor.execute("""
            SELECT COUNT(*) as total
            FROM conteos c
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
        """, (almacen_id,))
        
        total_conteos = cursor.fetchone()['total']
        total_pages = (total_conteos + per_page - 1) // per_page  # Ceiling division
        
        # Calcular offset para paginaci√≥n
        offset = (page - 1) * per_page
        
        # Obtener todos los conteos finalizados en Malvinas (TODOS los inventarios)
        cursor.execute("""
            SELECT 
                c.id,
                c.numero_inventario,
                c.registrado_por,
                c.tipo_conteo,
                DATE_FORMAT(c.fecha_hora_inicio, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_inicio,
                DATE_FORMAT(c.fecha_hora_final, '%%Y-%%m-%%d %%H:%%i:%%s') as fecha_hora_final,
                c.archivo_pdf,
                c.estado,
                c.origen_datos,
                c.inventario_id,
                i.numero_inventario as inventario_numero,
                c.tienda_id,
                t.nombre_tienda,
                COUNT(DISTINCT dc.id) as total_productos,
                COALESCE(SUM(dc.cantidad), 0) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            LEFT JOIN inventarios i ON c.inventario_id = i.id
            LEFT JOIN tiendas t ON c.tienda_id = t.id
            WHERE c.almacen_id = %s 
                AND c.estado = 'finalizado'
            GROUP BY c.id, c.numero_inventario, c.registrado_por, c.tipo_conteo,
                     c.fecha_hora_inicio, c.fecha_hora_final, c.archivo_pdf,
                     c.estado, c.origen_datos, c.inventario_id, i.numero_inventario,
                     c.tienda_id, t.nombre_tienda
            ORDER BY c.fecha_hora_final DESC
            LIMIT %s OFFSET %s
        """, (almacen_id, per_page, offset))
        
        conteos = cursor.fetchall()
        
        # Separar por tipo de conteo
        conteos_cajas = [c for c in conteos if c['tipo_conteo'] == 'por_cajas']
        conteos_stand = [c for c in conteos if c['tipo_conteo'] == 'por_stand']
        
        return {
            'success': True,
            'almacen': 'Malvinas',
            'conteos': conteos,
            'conteos_por_cajas': conteos_cajas,
            'conteos_por_stand': conteos_stand,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_conteos,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            }
        }
            
    except Exception as e:
        logging.error(f"Error en obtener_historial_conteos_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener historial de conteos de Malvinas: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ============================================================
# FUNCION PARA LISTAR PRODUCTOS DEL CATALOGO
# ============================================================
def listar_productos_inventario():
    """
    Lista los productos del cat√°logo maestro `productos_inventario`
    devolviendo solo los campos: item, producto, codigo y unidad_medida.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("""
            SELECT 
                item,
                producto,
                codigo,
                unidad_medida
            FROM productos_inventario
            WHERE estado = 'activo'
            ORDER BY producto
        """)

        productos = cursor.fetchall()

        return {
            'success': True,
            'productos': productos,
            'total_productos': len(productos)
        }
    except Exception as e:
        logging.error(f"Error al listar productos_inventario: {str(e)}")
        return {
            'success': False,
            'message': 'Error al listar productos del cat√°logo',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE COMPARACION DE CONTEOS (CALLAO - MALVINAS)
# =======================================================================
# ***********************************************************************

# ============================================================
# FUNCION PARA CARGAR DATOS DEL SISTEMA DESDE EXCEL (CALLAO)
# ============================================================
def cargar_sistema_callao(request):
    """
    Carga archivo Excel para datos del sistema en almac√©n Callao
    """
    try:
        # Debug: Verificar qu√© contiene request.files
        logging.info(f"cargar_sistema_callao - request.files keys: {list(request.files.keys())}")
        logging.info(f"cargar_sistema_callao - request.content_type: {request.content_type}")
        logging.info(f"cargar_sistema_callao - request.method: {request.method}")
        
        # Obtener datos del formulario
        inventario_id = request.form.get('inventario_id')
        usuario = request.form.get('usuario')
        
        # Verificar si hay archivos en la petici√≥n
        if not request.files:
            logging.error("cargar_sistema_callao - request.files est√° vac√≠o")
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel - request.files est√° vac√≠o'}
        
        if 'excel_file' not in request.files:
            logging.error(f"cargar_sistema_callao - 'excel_file' no est√° en request.files. Keys disponibles: {list(request.files.keys())}")
            return {'success': False, 'message': f'No se encontr√≥ el archivo Excel. Claves disponibles: {", ".join(request.files.keys())}'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            logging.error("cargar_sistema_callao - file.filename est√° vac√≠o")
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        try:
            file.seek(0)
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Leer columnas espec√≠ficas por posici√≥n seg√∫n especificaci√≥n:
        # Columna A (√≠ndice 0): Nombre
        # Columna B (√≠ndice 1): C√≥digo
        # Columna E (√≠ndice 4): C√≥digo Unidad
        # Columna N (√≠ndice 13): Cantidad
        
        # Primero intentar por nombre de columna (m√°s flexible)
        column_mapping = {}
        excel_data.columns = excel_data.columns.str.strip()
        
        # Buscar columnas por nombre primero
        nombre_col = None
        codigo_col = None
        unidad_col = None
        cantidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in ['NOMBRE', 'PRODUCTO', 'NOMBRE PRODUCTO']:
                nombre_col = col
            elif col_upper in ['C√ìDIGO', 'CODIGO', 'C√ìD', 'COD']:
                codigo_col = col
            elif col_upper in ['C√ìDIGO UNIDAD', 'CODIGO UNIDAD', 'UNIDAD', 'C√ìDIGO UNIDADES']:
                unidad_col = col
            elif col_upper in ['CANTIDAD', 'CANT', 'QTY']:
                cantidad_col = col
        
        # Si no se encontraron por nombre, usar posici√≥n (A=0, B=1, E=4, N=13)
        if not nombre_col and len(excel_data.columns) > 0:
            nombre_col = excel_data.columns[0]  # Columna A
        if not codigo_col and len(excel_data.columns) > 1:
            codigo_col = excel_data.columns[1]  # Columna B
        if not unidad_col and len(excel_data.columns) > 4:
            unidad_col = excel_data.columns[4]  # Columna E
        if not cantidad_col and len(excel_data.columns) > 13:
            cantidad_col = excel_data.columns[13]  # Columna N
        
        # Validar que se encontraron las columnas necesarias
        if not nombre_col:
            return {
                'success': False,
                'message': f'Columna "Nombre" (A) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not codigo_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo" (B) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not unidad_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo Unidad" (E) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not cantidad_col:
            return {
                'success': False,
                'message': f'Columna "Cantidad" (N) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        
        column_mapping = {
            'Nombre': nombre_col,
            'C√≥digo': codigo_col,
            'C√≥digo Unidad': unidad_col,
            'Cantidad': cantidad_col
        }
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Limpiar datos anteriores para este inventario (marcar como inactivos)
        cursor.execute("""
            UPDATE datos_sistema_callao 
            SET estado = 'inactivo' 
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        registros_procesados = 0
        
        # Insertar datos del Excel usando los nombres de columnas encontrados
        for _, row in excel_data.iterrows():
            try:
                # Obtener valores usando los nombres de columnas mapeados
                nombre_producto = str(row[column_mapping['Nombre']]).strip() if pd.notna(row[column_mapping['Nombre']]) else ''
                codigo_producto = str(row[column_mapping['C√≥digo']]).strip() if pd.notna(row[column_mapping['C√≥digo']]) else ''
                unidad_excel_raw = str(row[column_mapping['C√≥digo Unidad']]).strip().upper() if pd.notna(row[column_mapping['C√≥digo Unidad']]) else ''
                cantidad_raw = row[column_mapping['Cantidad']]
                
                # Validar que haya c√≥digo
                if not codigo_producto:
                    continue
                
                # Obtener producto del cat√°logo
                cursor.execute("""
                    SELECT item, unidad_medida 
                    FROM productos_inventario 
                    WHERE codigo = %s AND estado = 'activo'
                """, (codigo_producto,))
                
                producto = cursor.fetchone()
                
                # Convertir unidad de medida seg√∫n especificaci√≥n:
                # NIU ‚Üí UNIDAD
                # DC, DZN, DZP ‚Üí DOCENAS
                if unidad_excel_raw == 'NIU':
                    unidad_sistema = 'UNIDAD'
                elif unidad_excel_raw in ['DC', 'DZN', 'DZP']:
                    unidad_sistema = 'DOCENAS'
                else:
                    # Por defecto, usar UNIDAD si no coincide
                    unidad_sistema = 'UNIDAD'
                
                # Convertir cantidad a entero
                try:
                    cantidad_sistema = int(float(cantidad_raw)) if pd.notna(cantidad_raw) else 0
                except (ValueError, TypeError):
                    cantidad_sistema = 0
                
                # Insertar en datos_sistema_callao
                cursor.execute("""
                    INSERT INTO datos_sistema_callao (
                        inventario_id, producto_item, producto, codigo, 
                        cantidad_sistema, unidad_medida, archivo_origen, 
                        usuario_carga, estado
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'activo')
                """, (
                    inventario_id,
                    producto['item'] if producto else None,
                    nombre_producto,
                    codigo_producto,
                    cantidad_sistema,
                    unidad_sistema,
                    file.filename,
                    usuario
                ))
                
                registros_procesados += 1
            except Exception as e:
                logging.warning(f"Error al procesar fila del Excel en cargar_sistema_callao: {str(e)}")
                continue
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'SISTEMA_CALLAO',
            'CARGA_MASIVA',
            'callao',
            'CARGAR_SISTEMA',
            usuario,
            json.dumps({
                'archivo': file.filename,
                'registros': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_procesados': registros_procesados,
            'message': f'Se cargaron {registros_procesados} productos del sistema Callao desde hoja "{sheet_used}"'
        }
            
    except Exception as e:
        logging.error(f"Error en cargar_sistema_callao: {str(e)}")
        logging.error(f"Tipo de error: {type(e).__name__}")
        import traceback
        logging.error(f"Traceback: {traceback.format_exc()}")
        if 'conn' in locals():
            conn.rollback()
        return {
            'success': False,
            'message': f'Error al procesar el archivo Excel: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA CARGAR DATOS DEL SISTEMA DESDE EXCEL (MALVINAS)
# ============================================================
def cargar_sistema_malvinas(request):
    """
    Carga archivo Excel para datos del sistema en almac√©n Malvinas
    """
    try:
        # Obtener datos del formulario
        inventario_id = request.form.get('inventario_id')
        usuario = request.form.get('usuario')
        
        if 'excel_file' not in request.files:
            return {'success': False, 'message': 'No se encontr√≥ el archivo Excel'}
        
        file = request.files['excel_file']
        
        if file.filename == '':
            return {'success': False, 'message': 'No se seleccion√≥ archivo'}
        
        # Leer el archivo Excel - intentar primero con 'Products', si no existe usar la primera hoja
        excel_data = None
        sheet_used = None
        
        try:
            file.seek(0)
            excel_data = pd.read_excel(file, sheet_name='Products')
            sheet_used = 'Products'
        except (ValueError, Exception):
            # Si no encuentra 'Products', usar la primera hoja disponible
            try:
                file.seek(0)
                excel_file = pd.ExcelFile(file)
                sheet_names = excel_file.sheet_names
                if not sheet_names:
                    return {'success': False, 'message': 'El archivo Excel no contiene hojas'}
                file.seek(0)
                excel_data = pd.read_excel(file, sheet_name=sheet_names[0])
                sheet_used = sheet_names[0]
            except Exception as e:
                return {'success': False, 'message': f'Error al leer el archivo Excel: {str(e)}'}
        
        if excel_data is None or excel_data.empty:
            return {'success': False, 'message': 'El archivo Excel est√° vac√≠o o no se pudo leer'}
        
        # Leer columnas espec√≠ficas por posici√≥n seg√∫n especificaci√≥n:
        # Columna A (√≠ndice 0): Nombre
        # Columna B (√≠ndice 1): C√≥digo
        # Columna E (√≠ndice 4): C√≥digo Unidad
        # Columna N (√≠ndice 13): Cantidad
        
        # Primero intentar por nombre de columna (m√°s flexible)
        column_mapping = {}
        excel_data.columns = excel_data.columns.str.strip()
        
        # Buscar columnas por nombre primero
        nombre_col = None
        codigo_col = None
        unidad_col = None
        cantidad_col = None
        
        for col in excel_data.columns:
            col_upper = col.upper().strip()
            if col_upper in ['NOMBRE', 'PRODUCTO', 'NOMBRE PRODUCTO']:
                nombre_col = col
            elif col_upper in ['C√ìDIGO', 'CODIGO', 'C√ìD', 'COD']:
                codigo_col = col
            elif col_upper in ['C√ìDIGO UNIDAD', 'CODIGO UNIDAD', 'UNIDAD', 'C√ìDIGO UNIDADES']:
                unidad_col = col
            elif col_upper in ['CANTIDAD', 'CANT', 'QTY']:
                cantidad_col = col
        
        # Si no se encontraron por nombre, usar posici√≥n (A=0, B=1, E=4, N=13)
        if not nombre_col and len(excel_data.columns) > 0:
            nombre_col = excel_data.columns[0]  # Columna A
        if not codigo_col and len(excel_data.columns) > 1:
            codigo_col = excel_data.columns[1]  # Columna B
        if not unidad_col and len(excel_data.columns) > 4:
            unidad_col = excel_data.columns[4]  # Columna E
        if not cantidad_col and len(excel_data.columns) > 13:
            cantidad_col = excel_data.columns[13]  # Columna N
        
        # Validar que se encontraron las columnas necesarias
        if not nombre_col:
            return {
                'success': False,
                'message': f'Columna "Nombre" (A) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not codigo_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo" (B) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not unidad_col:
            return {
                'success': False,
                'message': f'Columna "C√≥digo Unidad" (E) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        if not cantidad_col:
            return {
                'success': False,
                'message': f'Columna "Cantidad" (N) no encontrada. Columnas disponibles: {", ".join(excel_data.columns.tolist())}'
            }
        
        column_mapping = {
            'Nombre': nombre_col,
            'C√≥digo': codigo_col,
            'C√≥digo Unidad': unidad_col,
            'Cantidad': cantidad_col
        }
        
        # Procesar datos del Excel
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Limpiar datos anteriores para este inventario (opcional)
        cursor.execute("""
            UPDATE datos_sistema_malvinas 
            SET estado = 'INACTIVO' 
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        registros_procesados = 0
        
        # Insertar datos del Excel usando los nombres de columnas encontrados
        for _, row in excel_data.iterrows():
            try:
                # Obtener valores usando los nombres de columnas mapeados
                nombre_producto = str(row[column_mapping['Nombre']]).strip() if pd.notna(row[column_mapping['Nombre']]) else ''
                codigo_producto = str(row[column_mapping['C√≥digo']]).strip() if pd.notna(row[column_mapping['C√≥digo']]) else ''
                unidad_excel_raw = str(row[column_mapping['C√≥digo Unidad']]).strip().upper() if pd.notna(row[column_mapping['C√≥digo Unidad']]) else ''
                cantidad_raw = row[column_mapping['Cantidad']]
                
                # Validar que haya c√≥digo
                if not codigo_producto:
                    continue
                
                # Obtener producto del cat√°logo
                cursor.execute("""
                    SELECT item, unidad_medida 
                    FROM productos_inventario 
                    WHERE codigo = %s AND estado = 'activo'
                """, (codigo_producto,))
                
                producto = cursor.fetchone()
                
                # Convertir unidad de medida seg√∫n especificaci√≥n:
                # NIU ‚Üí UNIDAD
                # DC, DZN, DZP ‚Üí DOCENAS
                if unidad_excel_raw == 'NIU':
                    unidad_sistema = 'UNIDAD'
                elif unidad_excel_raw in ['DC', 'DZN', 'DZP']:
                    unidad_sistema = 'DOCENAS'
                else:
                    # Por defecto, usar UNIDAD si no coincide
                    unidad_sistema = 'UNIDAD'
                
                # Convertir cantidad a entero
                try:
                    cantidad_sistema = int(float(cantidad_raw)) if pd.notna(cantidad_raw) else 0
                except (ValueError, TypeError):
                    cantidad_sistema = 0
                
                # Insertar en datos_sistema_malvinas
                cursor.execute("""
                    INSERT INTO datos_sistema_malvinas (
                        inventario_id, producto_item, producto, codigo, 
                        cantidad_sistema, unidad_medida, archivo_origen, 
                        usuario_carga, estado
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, 'ACTIVO')
                """, (
                    inventario_id,
                    producto['item'] if producto else None,
                    nombre_producto,
                    codigo_producto,
                    cantidad_sistema,
                    unidad_sistema,
                    file.filename,
                    usuario
                ))
                
                registros_procesados += 1
            except Exception as e:
                logging.warning(f"Error al procesar fila del Excel en cargar_sistema_malvinas: {str(e)}")
                continue
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'SISTEMA_MALVINAS',
            'CARGA_MASIVA',
            'malvinas',
            'CARGAR_SISTEMA',
            usuario,
            json.dumps({
                'archivo': file.filename,
                'registros': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'hoja_usada': sheet_used,
            'registros_procesados': registros_procesados,
            'message': f'Se cargaron {registros_procesados} productos del sistema Malvinas desde hoja "{sheet_used}"'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA GENERAR COMPARACION CALLAO
# ============================================================
def generar_comparacion_callao(data):
    """
    Genera comparaci√≥n autom√°tica para almac√©n Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        
        # Verificar que existe inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Llamar stored procedure para generar comparaci√≥n
        cursor.callproc('sp_generar_comparacion_callao', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''   # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_comparacion_callao_1, @_sp_generar_comparacion_callao_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_comparacion_callao_1']
        mensaje = result['@_sp_generar_comparacion_callao_2']
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'GENERACION_COMPARACION',
            'TODO',
            'callao',
            'GENERAR_COMPARACION',
            data.get('usuario', 'sistema'),
            json.dumps({
                'registros_procesados': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA GENERAR COMPARACION MALVINAS
# ============================================================
def generar_comparacion_malvinas(data):
    """
    Genera comparaci√≥n autom√°tica para almac√©n Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data['inventario_id']
        
        # Verificar que existe inventario
        cursor.execute("SELECT id FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        
        if not inventario:
            return {'success': False, 'message': 'Inventario no encontrado'}
        
        # Llamar stored procedure para generar comparaci√≥n
        cursor.callproc('sp_generar_comparacion_malvinas', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''   # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_comparacion_malvinas_1, @_sp_generar_comparacion_malvinas_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_comparacion_malvinas_1']
        mensaje = result['@_sp_generar_comparacion_malvinas_2']
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto, codigo, almacen, 
                tipo_accion, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            inventario_id,
            'GENERACION_COMPARACION',
            'TODO',
            'malvinas',
            'GENERAR_COMPARACION',
            data.get('usuario', 'sistema'),
            json.dumps({
                'registros_procesados': registros_procesados
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER ESTADO DE CONTEOS POR TIENDA
# ============================================================
def obtener_estado_conteos_tiendas(inventario_id, almacen_id):
    """
    Obtiene el estado de los conteos por tienda, separando por tipo_conteo (por_cajas y por_stand)
    √ötil para el frontend para mostrar qu√© tiendas tienen conteos completados
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener todas las tiendas del almac√©n
        if almacen_id == 1:  # Callao
            # Callao no tiene tiendas (tienda_id = NULL)
            resultado = {
                'success': True,
                'almacen': 'Callao',
                'inventario_id': inventario_id,
                'conteos': {
                    'por_cajas': None,
                    'por_stand': None
                }
            }
            
            # Verificar conteo por cajas
            cursor.execute("""
                SELECT id, estado, tipo_conteo
                FROM conteos
                WHERE inventario_id = %s
                    AND almacen_id = %s
                    AND tienda_id IS NULL
                    AND tipo_conteo = 'por_cajas'
                    AND estado != 'anulado'
                ORDER BY id DESC
                LIMIT 1
            """, (inventario_id, almacen_id))
            conteo_cajas = cursor.fetchone()
            resultado['conteos']['por_cajas'] = {
                'existe': conteo_cajas is not None,
                'id': conteo_cajas['id'] if conteo_cajas else None,
                'estado': conteo_cajas['estado'] if conteo_cajas else None
            }
            
            # Verificar conteo por stand
            cursor.execute("""
                SELECT id, estado, tipo_conteo
                FROM conteos
                WHERE inventario_id = %s
                    AND almacen_id = %s
                    AND tienda_id IS NULL
                    AND tipo_conteo = 'por_stand'
                    AND estado != 'anulado'
                ORDER BY id DESC
                LIMIT 1
            """, (inventario_id, almacen_id))
            conteo_stand = cursor.fetchone()
            resultado['conteos']['por_stand'] = {
                'existe': conteo_stand is not None,
                'id': conteo_stand['id'] if conteo_stand else None,
                'estado': conteo_stand['estado'] if conteo_stand else None
            }
            
            return resultado
        else:  # Malvinas
            # Obtener todas las tiendas de Malvinas
            cursor.execute("""
                SELECT id, nombre_tienda 
                FROM tiendas 
                WHERE almacen_id = %s 
                ORDER BY id
            """, (almacen_id,))
            
            tiendas = cursor.fetchall()
            
            resultado = {
                'success': True,
                'almacen': 'Malvinas',
                'inventario_id': inventario_id,
                'tiendas': {}
            }
            
            # Para cada tienda, verificar estado de conteos por cajas y por stand
            for tienda in tiendas:
                tienda_id = tienda['id']
                nombre_tienda = tienda['nombre_tienda']
                
                # Verificar conteo por cajas
                cursor.execute("""
                    SELECT id, estado, tipo_conteo
                    FROM conteos
                    WHERE inventario_id = %s
                        AND almacen_id = %s
                        AND tienda_id = %s
                        AND tipo_conteo = 'por_cajas'
                        AND estado != 'anulado'
                    ORDER BY id DESC
                    LIMIT 1
                """, (inventario_id, almacen_id, tienda_id))
                conteo_cajas = cursor.fetchone()
                
                # Verificar conteo por stand
                cursor.execute("""
                    SELECT id, estado, tipo_conteo
                    FROM conteos
                    WHERE inventario_id = %s
                        AND almacen_id = %s
                        AND tienda_id = %s
                        AND tipo_conteo = 'por_stand'
                        AND estado != 'anulado'
                    ORDER BY id DESC
                    LIMIT 1
                """, (inventario_id, almacen_id, tienda_id))
                conteo_stand = cursor.fetchone()
                
                resultado['tiendas'][tienda_id] = {
                    'nombre': nombre_tienda,
                    'por_cajas': {
                        'existe': conteo_cajas is not None,
                        'id': conteo_cajas['id'] if conteo_cajas else None,
                        'estado': conteo_cajas['estado'] if conteo_cajas else None,
                        'completado': conteo_cajas['estado'] == 'finalizado' if conteo_cajas else False
                    },
                    'por_stand': {
                        'existe': conteo_stand is not None,
                        'id': conteo_stand['id'] if conteo_stand else None,
                        'estado': conteo_stand['estado'] if conteo_stand else None,
                        'completado': conteo_stand['estado'] == 'finalizado' if conteo_stand else False
                    }
                }
            
            return resultado
            
    except Exception as e:
        logging.error(f"Error en obtener_estado_conteos_tiendas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al obtener estado de conteos: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA LISTAR DATOS DEL SISTEMA CALLAO
# ============================================================
def listar_datos_sistema_callao(inventario_id):
    """
    Lista los datos del sistema cargados desde Excel para Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                id,
                producto_item as item,
                producto,
                codigo,
                cantidad_sistema,
                unidad_medida,
                DATE_FORMAT(fecha_carga, '%%d/%%m/%%Y %%H:%%i') as fecha_carga,
                archivo_origen,
                usuario_carga,
                estado
            FROM datos_sistema_callao
            WHERE inventario_id = %s AND estado = 'activo'
            ORDER BY producto
        """, (inventario_id,))
        
        datos = cursor.fetchall()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Callao',
            'datos': datos,
            'total_registros': len(datos)
        }
    except Exception as e:
        logging.error(f"Error en listar_datos_sistema_callao: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar datos del sistema: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER COMPARACION CALLAO
# ============================================================
def obtener_comparacion_callao(inventario_id):
    """
    Obtiene la tabla de comparaci√≥n para almac√©n Callao.
    SIEMPRE inyecta la cantidad f√≠sica real sumada desde los conteos.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 1. Obtener ID del almac√©n Callao (Necesario para ambos casos)
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Callao'")
        almacen_callao = cursor.fetchone()
        almacen_id = almacen_callao['id'] if almacen_callao else None
        
        if not almacen_id:
            return {
                'success': False,
                'message': 'No se encontr√≥ el almac√©n Callao'
            }
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (SIEMPRE)
        # Esto asegura que si acabas de contar, el dato se refleje inmediatamente
        # Incluimos todos los estados excepto 'anulado' para capturar conteos en proceso y finalizados
        
        # Primero verificar qu√© conteos existen para este inventario y almac√©n
        cursor.execute("""
            SELECT 
                c.id,
                c.estado,
                c.tipo_conteo,
                COUNT(dc.id) as total_detalles,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
            GROUP BY c.id, c.estado, c.tipo_conteo
        """, (inventario_id, almacen_id))
        
        conteos_info = cursor.fetchall()
        logging.info(f"[Callao] Inventario {inventario_id}, Almac√©n {almacen_id}: {len(conteos_info)} conteos encontrados")
        for c_info in conteos_info:
            logging.info(f"[Callao] Conteo ID {c_info['id']}: estado={c_info['estado']}, tipo={c_info['tipo_conteo']}, detalles={c_info['total_detalles']}, cantidad={c_info['cantidad_total']}")
        
        # Ahora obtener la suma por c√≥digo
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        # Diccionario {CODIGO: CANTIDAD} para acceso r√°pido
        # Normalizamos los c√≥digos a may√∫sculas y sin espacios
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # Log temporal para debugging (puedes removerlo despu√©s)
        logging.info(f"[Callao] Inventario {inventario_id}: Encontrados {len(conteos_fisicos)} c√≥digos con conteos f√≠sicos")
        if len(conteos_fisicos) > 0:
            logging.info(f"[Callao] Primeros 5 c√≥digos encontrados: {list(conteos_fisicos.keys())[:5]}")
        else:
            logging.warning(f"[Callao] ‚ö†Ô∏è NO se encontraron conteos f√≠sicos para inventario {inventario_id}, almac√©n {almacen_id}")
        
        # 3. Verificar si hay comparaciones generadas en base de datos
        cursor.execute("""
            SELECT COUNT(*) as total_comparaciones
            FROM comparaciones_callao
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        comparaciones_count = cursor.fetchone()['total_comparaciones']
        
        comparacion_final = []
        total_sistema = 0
        total_fisico = 0
        diferencia_total = 0
        conformes = 0
        sobrantes = 0
        faltantes = 0
        
        if comparaciones_count == 0:
            # --- CASO 1: NO EXISTE COMPARACI√ìN PREVIA (Generaci√≥n din√°mica pura) ---
            datos_sistema_response = listar_datos_sistema_callao(inventario_id)
            if not datos_sistema_response['success']:
                return datos_sistema_response
            
            datos_iterar = datos_sistema_response['datos']
        else:
            # --- CASO 2: YA EXISTE COMPARACI√ìN (Usamos la tabla base pero actualizamos conteos) ---
            cursor.execute("""
                SELECT 
                    cc.id,
                    cc.producto_item as item,
                    cc.producto,
                    cc.codigo,
                    cc.cantidad_sistema,
                    cc.cantidad_fisica, -- Este valor podr√≠a estar desactualizado
                    cc.resultado,
                    cc.estado,
                    cc.unidad_medida,
                    DATE_FORMAT(cc.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                    pi.unidad_medida as unidad_catalogo
                FROM comparaciones_callao cc
                LEFT JOIN productos_inventario pi ON cc.producto_item = pi.item
                WHERE cc.inventario_id = %s
                ORDER BY cc.estado DESC, cc.producto
            """, (inventario_id,))
            datos_iterar = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales en vivo
        for item in datos_iterar:
            # Normalizar c√≥digo del item (puede venir como string o None)
            codigo_original = item.get('codigo') or ''
            codigo = str(codigo_original).strip().upper()
            cant_sistema = float(item['cantidad_sistema'])
            
            # AQU√ç EST√Å LA MAGIA: Usamos siempre el conteo real calculado en el paso 2
            # si existe, sino usamos 0.
            # Buscar por c√≥digo normalizado
            cant_fisica = conteos_fisicos.get(codigo, 0.0)
            
            # Si no encontramos por c√≥digo exacto, intentar buscar variaciones
            if cant_fisica == 0.0 and codigo:
                # Intentar buscar sin guiones o con diferentes formatos
                codigo_sin_guion = codigo.replace('-', '')
                for key in conteos_fisicos.keys():
                    if key.replace('-', '') == codigo_sin_guion:
                        cant_fisica = conteos_fisicos[key]
                        break
            
            diferencia = cant_fisica - cant_sistema
            
            # Recalcular estado en vivo
            if diferencia == 0:
                estado = 'CONFORME'
                conformes += 1
            elif diferencia > 0:
                estado = 'SOBRANTE'
                sobrantes += 1
            else:
                estado = 'FALTANTE'
                faltantes += 1
                
            total_sistema += cant_sistema
            total_fisico += cant_fisica
            diferencia_total += diferencia
            
            # Construir objeto actualizado
            row = item.copy()
            row['cantidad_fisica'] = int(cant_fisica)  # Forzamos el valor real
            row['resultado'] = int(diferencia)
            row['estado'] = estado
            
            # Asegurar campos si venimos de datos_sistema (Caso 1)
            if 'unidad_catalogo' not in row:
                row['unidad_catalogo'] = row.get('unidad_medida', '')
            
            comparacion_final.append(row)
        
        # 5. Retornar estructura
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Callao',
            'comparaciones': comparacion_final,
            'resumen': {
                'total_productos': len(comparacion_final),
                'conformes': conformes,
                'sobrantes': sobrantes,
                'faltantes': faltantes,
                'total_sistema': int(total_sistema),
                'total_fisico': int(total_fisico),
                'diferencia_total': int(diferencia_total)
            },
            'sistema_cargado': True,
            'total_registros': len(comparacion_final)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA LISTAR DATOS DEL SISTEMA MALVINAS
# ============================================================
def listar_datos_sistema_malvinas(inventario_id):
    """
    Lista los datos del sistema cargados desde Excel para Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                id,
                producto_item as item,
                producto,
                codigo,
                cantidad_sistema,
                unidad_medida,
                DATE_FORMAT(fecha_carga, '%%d/%%m/%%Y %%H:%%i') as fecha_carga,
                archivo_origen,
                usuario_carga,
                estado
            FROM datos_sistema_malvinas
            WHERE inventario_id = %s AND estado = 'ACTIVO'
            ORDER BY producto
        """, (inventario_id,))
        
        datos = cursor.fetchall()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Malvinas',
            'datos': datos,
            'total_registros': len(datos)
        }
    except Exception as e:
        logging.error(f"Error en listar_datos_sistema_malvinas: {str(e)}")
        return {
            'success': False,
            'message': f'Error al listar datos del sistema: {str(e)}',
            'error': str(e)
        }
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER COMPARACION MALVINAS
# ============================================================
def obtener_comparacion_malvinas(inventario_id):
    """
    Obtiene la tabla de comparaci√≥n para almac√©n Malvinas.
    SIEMPRE inyecta la cantidad f√≠sica real sumada desde los conteos.
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 1. Obtener ID del almac√©n Malvinas (Necesario para ambos casos)
        cursor.execute("SELECT id FROM almacenes WHERE nombre = 'Malvinas'")
        almacen_malvinas = cursor.fetchone()
        almacen_id = almacen_malvinas['id'] if almacen_malvinas else None
        
        if not almacen_id:
            return {
                'success': False,
                'message': 'No se encontr√≥ el almac√©n Malvinas'
            }
        
        # 2. OBTENER SUMATORIA REAL DE CONTEOS F√çSICOS (SIEMPRE)
        # Esto asegura que si acabas de contar, el dato se refleje inmediatamente
        # Incluimos todos los estados excepto 'anulado' para capturar conteos en proceso y finalizados
        
        # Primero verificar qu√© conteos existen para este inventario y almac√©n
        cursor.execute("""
            SELECT 
                c.id,
                c.estado,
                c.tipo_conteo,
                COUNT(dc.id) as total_detalles,
                SUM(dc.cantidad) as cantidad_total
            FROM conteos c
            LEFT JOIN detalle_conteo dc ON c.id = dc.conteo_id
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
            GROUP BY c.id, c.estado, c.tipo_conteo
        """, (inventario_id, almacen_id))
        
        conteos_info = cursor.fetchall()
        logging.info(f"[Malvinas] Inventario {inventario_id}, Almac√©n {almacen_id}: {len(conteos_info)} conteos encontrados")
        for c_info in conteos_info:
            logging.info(f"[Malvinas] Conteo ID {c_info['id']}: estado={c_info['estado']}, tipo={c_info['tipo_conteo']}, detalles={c_info['total_detalles']}, cantidad={c_info['cantidad_total']}")
        
        # Ahora obtener la suma por c√≥digo
        cursor.execute("""
            SELECT 
                pi.codigo, 
                SUM(dc.cantidad) as total_fisico
            FROM detalle_conteo dc
            JOIN conteos c ON dc.conteo_id = c.id
            JOIN productos_inventario pi ON dc.item_producto = pi.item
            WHERE c.inventario_id = %s 
                AND c.almacen_id = %s 
                AND c.estado != 'anulado'
                AND dc.cantidad > 0
            GROUP BY pi.codigo
        """, (inventario_id, almacen_id))
        
        # Diccionario {CODIGO: CANTIDAD} para acceso r√°pido
        # Normalizamos los c√≥digos a may√∫sculas y sin espacios
        conteos_fisicos = {}
        conteos_raw = cursor.fetchall()
        for row in conteos_raw:
            codigo_normalizado = str(row['codigo']).strip().upper() if row['codigo'] else ''
            if codigo_normalizado:
                conteos_fisicos[codigo_normalizado] = float(row['total_fisico'])
        
        # Log temporal para debugging (puedes removerlo despu√©s)
        logging.info(f"[Malvinas] Inventario {inventario_id}: Encontrados {len(conteos_fisicos)} c√≥digos con conteos f√≠sicos")
        if len(conteos_fisicos) > 0:
            logging.info(f"[Malvinas] Primeros 5 c√≥digos encontrados: {list(conteos_fisicos.keys())[:5]}")
        else:
            logging.warning(f"[Malvinas] ‚ö†Ô∏è NO se encontraron conteos f√≠sicos para inventario {inventario_id}, almac√©n {almacen_id}")
        
        # 3. Verificar si hay comparaciones generadas en base de datos
        cursor.execute("""
            SELECT COUNT(*) as total_comparaciones
            FROM comparaciones_malvinas
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        comparaciones_count = cursor.fetchone()['total_comparaciones']
        
        comparacion_final = []
        total_sistema = 0
        total_fisico = 0
        diferencia_total = 0
        conformes = 0
        sobrantes = 0
        faltantes = 0
        
        if comparaciones_count == 0:
            # --- CASO 1: NO EXISTE COMPARACI√ìN PREVIA (Generaci√≥n din√°mica pura) ---
            datos_sistema_response = listar_datos_sistema_malvinas(inventario_id)
            if not datos_sistema_response['success']:
                return datos_sistema_response
            
            datos_iterar = datos_sistema_response['datos']
        else:
            # --- CASO 2: YA EXISTE COMPARACI√ìN (Usamos la tabla base pero actualizamos conteos) ---
            cursor.execute("""
                SELECT 
                    cm.id,
                    cm.producto_item as item,
                    cm.producto,
                    cm.codigo,
                    cm.cantidad_sistema,
                    cm.cantidad_fisica, -- Este valor podr√≠a estar desactualizado
                    cm.resultado,
                    cm.estado,
                    cm.unidad_medida,
                    DATE_FORMAT(cm.fecha_comparacion, '%%d/%%m/%%Y %%H:%%i') as fecha_comparacion,
                    pi.unidad_medida as unidad_catalogo
                FROM comparaciones_malvinas cm
                LEFT JOIN productos_inventario pi ON cm.producto_item = pi.item
                WHERE cm.inventario_id = %s
                ORDER BY cm.estado DESC, cm.producto
            """, (inventario_id,))
            datos_iterar = cursor.fetchall()
        
        # 4. Procesar y mezclar con los conteos reales en vivo
        for item in datos_iterar:
            # Normalizar c√≥digo del item (puede venir como string o None)
            codigo_original = item.get('codigo') or ''
            codigo = str(codigo_original).strip().upper()
            cant_sistema = float(item['cantidad_sistema'])
            
            # AQU√ç EST√Å LA MAGIA: Usamos siempre el conteo real calculado en el paso 2
            # si existe, sino usamos 0.
            # Buscar por c√≥digo normalizado
            cant_fisica = conteos_fisicos.get(codigo, 0.0)
            
            # Si no encontramos por c√≥digo exacto, intentar buscar variaciones
            if cant_fisica == 0.0 and codigo:
                # Intentar buscar sin guiones o con diferentes formatos
                codigo_sin_guion = codigo.replace('-', '')
                for key in conteos_fisicos.keys():
                    if key.replace('-', '') == codigo_sin_guion:
                        cant_fisica = conteos_fisicos[key]
                        break
            
            diferencia = cant_fisica - cant_sistema
            
            # Recalcular estado en vivo
            if diferencia == 0:
                estado = 'CONFORME'
                conformes += 1
            elif diferencia > 0:
                estado = 'SOBRANTE'
                sobrantes += 1
            else:
                estado = 'FALTANTE'
                faltantes += 1
                
            total_sistema += cant_sistema
            total_fisico += cant_fisica
            diferencia_total += diferencia
            
            # Construir objeto actualizado
            row = item.copy()
            row['cantidad_fisica'] = int(cant_fisica)  # Forzamos el valor real
            row['resultado'] = int(diferencia)
            row['estado'] = estado
            
            # Asegurar campos si venimos de datos_sistema (Caso 1)
            if 'unidad_catalogo' not in row:
                row['unidad_catalogo'] = row.get('unidad_medida', '')
            
            comparacion_final.append(row)
        
        # 5. Retornar estructura
        return {
            'success': True,
            'inventario_id': inventario_id,
            'almacen': 'Malvinas',
            'comparaciones': comparacion_final,
            'resumen': {
                'total_productos': len(comparacion_final),
                'conformes': conformes,
                'sobrantes': sobrantes,
                'faltantes': faltantes,
                'total_sistema': int(total_sistema),
                'total_fisico': int(total_fisico),
                'diferencia_total': int(diferencia_total)
            },
            'sistema_cargado': True,
            'total_registros': len(comparacion_final)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA EDITAR CANTIDAD FISICA
# ============================================================
def editar_cantidad_fisica(data):
    """
    Edita la cantidad f√≠sica de un producto en la comparaci√≥n
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        comparacion_id = data['comparacion_id']
        almacen = data['almacen']
        nueva_cantidad = data['nueva_cantidad']
        motivo = data.get('motivo', '')
        registrado_por = data['registrado_por']
        error_de = data.get('error_de', '')
        observaciones = data.get('observaciones', '')
        
        # Determinar tabla seg√∫n almac√©n
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        
        # Obtener datos actuales
        cursor.execute(f"""
            SELECT 
                cantidad_fisica, producto_item, producto, codigo, inventario_id
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (comparacion_id,))
        
        comparacion = cursor.fetchone()
        
        if not comparacion:
            return {'success': False, 'message': 'Comparaci√≥n no encontrada'}
        
        cantidad_anterior = comparacion['cantidad_fisica']
        
        # Actualizar comparaci√≥n
        cursor.execute(f"""
            UPDATE {tabla_comparacion}
            SET cantidad_fisica = %s,
                resultado = %s - cantidad_sistema,
                estado = CASE
                    WHEN %s = cantidad_sistema THEN 'CONFORME'
                    WHEN %s > cantidad_sistema THEN 'SOBRANTE'
                    ELSE 'FALTANTE'
                END,
                ultima_actualizacion = CURRENT_TIMESTAMP
            WHERE id = %s
        """, (nueva_cantidad, nueva_cantidad, nueva_cantidad, nueva_cantidad, comparacion_id))
        
        # Registrar en tabla de ediciones
        cursor.execute("""
            INSERT INTO ediciones_cantidad_fisica (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto, cantidad_fisica_anterior,
                cantidad_fisica_nueva, motivo, registrado_por,
                error_de, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion_id,
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            cantidad_anterior,
            nueva_cantidad,
            motivo,
            registrado_por,
            error_de,
            observaciones
        ))
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, cantidad_afectada,
                error_de, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'EDITAR_CANTIDAD_FISICA',
            motivo,
            nueva_cantidad - cantidad_anterior,
            error_de,
            registrado_por,
            json.dumps({
                'cantidad_anterior': cantidad_anterior,
                'cantidad_nueva': nueva_cantidad,
                'diferencia': nueva_cantidad - cantidad_anterior
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'message': 'Cantidad f√≠sica actualizada correctamente',
            'comparacion_id': comparacion_id,
            'diferencia': nueva_cantidad - cantidad_anterior
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA EDITAR CANTIDAD SISTEMA
# ============================================================
def editar_cantidad_sistema(data):
    """
    Edita la cantidad del sistema de un producto en la comparaci√≥n
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        comparacion_id = data['comparacion_id']
        almacen = data['almacen']
        nueva_cantidad = data['nueva_cantidad']
        motivo = data.get('motivo', '')
        registrado_por = data['registrado_por']
        error_de = data.get('error_de', '')
        observaciones = data.get('observaciones', '')
        
        # Determinar tabla seg√∫n almac√©n
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        tabla_sistema = 'datos_sistema_callao' if almacen == 'callao' else 'datos_sistema_malvinas'
        
        # Obtener datos actuales
        cursor.execute(f"""
            SELECT 
                cantidad_sistema, producto_item, producto, codigo, inventario_id
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (comparacion_id,))
        
        comparacion = cursor.fetchone()
        
        if not comparacion:
            return {'success': False, 'message': 'Comparaci√≥n no encontrada'}
        
        cantidad_anterior = comparacion['cantidad_sistema']
        
        # Actualizar comparaci√≥n
        cursor.execute(f"""
            UPDATE {tabla_comparacion}
            SET cantidad_sistema = %s,
                resultado = cantidad_fisica - %s,
                estado = CASE
                    WHEN cantidad_fisica = %s THEN 'CONFORME'
                    WHEN cantidad_fisica > %s THEN 'SOBRANTE'
                    ELSE 'FALTANTE'
                END,
                ultima_actualizacion = CURRENT_TIMESTAMP
            WHERE id = %s
        """, (nueva_cantidad, nueva_cantidad, nueva_cantidad, nueva_cantidad, comparacion_id))
        
        # Actualizar datos del sistema
        cursor.execute(f"""
            UPDATE {tabla_sistema}
            SET cantidad_sistema = %s,
                estado = 'MODIFICADO'
            WHERE inventario_id = %s AND codigo = %s
        """, (nueva_cantidad, comparacion['inventario_id'], comparacion['codigo']))
        
        # Registrar en tabla de ediciones
        cursor.execute("""
            INSERT INTO ediciones_cantidad_sistema (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto, cantidad_sistema_anterior,
                cantidad_sistema_nueva, motivo, registrado_por,
                error_de, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion_id,
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            cantidad_anterior,
            nueva_cantidad,
            motivo,
            registrado_por,
            error_de,
            observaciones
        ))
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, cantidad_afectada,
                error_de, registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'EDITAR_CANTIDAD_SISTEMA',
            motivo,
            nueva_cantidad - cantidad_anterior,
            error_de,
            registrado_por,
            json.dumps({
                'cantidad_anterior': cantidad_anterior,
                'cantidad_nueva': nueva_cantidad,
                'diferencia': nueva_cantidad - cantidad_anterior
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'message': 'Cantidad sistema actualizada correctamente',
            'comparacion_id': comparacion_id,
            'diferencia': nueva_cantidad - cantidad_anterior
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA REGISTRAR VERIFICACION 
# ============================================================
def registrar_verificacion(data):
    """
    Registra una verificaci√≥n detallada para un producto
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener datos del sistema y f√≠sico
        almacen = data['almacen']
        tabla_comparacion = 'comparaciones_callao' if almacen == 'callao' else 'comparaciones_malvinas'
        
        cursor.execute(f"""
            SELECT 
                cantidad_fisica, cantidad_sistema, producto_item,
                producto, codigo, inventario_id
            FROM {tabla_comparacion}
            WHERE id = %s
        """, (data['comparacion_id'],))
        
        comparacion = cursor.fetchone()
        
        if not comparacion:
            return {'success': False, 'message': 'Comparaci√≥n no encontrada'}
        
        # Calcular stock_existencia (Compras - Ventas)
        compras_totales = float(data.get('compras_totales', 0))
        ventas_totales = float(data.get('ventas_totales', 0))
        stock_existencia = compras_totales - ventas_totales
        
        stock_fisico = float(comparacion['cantidad_fisica'])
        stock_sistema = float(comparacion['cantidad_sistema'])
        
        # Calcular estado de verificaci√≥n seg√∫n los 4 casos
        # Caso 1: stock_existencia coincide con stock_fisico pero NO con stock_sistema ‚Üí Error de Sistema
        # Caso 2: stock_existencia coincide con stock_sistema pero NO con stock_fisico ‚Üí Error de Log√≠stica
        # Caso 3: stock_existencia NO coincide ni con stock_fisico ni con stock_sistema ‚Üí Nuevo conteo requerido
        # Caso 4: todos coinciden ‚Üí CONFORME
        
        estado_verificacion = None
        mensaje_estado = ''
        
        # Usar tolerancia peque√±a para comparaciones de decimales
        tolerancia = 0.01
        
        coincide_existencia_fisico = abs(stock_existencia - stock_fisico) < tolerancia
        coincide_existencia_sistema = abs(stock_existencia - stock_sistema) < tolerancia
        coincide_fisico_sistema = abs(stock_fisico - stock_sistema) < tolerancia
        
        if coincide_existencia_fisico and coincide_existencia_sistema and coincide_fisico_sistema:
            # Caso 4: Todos coinciden
            estado_verificacion = 'CONFORME'
            mensaje_estado = 'Todos los valores coinciden correctamente'
        elif coincide_existencia_fisico and not coincide_existencia_sistema:
            # Caso 1: Existencia = F√≠sico, pero Sistema es diferente
            estado_verificacion = 'ERROR_SISTEMA'
            mensaje_estado = f'El sistema est√° mal. Stock existencia ({stock_existencia}) coincide con f√≠sico ({stock_fisico}) pero no con sistema ({stock_sistema})'
        elif coincide_existencia_sistema and not coincide_existencia_fisico:
            # Caso 2: Existencia = Sistema, pero F√≠sico es diferente
            estado_verificacion = 'ERROR_LOGISTICA'
            mensaje_estado = f'Error de log√≠stica. Stock existencia ({stock_existencia}) coincide con sistema ({stock_sistema}) pero no con f√≠sico ({stock_fisico})'
        else:
            # Caso 3: Existencia no coincide ni con f√≠sico ni con sistema
            estado_verificacion = 'NUEVO_CONTEO_REQUERIDO'
            mensaje_estado = f'Se requiere nuevo conteo. Stock existencia ({stock_existencia}) no coincide ni con f√≠sico ({stock_fisico}) ni con sistema ({stock_sistema})'
        
        # Insertar verificaci√≥n
        cursor.execute("""
            INSERT INTO verificaciones (
                comparacion_id, almacen, inventario_id, producto_item,
                codigo_producto, producto,
                
                -- Compras
                fecha_ingreso_compra, hora_ingreso_compra,
                numero_acta, fecha_descarga_compra, hora_descarga_compra,
                
                -- Ventas
                fecha_descarga_ventas, hora_descarga_ventas,
                fecha_descarga_sistema, hora_descarga_sistema,
                
                -- Resultado General
                compras_totales, ventas_totales, stock_existencia,
                
                -- Resultado de Verificaci√≥n
                stock_fisico, stock_sistema, estado_verificacion,
                mensaje_estado,
                
                -- Metadatos
                registrado_por, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                     %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                     %s, %s, %s)
        """, (
            data['comparacion_id'],
            almacen,
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['codigo'],
            comparacion['producto'],
            
            # Compras
            data.get('fecha_ingreso_compra'),
            data.get('hora_ingreso_compra'),
            data.get('numero_acta'),
            data.get('fecha_descarga_compra'),
            data.get('hora_descarga_compra'),
            
            # Ventas
            data.get('fecha_descarga_ventas'),
            data.get('hora_descarga_ventas'),
            data.get('fecha_descarga_sistema'),
            data.get('hora_descarga_sistema'),
            
            # Resultado General
            data.get('compras_totales', 0),
            data.get('ventas_totales', 0),
            stock_existencia,
            
            # Resultado de Verificaci√≥n
            stock_fisico,
            stock_sistema,
            estado_verificacion,
            mensaje_estado,
            
            # Metadatos
            data['registrado_por'],
            data.get('observaciones', '')
        ))
        
        verificacion_id = cursor.lastrowid
        
        # Registrar en historial
        cursor.execute("""
            INSERT INTO historial_acciones_comparacion (
                inventario_id, producto_item, producto, codigo,
                almacen, tipo_accion, motivo, error_de,
                registrado_por, detalles
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            comparacion['inventario_id'],
            comparacion['producto_item'],
            comparacion['producto'],
            comparacion['codigo'],
            almacen,
            'VERIFICACION',
            data.get('motivo', ''),
            estado_verificacion if estado_verificacion != 'CONFORME' else '',
            data['registrado_por'],
            json.dumps({
                'verificacion_id': verificacion_id,
                'stock_existencia': stock_existencia,
                'estado': estado_verificacion,
                'mensaje': mensaje_estado
            })
        ))
        
        conn.commit()
        
        return {
            'success': True,
            'verificacion_id': verificacion_id,
            'estado_verificacion': estado_verificacion,
            'mensaje_estado': mensaje_estado,
            'message': 'Verificaci√≥n registrada correctamente'
        }
            
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# ============================================================
# FUNCION PARA OBTENER EL HISTORIAL DE ACCIONES DE COMPARACION
# ============================================================
def obtener_historial_acciones(inventario_id):
    """
    Obtiene el historial completo de acciones de comparaci√≥n
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                h.id,
                h.inventario_id,
                i.numero_inventario,
                h.producto_item as item,
                h.producto,
                h.codigo,
                h.almacen,
                h.tipo_accion,
                h.motivo,
                h.cantidad_afectada as cantidad,
                h.error_de,
                h.registrado_por,
                DATE_FORMAT(h.fecha_hora, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_hora,
                h.fecha_hora as fecha_hora_raw,
                h.detalles
            FROM historial_acciones_comparacion h
            JOIN inventarios i ON h.inventario_id = i.id
            WHERE h.inventario_id = %s
            ORDER BY h.fecha_hora DESC
        """, (inventario_id,))
        
        acciones = cursor.fetchall()
        
        # Convertir detalles JSON a string
        for accion in acciones:
            if accion['detalles']:
                try:
                    accion['detalles'] = json.loads(accion['detalles'])
                except:
                    accion['detalles'] = str(accion['detalles'])
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'acciones': acciones,
            'total_acciones': len(acciones)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ============================================================
# FUNCION PARA OBTENER VERIFICACIONES DE CADA PRODUCTO
# ============================================================
def obtener_verificaciones_producto(comparacion_id, almacen):
    """
    Obtiene las verificaciones realizadas para un producto espec√≠fico
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                v.*,
                DATE_FORMAT(v.fecha_hora, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_hora_formateada,
                DATE_FORMAT(v.fecha_actualizacion, '%%d/%%m/%%Y %%H:%%i:%%s') as fecha_actualizacion_formateada
            FROM verificaciones v
            WHERE v.comparacion_id = %s AND v.almacen = %s
            ORDER BY v.fecha_hora DESC
        """, (comparacion_id, almacen))
        
        verificaciones = cursor.fetchall()
        
        return {
            'success': True,
            'comparacion_id': comparacion_id,
            'almacen': almacen,
            'verificaciones': verificaciones,
            'total_verificaciones': len(verificaciones)
        }
            
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

# ***********************************************************************
# =======================================================================
# FUNCIONES PARA MODULO DE CONSOLIDADO (CALLAO - MALVINAS - GENERAL)
# =======================================================================
# ***********************************************************************

def generar_consolidado_callao(data):
    """
    Genera el consolidado de inventario para almac√©n Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Llamar al stored procedure
        cursor.callproc('sp_generar_consolidado_callao', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_consolidado_callao_1, @_sp_generar_consolidado_callao_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_consolidado_callao_1']
        mensaje = result['@_sp_generar_consolidado_callao_2']
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def generar_consolidado_malvinas(data):
    """
    Genera el consolidado de inventario para almac√©n Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Llamar al stored procedure
        cursor.callproc('sp_generar_consolidado_malvinas', [
            inventario_id,
            0,  # OUT p_registros_procesados
            ''  # OUT p_mensaje
        ])
        
        cursor.execute('SELECT @_sp_generar_consolidado_malvinas_1, @_sp_generar_consolidado_malvinas_2')
        result = cursor.fetchone()
        
        registros_procesados = result['@_sp_generar_consolidado_malvinas_1']
        mensaje = result['@_sp_generar_consolidado_malvinas_2']
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'message': mensaje
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def generar_consolidado_general(data):
    """
    Genera el consolidado general que integra Callao y Malvinas
    SIN ELIMINAR registros anteriores, solo agrega nuevos o actualiza
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # 1. Obtener datos de Callao
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                unidad_medida
            FROM consolidado_inventario_callao
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        callao_data = {row['codigo']: row for row in cursor.fetchall()}
        
        # 2. Obtener datos de Malvinas
        cursor.execute("""
            SELECT 
                codigo,
                producto_item,
                producto,
                sistema,
                fisico,
                unidad_medida
            FROM consolidado_inventario_malvinas
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        malvinas_data = {row['codigo']: row for row in cursor.fetchall()}
        
        # 3. Obtener todos los c√≥digos √∫nicos
        todos_codigos = set(callao_data.keys()) | set(malvinas_data.keys())
        
        if not todos_codigos:
            return {
                'success': False,
                'message': 'No hay datos de consolidado para Callao o Malvinas. Genere los consolidados primero.'
            }
        
        registros_procesados = 0
        registros_actualizados = 0
        registros_nuevos = 0
        
        # 4. Procesar cada producto
        for codigo in todos_codigos:
            callao = callao_data.get(codigo, {})
            malvinas = malvinas_data.get(codigo, {})
            
            callao_sistema = callao.get('sistema', 0) if callao else 0
            callao_fisico = callao.get('fisico', 0) if callao else 0
            malvinas_sistema = malvinas.get('sistema', 0) if malvinas else 0
            malvinas_fisico = malvinas.get('fisico', 0) if malvinas else 0
            
            total_sistema = callao_sistema + malvinas_sistema
            total_fisico = callao_fisico + malvinas_fisico
            diferencia = total_fisico - total_sistema
            
            # Determinar resultado
            if total_fisico == total_sistema:
                resultado = 'CONFORME'
            elif total_fisico > total_sistema:
                resultado = 'SOBRANTE'
            else:
                resultado = 'FALTANTE'
            
            producto = callao.get('producto') if callao else malvinas.get('producto', '')
            producto_item = callao.get('producto_item') if callao else malvinas.get('producto_item')
            unidad_medida = callao.get('unidad_medida') if callao else malvinas.get('unidad_medida', '')
            
            # Verificar si ya existe en consolidado general
            cursor.execute("""
                SELECT id, total_sistema, total_fisico 
                FROM consolidado_general 
                WHERE inventario_id = %s AND codigo = %s
                ORDER BY fecha_consolidacion DESC
                LIMIT 1
            """, (inventario_id, codigo))
            
            existente = cursor.fetchone()
            
            if existente:
                # Verificar si los datos han cambiado
                if (existente['total_sistema'] != total_sistema or 
                    existente['total_fisico'] != total_fisico):
                    
                    cursor.execute("""
                        UPDATE consolidado_general
                        SET total_sistema = %s,
                            total_fisico = %s,
                            diferencia = %s,
                            resultado = %s,
                            callao_sistema = %s,
                            callao_fisico = %s,
                            malvinas_sistema = %s,
                            malvinas_fisico = %s,
                            ultima_actualizacion = CURRENT_TIMESTAMP
                        WHERE id = %s
                    """, (
                        total_sistema,
                        total_fisico,
                        diferencia,
                        resultado,
                        callao_sistema,
                        callao_fisico,
                        malvinas_sistema,
                        malvinas_fisico,
                        existente['id']
                    ))
                    registros_actualizados += 1
                else:
                    registros_procesados += 1
            else:
                # Insertar nuevo registro
                cursor.execute("""
                    INSERT INTO consolidado_general (
                        inventario_id, producto_item, producto, codigo,
                        total_sistema, total_fisico, diferencia, resultado,
                        unidad_medida, callao_sistema, callao_fisico,
                        malvinas_sistema, malvinas_fisico
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    inventario_id,
                    producto_item,
                    producto,
                    codigo,
                    total_sistema,
                    total_fisico,
                    diferencia,
                    resultado,
                    unidad_medida,
                    callao_sistema,
                    callao_fisico,
                    malvinas_sistema,
                    malvinas_fisico
                ))
                registros_nuevos += 1
        
        registros_procesados = len(todos_codigos)
        
        conn.commit()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'registros_procesados': registros_procesados,
            'registros_nuevos': registros_nuevos,
            'registros_actualizados': registros_actualizados,
            'message': f'Consolidado General: {registros_nuevos} nuevos, {registros_actualizados} actualizados'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()
            
def generar_todos_consolidados(data):
    """
    Genera todos los consolidados (Callao, Malvinas y General) de una sola vez
    SIN ELIMINAR registros anteriores
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        inventario_id = data.get('inventario_id')
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Generar consolidado Callao
        result_callao = generar_consolidado_callao({'inventario_id': inventario_id})
        
        # Generar consolidado Malvinas
        result_malvinas = generar_consolidado_malvinas({'inventario_id': inventario_id})
        
        # Generar consolidado General
        result_general = generar_consolidado_general({'inventario_id': inventario_id})
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'callao': {
                'success': result_callao.get('success', False),
                'nuevos': result_callao.get('registros_nuevos', 0),
                'actualizados': result_callao.get('registros_actualizados', 0),
                'message': result_callao.get('message', '')
            },
            'malvinas': {
                'success': result_malvinas.get('success', False),
                'nuevos': result_malvinas.get('registros_nuevos', 0),
                'actualizados': result_malvinas.get('registros_actualizados', 0),
                'message': result_malvinas.get('message', '')
            },
            'general': {
                'success': result_general.get('success', False),
                'nuevos': result_general.get('registros_nuevos', 0),
                'actualizados': result_general.get('registros_actualizados', 0),
                'message': result_general.get('message', '')
            },
            'message': 'Consolidados generados/actualizados correctamente'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.rollback()
        raise e
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def obtener_consolidado_callao(inventario_id=None):
    """
    Obtiene el consolidado de inventario para almac√©n Callao
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener consolidado
        cursor.execute("""
            SELECT 
                id,
                inventario_id,
                producto_item,
                producto,
                codigo,
                sistema,
                fisico,
                diferencia,
                unidad_medida,
                DATE_FORMAT(fecha_consolidacion, '%d/%m/%Y %H:%i:%s') as fecha_consolidacion_formateada
            FROM consolidado_inventario_callao
            WHERE inventario_id = %s
            ORDER BY producto
        """, (inventario_id,))
        
        consolidado = cursor.fetchall()
        
        # Obtener resumen
        cursor.execute("""
            SELECT 
                COUNT(*) as total_productos,
                SUM(sistema) as total_sistema,
                SUM(fisico) as total_fisico,
                SUM(diferencia) as diferencia_total,
                SUM(CASE WHEN fisico > sistema THEN 1 ELSE 0 END) as productos_sobrantes,
                SUM(CASE WHEN fisico < sistema THEN 1 ELSE 0 END) as productos_faltantes,
                SUM(CASE WHEN fisico = sistema THEN 1 ELSE 0 END) as productos_conformes
            FROM consolidado_inventario_callao
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        resumen = cursor.fetchone()
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        
        inventario_info = cursor.fetchone()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'almacen': 'Callao',
            'consolidado': consolidado,
            'resumen': resumen,
            'total_registros': len(consolidado)
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

def obtener_consolidado_malvinas(inventario_id=None):
    """
    Obtiene el consolidado de inventario para almac√©n Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener consolidado
        cursor.execute("""
            SELECT 
                id,
                inventario_id,
                producto_item,
                producto,
                codigo,
                sistema,
                fisico,
                diferencia,
                unidad_medida,
                DATE_FORMAT(fecha_consolidacion, '%d/%m/%Y %H:%i:%s') as fecha_consolidacion_formateada
            FROM consolidado_inventario_malvinas
            WHERE inventario_id = %s
            ORDER BY producto
        """, (inventario_id,))
        
        consolidado = cursor.fetchall()
        
        # Obtener resumen
        cursor.execute("""
            SELECT 
                COUNT(*) as total_productos,
                SUM(sistema) as total_sistema,
                SUM(fisico) as total_fisico,
                SUM(diferencia) as diferencia_total,
                SUM(CASE WHEN fisico > sistema THEN 1 ELSE 0 END) as productos_sobrantes,
                SUM(CASE WHEN fisico < sistema THEN 1 ELSE 0 END) as productos_faltantes,
                SUM(CASE WHEN fisico = sistema THEN 1 ELSE 0 END) as productos_conformes
            FROM consolidado_inventario_malvinas
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        resumen = cursor.fetchone()
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        
        inventario_info = cursor.fetchone()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'almacen': 'Malvinas',
            'consolidado': consolidado,
            'resumen': resumen,
            'total_registros': len(consolidado)
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

def obtener_consolidado_general(inventario_id=None):
    """
    Obtiene el consolidado general que integra Callao y Malvinas
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            # Si no se especifica inventario, buscar el activo
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener consolidado general
        cursor.execute("""
            SELECT 
                id,
                inventario_id,
                producto_item,
                producto,
                codigo,
                total_sistema,
                total_fisico,
                diferencia,
                resultado,
                unidad_medida,
                callao_sistema,
                callao_fisico,
                malvinas_sistema,
                malvinas_fisico,
                DATE_FORMAT(fecha_consolidacion, '%d/%m/%Y %H:%i:%s') as fecha_consolidacion_formateada
            FROM consolidado_general
            WHERE inventario_id = %s
            ORDER BY producto
        """, (inventario_id,))
        
        consolidado = cursor.fetchall()
        
        # Obtener resumen general
        cursor.execute("""
            SELECT 
                COUNT(*) as total_productos,
                SUM(total_sistema) as gran_total_sistema,
                SUM(total_fisico) as gran_total_fisico,
                SUM(diferencia) as diferencia_total,
                SUM(CASE WHEN resultado = 'SOBRANTE' THEN 1 ELSE 0 END) as total_sobrantes,
                SUM(CASE WHEN resultado = 'FALTANTE' THEN 1 ELSE 0 END) as total_faltantes,
                SUM(CASE WHEN resultado = 'CONFORME' THEN 1 ELSE 0 END) as total_conformes,
                SUM(callao_sistema) as total_callao_sistema,
                SUM(callao_fisico) as total_callao_fisico,
                SUM(malvinas_sistema) as total_malvinas_sistema,
                SUM(malvinas_fisico) as total_malvinas_fisico
            FROM consolidado_general
            WHERE inventario_id = %s
        """, (inventario_id,))
        
        resumen = cursor.fetchone()
        
        # Obtener informaci√≥n del inventario
        cursor.execute("""
            SELECT numero_inventario, area, autorizado_por, fecha_hora_asignacion
            FROM inventarios
            WHERE id = %s
        """, (inventario_id,))
        
        inventario_info = cursor.fetchone()
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'inventario': inventario_info,
            'tipo': 'CONSOLIDADO_GENERAL',
            'consolidado': consolidado,
            'resumen': resumen,
            'total_registros': len(consolidado)
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

def obtener_consolidados_completos(inventario_id=None):
    """
    Obtiene todos los consolidados (Callao, Malvinas y General) en una sola respuesta
    """
    try:
        if not inventario_id:
            inventario_activo = obtener_inventario_activo()
            if inventario_activo['success']:
                inventario_id = inventario_activo['inventario']['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener cada consolidado
        callao = obtener_consolidado_callao(inventario_id)
        malvinas = obtener_consolidado_malvinas(inventario_id)
        general = obtener_consolidado_general(inventario_id)
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'callao': callao if callao['success'] else None,
            'malvinas': malvinas if malvinas['success'] else None,
            'general': general if general['success'] else None
        }
        
    except Exception as e:
        raise e

def exportar_consolidado_excel(inventario_id=None, tipo='general'):
    """
    Exporta los consolidados a formato Excel (CSV para descarga)
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Obtener informaci√≥n del inventario
        cursor.execute("SELECT numero_inventario FROM inventarios WHERE id = %s", (inventario_id,))
        inventario = cursor.fetchone()
        numero_inventario = inventario['numero_inventario'] if inventario else 'INV-' + str(inventario_id)
        
        # Determinar qu√© consolidado exportar
        if tipo == 'callao':
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    sistema as 'SISTEMA',
                    fisico as 'FISICO',
                    diferencia as 'DIFERENCIA',
                    unidad_medida as 'UNIDAD',
                    fecha_consolidacion as 'FECHA'
                FROM consolidado_inventario_callao
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_callao_{numero_inventario}.csv"
            
        elif tipo == 'malvinas':
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    sistema as 'SISTEMA',
                    fisico as 'FISICO',
                    diferencia as 'DIFERENCIA',
                    unidad_medida as 'UNIDAD',
                    fecha_consolidacion as 'FECHA'
                FROM consolidado_inventario_malvinas
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_malvinas_{numero_inventario}.csv"
            
        else:  # general
            cursor.execute("""
                SELECT 
                    producto_item as 'ITEM',
                    producto as 'PRODUCTO',
                    codigo as 'CODIGO',
                    total_sistema as 'TOTAL SISTEMA',
                    total_fisico as 'TOTAL FISICO',
                    diferencia as 'DIFERENCIA',
                    resultado as 'RESULTADO',
                    unidad_medida as 'UNIDAD',
                    callao_sistema as 'CALLAO SISTEMA',
                    callao_fisico as 'CALLAO FISICO',
                    malvinas_sistema as 'MALVINAS SISTEMA',
                    malvinas_fisico as 'MALVINAS FISICO'
                FROM consolidado_general
                WHERE inventario_id = %s
                ORDER BY producto
            """, (inventario_id,))
            data = cursor.fetchall()
            filename = f"consolidado_general_{numero_inventario}.csv"
        
        if not data:
            return {'success': False, 'message': 'No hay datos para exportar'}
        
        # Convertir a DataFrame de pandas
        df = pd.DataFrame(data)
        
        # Crear archivo CSV en memoria
        csv_buffer = io.StringIO()
        df.to_csv(csv_buffer, index=False, encoding='utf-8')
        csv_content = csv_buffer.getvalue()
        
        return {
            'success': True,
            'filename': filename,
            'content': csv_content,
            'content_type': 'text/csv'
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()

def verificar_consolidados_generados(inventario_id=None):
    """
    Verifica si ya se generaron los consolidados para un inventario
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if not inventario_id:
            cursor.execute("SELECT id FROM inventarios WHERE estado = 'activo' LIMIT 1")
            inventario = cursor.fetchone()
            if inventario:
                inventario_id = inventario['id']
            else:
                return {'success': False, 'message': 'No se especific√≥ inventario y no hay inventario activo'}
        
        # Verificar Callao
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_inventario_callao 
            WHERE inventario_id = %s
        """, (inventario_id,))
        callao_count = cursor.fetchone()['count']
        
        # Verificar Malvinas
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_inventario_malvinas 
            WHERE inventario_id = %s
        """, (inventario_id,))
        malvinas_count = cursor.fetchone()['count']
        
        # Verificar General
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM consolidado_general 
            WHERE inventario_id = %s
        """, (inventario_id,))
        general_count = cursor.fetchone()['count']
        
        return {
            'success': True,
            'inventario_id': inventario_id,
            'consolidados_generados': {
                'callao': callao_count > 0,
                'malvinas': malvinas_count > 0,
                'general': general_count > 0
            },
            'registros': {
                'callao': callao_count,
                'malvinas': malvinas_count,
                'general': general_count
            }
        }
        
    except Exception as e:
        raise e
    finally:
        cursor.close()
        conn.close()



# ============================================================
# FUNCI√ìN PRINCIPAL
# ============================================================
@functions_framework.http
def inventario_general_logistica(request):
    headers = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type"
    }

    if request.method == "OPTIONS":
        return ("", 200, headers)

    # Identificar el m√©todo HTTP actual
    method = request.method

    # Variable para guardar la respuesta temporalmente
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # Obtener acci√≥n y datos
        # IMPORTANTE: No llamar get_json() si es multipart/form-data (archivos)
        # porque consume el stream y luego request.files queda vac√≠o
        content_type = request.content_type or ''
        is_multipart = 'multipart/form-data' in content_type
        
        if is_multipart:
            # Para multipart, solo usar form y args
            request_json = {}
            action = request.args.get('action') or request.form.get('action')
        else:
            # Para JSON, obtener el JSON
            request_json = request.get_json(silent=True) or {}
            action = request.args.get('action') or request_json.get('action') or request.form.get('action')
        
        response_data = {'success': False, 'message': f'Acci√≥n "{action}" no reconocida'}

        # --- Enrutador de Acciones con Validaci√≥n de M√©todos ---
        # =========================================================================
        # ACCIONES PARA M√ìDULO DE CONTEO (CAJAS/STANDS - TIENDAS) CALLAO Y MALVINAS 
        # =========================================================================
        # ASIGNAR INVENTARIO (POST)
        if action == 'asignar_inventario' and method == 'POST':
            response_data = asignar_inventario(request_json)
            
        # UNIR COLABORADOR (POST)
        elif action == 'unir_colaborador' and method == 'POST':
            response_data = unir_colaborador_inventario(request_json)

        # ACTUALIZAR UBICACI√ìN DEL COLABORADOR (POST)
        elif action == 'actualizar_ubicacion' and method == 'POST':
            response_data = actualizar_ubicacion_colaborador(
                request_json.get('nombre_colaborador'),
                request_json.get('inventario_id'),
                request_json.get('conteo_id') # Puede ser None si sale de la tienda
            )

        # OBTENER PRESENCIA DE COLABORADORES (GET)
        elif action == 'obtener_presencia' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if not inventario_id:
                # Intento obtener el activo si no env√≠an ID
                activo = obtener_inventario_activo()
                inventario_id = activo['inventario']['id'] if activo['success'] else None
            
            if inventario_id:
                response_data = obtener_presencia_colaboradores(inventario_id)
            else:
                response_data = {'success': False, 'message': 'Falta inventario_id'}    
            
        # INICIAR CONTEO (POST)
        elif action == 'iniciar_conteo' and method == 'POST':
            response_data = iniciar_conteo(request_json)
            
        # CARGAR EXCEL EMERGENCIA (POST con archivo)
        elif action == 'cargar_excel_emergencia' and method == 'POST':
            response_data = cargar_excel_emergencia(request)
            
        # OBTENER DETALLE DE CONTEO (GET)
        elif action == 'obtener_detalle_conteo' and method == 'GET':
            conteo_id = request.args.get('conteo_id')
            response_data = obtener_detalle_conteo(conteo_id)
            
        # DIAGN√ìSTICO DE CANTIDADES (GET) - Para debugging
        elif action == 'diagnosticar_cantidades' and method == 'GET':
            conteo_id = request.args.get('conteo_id')
            if not conteo_id:
                response_data = {'success': False, 'message': 'Falta par√°metro conteo_id'}
            else:
                try:
                    conteo_id = int(conteo_id)
                    response_data = diagnosticar_cantidades_conteo(conteo_id)
                except (ValueError, TypeError):
                    response_data = {'success': False, 'message': 'conteo_id inv√°lido'}
            
        # LISTAR CONTEOS INICIADOS (EN PROCESO) (GET)
        elif action == 'listar_conteos_iniciados' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = listar_conteos_iniciados(inventario_id)
            
        # ACTUALIZAR CANTIDAD INDIVIDUAL (POST)
        elif action == 'actualizar_cantidad_individual' and method == 'POST':
            # Log para debugging: ver qu√© datos est√°n llegando
            logging.info(f"[ROUTER] actualizar_cantidad_individual recibido. Datos: {request_json}")
            response_data = actualizar_cantidad_producto_individual(request_json)
            logging.info(f"[ROUTER] actualizar_cantidad_individual respuesta: {response_data}")
            
        # ACTUALIZACI√ìN MASIVA (POST) - FUNCI√ìN SOLICITADA
        elif action == 'actualizar_masivo' and method == 'POST':
            # Log para debugging: ver qu√© datos est√°n llegando
            logging.info(f"[ROUTER] actualizar_masivo recibido. Conteo ID: {request_json.get('conteo_id')}, Productos: {len(request_json.get('productos', []))}")
            response_data = actualizar_masivo_productos(request_json)
            logging.info(f"[ROUTER] actualizar_masivo respuesta: success={response_data.get('success')}, registros={response_data.get('registros_actualizados', 0)}")
            
        # FINALIZAR CONTEO (POST)
        elif action == 'finalizar_conteo' and method == 'POST':
            response_data = finalizar_conteo(request_json)
            
        # CERRAR INVENTARIO ACTIVO (POST)
        elif action == 'cerrar_inventario' and method == 'POST':
            response_data = cerrar_inventario(request_json)
            
        # LISTAR INVENTARIOS (GET) - Todos o solo activos
        elif action == 'listar_inventarios' and method == 'GET':
            solo_activos = request.args.get('solo_activos', 'false').lower() == 'true'
            response_data = listar_inventarios(filtrar_activos=solo_activos)
            
        # OBTENER INVENTARIO ACTIVO (GET)
        elif action == 'obtener_inventario_activo' and method == 'GET':
            response_data = obtener_inventario_activo()
            
        # LISTAR CONTEO CALLAO (GET) - FUNCI√ìN SOLICITADA
        elif action == 'listar_conteos_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = listar_conteos_callao(inventario_id)
            else:
                # Si no se especifica inventario, buscar el activo
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = listar_conteos_callao(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # LISTAR CONTEO MALVINAS (GET) - FUNCI√ìN SOLICITADA
        # OBTENER ESTADO DE CONTEOS POR TIENDA (GET) - Para frontend
        elif action == 'obtener_estado_conteos_tiendas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            almacen_id = request.args.get('almacen_id')
            
            if not inventario_id or not almacen_id:
                response_data = {
                    'success': False,
                    'message': 'Faltan par√°metros: inventario_id y almacen_id son requeridos'
                }
            else:
                try:
                    inventario_id = int(inventario_id)
                    almacen_id = int(almacen_id)
                    response_data = obtener_estado_conteos_tiendas(inventario_id, almacen_id)
                except (ValueError, TypeError):
                    response_data = {
                        'success': False,
                        'message': 'inventario_id y almacen_id deben ser n√∫meros v√°lidos'
                    }
                    
        elif action == 'listar_conteos_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = listar_conteos_malvinas(inventario_id)
            else:
                # Si no se especifica inventario, buscar el activo
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = listar_conteos_malvinas(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER HISTORIAL DE CONTEOS CALLAO (GET) - TODOS LOS USUARIOS
        elif action == 'obtener_historial_conteos_callao' and method == 'GET':
            try:
                page = int(request.args.get('page', 1))
                per_page = int(request.args.get('per_page', 10))
                response_data = obtener_historial_conteos_callao(page, per_page)
            except (ValueError, TypeError):
                response_data = {
                    'success': False,
                    'message': 'page y per_page deben ser n√∫meros v√°lidos'
                }
                    
        # OBTENER HISTORIAL DE CONTEOS MALVINAS (GET) - TODOS LOS USUARIOS
        elif action == 'obtener_historial_conteos_malvinas' and method == 'GET':
            try:
                page = int(request.args.get('page', 1))
                per_page = int(request.args.get('per_page', 10))
                response_data = obtener_historial_conteos_malvinas(page, per_page)
            except (ValueError, TypeError):
                response_data = {
                    'success': False,
                    'message': 'page y per_page deben ser n√∫meros v√°lidos'
                }
                    
        # LISTAR PRODUCTOS DEL CATALOGO (GET)
        elif action == 'listar_productos_inventario' and method == 'GET':
            response_data = listar_productos_inventario()

        # ======================================================
        # ACCIONES PARA M√ìDULO DE COMPARACI√ìN
        # ======================================================
        
        # CARGAR SISTEMA CALLAO (POST con archivo)
        elif action == 'cargar_sistema_callao' and method == 'POST':
            response_data = cargar_sistema_callao(request)
            
        # CARGAR SISTEMA MALVINAS (POST con archivo)
        elif action == 'cargar_sistema_malvinas' and method == 'POST':
            response_data = cargar_sistema_malvinas(request)
            
        # GENERAR COMPARACI√ìN CALLAO (POST)
        elif action == 'generar_comparacion_callao' and method == 'POST':
            response_data = generar_comparacion_callao(request_json)
            
        # GENERAR COMPARACI√ìN MALVINAS (POST)
        elif action == 'generar_comparacion_malvinas' and method == 'POST':
            response_data = generar_comparacion_malvinas(request_json)
            
        # OBTENER COMPARACI√ìN CALLAO (GET)
        elif action == 'obtener_comparacion_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = obtener_comparacion_callao(inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_comparacion_callao(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER COMPARACI√ìN MALVINAS (GET)
        elif action == 'obtener_comparacion_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = obtener_comparacion_malvinas(inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_comparacion_malvinas(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # EDITAR CANTIDAD F√çSICA (POST)
        elif action == 'editar_cantidad_fisica' and method == 'POST':
            response_data = editar_cantidad_fisica(request_json)
            
        # EDITAR CANTIDAD SISTEMA (POST)
        elif action == 'editar_cantidad_sistema' and method == 'POST':
            response_data = editar_cantidad_sistema(request_json)
            
        # REGISTRAR VERIFICACI√ìN (POST)
        elif action == 'registrar_verificacion' and method == 'POST':
            response_data = registrar_verificacion(request_json)
            
        # OBTENER HISTORIAL DE ACCIONES (GET)
        elif action == 'obtener_historial_acciones' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            if inventario_id:
                response_data = obtener_historial_acciones(inventario_id)
            else:
                inventario_activo = obtener_inventario_activo()
                if inventario_activo['success']:
                    inventario_id = inventario_activo['inventario']['id']
                    response_data = obtener_historial_acciones(inventario_id)
                else:
                    response_data = inventario_activo
                    
        # OBTENER VERIFICACIONES PRODUCTO (GET)
        elif action == 'obtener_verificaciones_producto' and method == 'GET':
            comparacion_id = request.args.get('comparacion_id')
            almacen = request.args.get('almacen')
            if comparacion_id and almacen:
                response_data = obtener_verificaciones_producto(comparacion_id, almacen)
            else:
                response_data = {'success': False, 'message': 'Se requiere comparacion_id y almacen'}

        # ======================================================
        # ACCIONES PARA M√ìDULO DE CONSOLIDADO 
        # ======================================================
        
        # GENERAR CONSOLIDADO CALLAO (POST)
        elif action == 'generar_consolidado_callao' and method == 'POST':
            response_data = generar_consolidado_callao(request_json)
            
        # GENERAR CONSOLIDADO MALVINAS (POST)
        elif action == 'generar_consolidado_malvinas' and method == 'POST':
            response_data = generar_consolidado_malvinas(request_json)
            
        # GENERAR CONSOLIDADO GENERAL (POST)
        elif action == 'generar_consolidado_general' and method == 'POST':
            response_data = generar_consolidado_general(request_json)
            
        # GENERAR TODOS LOS CONSOLIDADOS (POST)
        elif action == 'generar_todos_consolidados' and method == 'POST':
            response_data = generar_todos_consolidados(request_json)
            
        # OBTENER CONSOLIDADO CALLAO (GET)
        elif action == 'obtener_consolidado_callao' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = obtener_consolidado_callao(inventario_id)
            
        # OBTENER CONSOLIDADO MALVINAS (GET)
        elif action == 'obtener_consolidado_malvinas' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = obtener_consolidado_malvinas(inventario_id)
            
        # OBTENER CONSOLIDADO GENERAL (GET)
        elif action == 'obtener_consolidado_general' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = obtener_consolidado_general(inventario_id)
            
        # OBTENER CONSOLIDADOS COMPLETOS (GET)
        elif action == 'obtener_consolidados_completos' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = obtener_consolidados_completos(inventario_id)
            
        # EXPORTAR CONSOLIDADO EXCEL (GET)
        elif action == 'exportar_consolidado_excel' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            tipo = request.args.get('tipo', 'general')
            response_data = exportar_consolidado_excel(inventario_id, tipo)
            
        # VERIFICAR CONSOLIDADOS GENERADOS (GET)
        elif action == 'verificar_consolidados' and method == 'GET':
            inventario_id = request.args.get('inventario_id')
            response_data = verificar_consolidados_generados(inventario_id)
            

        return (json.dumps(response_data, default=str), 200, headers)
        
    except Exception as e:
        if 'conn' in locals() and conn.open: 
            conn.rollback()
        logging.error(f"Error en inventario: {str(e)}")
        return (json.dumps({'success': False, 'error': str(e)}), 500, headers)
    finally:
        if 'cursor' in locals(): 
            cursor.close()
        if 'conn' in locals(): 
            conn.close()